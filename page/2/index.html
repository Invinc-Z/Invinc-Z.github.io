<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">
<link rel="preconnect" href="https://fonts.loli.net" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/android-chrome-512x512.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.css" integrity="sha256-zM8WXtG4eUn7dKKNMTuoWZub++VnSfaOpA/8PJfvTBo=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"invinc-z.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.23.1","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="Welcome to my blog! Here I share tech tips and life stories.">
<meta property="og:type" content="website">
<meta property="og:title" content="Invinc-Z Blog">
<meta property="og:url" content="https://invinc-z.com/page/2/index.html">
<meta property="og:site_name" content="Invinc-Z Blog">
<meta property="og:description" content="Welcome to my blog! Here I share tech tips and life stories.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Invinc-Z">
<meta property="article:tag" content="编程技术,C,C++,Linux,LaTeX">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://invinc-z.com/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Invinc-Z Blog - Plain Life and Wonderful Moments</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.js" integrity="sha256-hiUEBwFEpLF6DlB8sGXlKo4kPZ46Ui4qGpd0vrVkOm4=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>


  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous" defer></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://invinc-z.com/page/2/"}</script>
  <script src="/js/third-party/quicklink.js" defer></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Invinc-Z Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Plain Life and Wonderful Moments</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-公告"><a href="/bulletin/" rel="section"><i class="fa fa-bullhorn fa-fw"></i>公告</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-书单"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书单</a></li><li class="menu-item menu-item-友链"><a href="/friends/" rel="section"><i class="fa fa-users fa-fw"></i>友链</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Invinc-Z"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Invinc-Z</p>
  <div class="site-description" itemprop="description">Welcome to my blog! Here I share tech tips and life stories.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ludmluYy1a" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Invinc-Z"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnpodWFuZ196aGFuZ185N0AxNjMuY29t" title="E-Mail → mailto:zhuang_zhang_97@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vdS81NjQ0MTM3NTM0" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5644137534"><i class="fab fa-weibo fa-fw"></i>微博</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS8=" title="https:&#x2F;&#x2F;www.runoob.com&#x2F;">菜鸟教程</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9zaXRlbWFwLw==" title="http:&#x2F;&#x2F;c.biancheng.net&#x2F;sitemap&#x2F;">C语言中文网</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9jc2RpeS53aWtpLw==" title="https:&#x2F;&#x2F;csdiy.wiki&#x2F;">CS自学指南</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly93d3cucjJjb2RpbmcuY29tLyMv" title="https:&#x2F;&#x2F;www.r2coding.com&#x2F;#&#x2F;">Road To Coding</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9oYWNrd2F5Lm9yZy9kb2NzL2NzL2ludHJv" title="https:&#x2F;&#x2F;hackway.org&#x2F;docs&#x2F;cs&#x2F;intro">计算机专业学习路线</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9maXNoYy5jb20uY24=" title="https:&#x2F;&#x2F;fishc.com.cn">鱼C论坛</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/lang_latex/notes_lshort/03_document_elements/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lang_latex/notes_lshort/03_document_elements/" class="post-title-link" itemprop="url">$\LaTeX{}$ 之文档元素（三）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-13 05:12:18" itemprop="dateCreated datePublished" datetime="2025-01-13T05:12:18+08:00">2025-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 23:18:22" itemprop="dateModified" datetime="2025-06-06T23:18:22+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LaTeX/" itemprop="url" rel="index"><span itemprop="name">LaTeX</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LaTeX/LaTeX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">LaTeX学习笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>在知道了如何输入文字后，本章介绍一个结构化的文档所依赖的各种元素——章节、目录、列表、图表、交叉引用、脚注等等。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/lang_latex/notes_lshort/03_document_elements/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/lang_latex/notes_lshort/02_typeset_text/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lang_latex/notes_lshort/02_typeset_text/" class="post-title-link" itemprop="url">用 $\LaTeX{}$ 排版文字（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-07 05:12:18" itemprop="dateCreated datePublished" datetime="2025-01-07T05:12:18+08:00">2025-01-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 23:17:58" itemprop="dateModified" datetime="2025-06-06T23:17:58+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LaTeX/" itemprop="url" rel="index"><span itemprop="name">LaTeX</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LaTeX/LaTeX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">LaTeX学习笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>文字是排版的基础。本章主要介绍如何在 <span
class="math inline">\(\LaTeX{}\)</span>
中输入各种文字符号，包括标点符号、连字符、重音等，以及控制文字断行和断页的方式。本章简要介绍了在
<span class="math inline">\(\LaTeX{}\)</span> 中排版中文的方法。随着
<span class="math inline">\(\LaTeX{}\)</span> 和底层 <span
class="math inline">\(\TeX{}\)</span>引擎的发展，旧方式（<span
class="math inline">\(\texttt{CCT}\)</span>、<span
class="math inline">\(\texttt{CJK}\)</span>等）日渐退出舞台，<span
class="math inline">\(\texttt{xelatex}\)</span> 和 <span
class="math inline">\(\texttt{lualatex}\)</span> 编译命令配合 <span
class="math inline">\(\texttt{ctex}\)</span>
宏包/文档类的方式成为当前的主流中文排版支持方式。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/lang_latex/notes_lshort/02_typeset_text/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/lang_latex/notes_lshort/01_basic_concepts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lang_latex/notes_lshort/01_basic_concepts/" class="post-title-link" itemprop="url">$\LaTeX{}$ 的基本概念（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-01 05:12:18" itemprop="dateCreated datePublished" datetime="2025-01-01T05:12:18+08:00">2025-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 10:23:05" itemprop="dateModified" datetime="2025-06-06T10:23:05+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LaTeX/" itemprop="url" rel="index"><span itemprop="name">LaTeX</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LaTeX/LaTeX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">LaTeX学习笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>欢迎使用 <span
class="math inline">\(\LaTeX{}\)</span>！本文开头介绍了<span
class="math inline">\(\LaTeX{}\)</span>的来源，然后介绍了<span
class="math inline">\(\LaTeX{}\)</span>源代码的写法，编译<span
class="math inline">\(\LaTeX{}\)</span>源代码生成文档的方法，以及理解接下来的章节的一些必要知识。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/lang_latex/notes_lshort/01_basic_concepts/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/lang_c/c_file_stream_api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lang_c/c_file_stream_api/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-10-14 15:02:43 / 修改时间：16:08:47" itemprop="dateCreated datePublished" datetime="2024-10-14T15:02:43+08:00">2024-10-14</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>959</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="c语言之文件流常用api">C语言之文件流常用API</h1>
<h2 id="文件流常用api">文件流常用API</h2>
<p>使用下列文件流API需要包含头文件<code>stdio.h</code></p>
<div data-align="center">
<table>
<thead>
<tr>
<th style="text-align:left">
</th>
<th style="text-align:left">
函数
</th>
<th style="text-align:left">
作用
</th>
<th style="text-align:left">
注意事项
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left" rowspan="2">
打开或关闭文件流
</td>
<td style="text-align:left">
<code>fopen</code>
</td>
<td style="text-align:left">
打开文件，返回指向FILE的指针
</td>
<td style="text-align:left">
需要指定模式（如“r”, “w”, “a”等），并处理可能的文件打开错误
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fclose</code>
</td>
<td style="text-align:left">
关闭文件流，释放流资源
</td>
<td style="text-align:left">
确保每个打开的文件流最终都被关闭，避免资源泄露
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
读写二进制文件流
</td>
<td style="text-align:left">
<code>fread</code>
</td>
<td style="text-align:left">
从文件流中读取数据
</td>
<td style="text-align:left">
需要检查返回值以确定读取的数据量和是否遇到错误或EOF
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fwrite</code>
</td>
<td style="text-align:left">
向文件流中写入数据
</td>
<td style="text-align:left">
需要检查返回值以确保数据正确写入
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
逐字符读写文本文件流
</td>
<td style="text-align:left">
<code>fgetc</code>
</td>
<td style="text-align:left">
从文件流中读取下一个字符
</td>
<td style="text-align:left">
在达到文件末尾或出现错误时返回EOF
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fputc</code>
</td>
<td style="text-align:left">
将一个字符写入文件流
</td>
<td style="text-align:left">
返回写入的字符，若出现错误则返回EOF
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
逐行读写文本文件流
</td>
<td style="text-align:left">
<code>fgets</code>
</td>
<td style="text-align:left">
从文件流中读取字符串（一行）
</td>
<td style="text-align:left">
确保正确处理缓冲区长度和行尾字符
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fputs</code>
</td>
<td style="text-align:left">
将字符串（不包括NUL终止符）写入文件流
</td>
<td style="text-align:left">
不会自动添加换行符，需手动处理
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
格式化读写文本文件流
</td>
<td style="text-align:left">
<code>fscanf</code>
</td>
<td style="text-align:left">
从文件流中格式化读取数据
</td>
<td style="text-align:left">
与<code>scanf</code>类似，但从文件流读取
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fprintf</code>
</td>
<td style="text-align:left">
格式化输出到文件流
</td>
<td style="text-align:left">
类似于<code>printf</code>，但输出到文件流
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
文件流状态检查
</td>
<td style="text-align:left">
<code>feof</code>
</td>
<td style="text-align:left">
检查文件流的EOF标志
</td>
<td style="text-align:left">
通常用于循环读取数据时判断文件是否结束
</td>
</tr>
<tr>
<td style="text-align:left">
<code>ferror</code>
</td>
<td style="text-align:left">
检查文件流的错误指示器
</td>
<td style="text-align:left">
用于错误处理和调试
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="3">
文件定位
</td>
<td style="text-align:left">
<code>ftell</code>
</td>
<td style="text-align:left">
返回文件流的当前文件位置指示器
</td>
<td style="text-align:left">
配合<code>fseek</code>可实现文件的随机访问
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fseek</code>
</td>
<td style="text-align:left">
设置文件流的文件位置指示器
</td>
<td style="text-align:left">
可用于移动文件指针到特定位置
</td>
</tr>
<tr>
<td style="text-align:left">
<code>rewind</code>
</td>
<td style="text-align:left">
将文件流的文件位置指示器重置到文件开头
</td>
<td style="text-align:left">
等同于<code>fseek(stream, 0, SEEK_SET)</code>
</td>
</tr>
<tr>
<td style="text-align:left">
刷新输出缓冲区
</td>
<td style="text-align:left">
<code>fflush</code>
</td>
<td style="text-align:left">
清空文件流的输出缓冲区
</td>
<td style="text-align:left">
常用于确保所有输出已经从缓冲区写入文件
</td>
</tr>
</tbody>
</table>
</div>
<p>2.. 3.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/lang_c/binary_search_algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lang_c/binary_search_algorithm/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-08 20:52:20" itemprop="dateCreated datePublished" datetime="2024-10-08T20:52:20+08:00">2024-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-09 10:32:10" itemprop="dateModified" datetime="2024-10-09T10:32:10+08:00">2024-10-09</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二分查找算法">二分查找算法</h1>
<h2 id="基本思路">基本思路</h2>
<p>二分查找的基本思路如下：</p>
<ol type="1">
<li><strong>找到中间元素：</strong>查找过程从数组的中间元素开始，如果中间元素恰好是目标元素，则查找过程结束。</li>
<li><strong>比较并缩小范围：</strong>如果中间元素不是目标元素，那么将中间元素与目标值进行比较：
<ol type="1">
<li>如果目标值小于中间元素，则说明目标值位于当前搜索范围的左半部分。</li>
<li>如果目标值大于中间元素，则说明目标值位于当前搜索范围的右半部分。</li>
</ol></li>
<li><strong>重复上述过程。</strong>不断重复上述过程，每次都将搜索范围缩小一半，直到找到目标值或者发现目标元素不存在。</li>
</ol>
<p>二分查找的关键在于每次比较后都能排除一半的搜索范围，这使得查找效率非常高，尤其是在大型数组中。</p>
<p><strong>这种算法的时间复杂度为 O(log n)，其中 n
是数组的长度。</strong></p>
<h2 id="代码实现">代码实现</h2>
<h3 id="递归实现">递归实现</h3>
<details>
<summary>
<font size="4" color="orange">递归实现二分查找</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int bs_recursion(int arr[], int left, int right, int target) &#123;
    // 递归的出口
    // 如果区间已不存在, 则二分查找结束, 没找到目标元素
    if (left > right) &#123;
        return -1;
    &#125;
    int mid = left + (right - left >> 1);
    int diff = target - arr[mid];
    if (diff < 0)
        return bs_recursion(arr, left, mid - 1, target);
    if (diff > 0)
        return bs_recursion(arr, mid + 1, right, target);
    return mid;
&#125;
int binary_search(int arr[], int len, int target) &#123;
    bs_recursion(arr, 0, len - 1, target);
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 7;
    int idx = binary_search(arr, len, target);
    printf("查找目标元素%d, 它在数组中的索引是%d\n", target, idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="循环实现">循环实现</h3>
<details>
<summary>
<font size="4" color="orange">循环实现二分查找</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        int diff = target - arr[mid];
        if (diff < 0)      
            right = mid - 1;
        else if (diff > 0) 
            left = mid + 1;
        else
            return mid;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 100;
    int idx = binary_search(arr, len, target);
    printf("查找目标元素%d, 它在数组中的索引是%d\n", target, idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="二分查找变体">二分查找变体</h3>
<details>
<summary>
<font size="4" color="orange">查找数组中第一个与目标值相等的元素</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search_first(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        int diff = target - arr[mid];
        if (diff < 0)
            right = mid - 1;
        else if (diff > 0)
            left = mid + 1;
        else &#123;
            if (mid == left || arr[mid - 1] < target)
            &#123;
                return mid;
            &#125;
            right = mid - 1;
        &#125;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 7;
    int idx = binary_search_first(arr, len, target);
    printf("查找目标元素%d, 它在数组中的第一个索引是%d\n", target, idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange">查找数组中最后一个与目标值相等的元素</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search_last(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        int diff = target - arr[mid];
        if (diff < 0)
            right = mid - 1;
        else if (diff > 0)
            left = mid + 1;
        else &#123;
            if (mid == right || arr[mid + 1] > target)
            &#123;
                return mid;
            &#125;
            left = mid + 1;
        &#125;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 7;
    int idx = binary_search_last(arr, len, target);
    printf("查找目标元素%d, 它在数组中的最后一个索引是%d\n", target, idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange">查找数组中第一个大于等于目标值的元素</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search_first_gt(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        if (arr[mid] < target)
            left = mid + 1;
        else &#123;
            if (mid == left || arr[mid - 1] < target)
            &#123;
                return mid;
            &#125;
            right = mid - 1;
        &#125;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 7;
    int idx = binary_search_first_gt(arr, len, target);
    printf("查找数组中第一个大于等于目标值%d的元素, 它是%d, 在索引%d\n", target,arr[idx], idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange">查找数组中最后一个小于等于目标值的元素</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search_last_lt(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        if (arr[mid] > target)
            right = mid - 1;
        else &#123;
            if (mid == right || arr[mid + 1] > target)
            &#123;
                return mid;
            &#125;
            left = mid + 1;
        &#125;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 8;
    int idx = binary_search_last_lt(arr, len, target);
    printf("查找数组中最后一个小于等于目标值%d的元素, 它是%d, 在索引%d\n", target, arr[idx], idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h2 id="典型应用">典型应用</h2>
<h3 id="ip归属地查询">IP归属地查询</h3>
<h3 id="改进插入排序">改进插入排序</h3>
<p>二分查找是可以改进插入排序的，其核心思路是，每一轮插入排序都会有一张”新抓手牌”，而”旧手牌”是一个已经有序的数组。传统的做法是：</p>
<p>让”新手牌”逐一和”旧手牌”有序数组中的元素逐一比较，然后确定”新手牌”的插入位置，向后移动元素，将”新手牌”插入。如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202401150718625.png" alt="二分查找-改进插入排序" style="zoom: 50%;" />
</div>
<p>当数据量比较大时，“旧手牌”比较多，有序数组很长时，可以考虑用二分查找，替代逐一比较查找待插入位置。那么这个二分查找是在找什么呢？</p>
<p>当然是查找<strong>最后一个小于等于”新手牌”值的元素</strong>，这样就可以直接将它后面的所有元素后移一位，然后再它后面直接插入”新手牌”。</p>
<p>当然，这种改进在实际应用中并不常见：</p>
<ol type="1">
<li>插入排序本身就应用于小数据集，大数据集情况下大多不会选择插入排序。</li>
<li>既然是应用于小数据集，数组本身较短，用二分查找的意义就不大了。对效率的提升不明显，而且还增加了复杂性。</li>
</ol>
<details>
<summary>
<font size="4" color="orange">使用二分查找改进的插入排序</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_sort(int arr[], int left,int right, int target) &#123;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        if (arr[mid]>target)
        &#123;
            right = mid - 1;
        &#125;
        else
        &#123;
            if (mid == right||arr[mid+1]>target)
            &#123;
                return mid;
            &#125;
            left = mid + 1;
        &#125;
    &#125;
    return -1;
&#125;
void binary_insertion_sort(int arr[], int len) &#123;
    for (int i = 1; i < len; i++)
    &#123;
        int value = arr[i];
        // 使用二分查找找到应插入的位置
        // idx(不包括)后面的所有元素都有后移一位，idx + 1是value要插入的位置
        int idx = binary_sort(arr, 0,i-1, value);
        int j = i - 1;  // j在这里赋值为有序数组的最后一个元素
        while (j > idx) &#123;       // 有序数组中的元素只要下标大于idx就后移 也就是不包括idx，但idx后面的所有元素都要后移
            arr[j + 1] = arr[j];
            j--;
        &#125; // j == idx;
        arr[j + 1] = value;
    &#125;
&#125;
int main(void) &#123;
    int arr[] = &#123; 9, 5, 2, 7, 1, 3, 4, 0, 8, 6 &#125;;
    int len = ARR_LEN(arr);
    binary_insertion_sort(arr, len);
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/lang_c/c_data_structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lang_c/c_data_structure/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-06 12:34:13" itemprop="dateCreated datePublished" datetime="2024-09-06T12:34:13+08:00">2024-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-07 15:52:32" itemprop="dateModified" datetime="2025-06-07T15:52:32+08:00">2025-06-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:16</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="c-语言之常用数据结构">C 语言之常用数据结构</h1>
<p>在日常的工作开发中，最常用的数据结构有：数组、链表、栈、队列、哈希表和二叉搜索树。其中：</p>
<ol type="1">
<li><p><strong>数组和链表是线性数据结构的两种典型物理实现。</strong>
它们是最基础的数据结构，是构成其它更复杂数据结构的基石。</p>
<ul>
<li><p>数组采用一段连续的内存空间存储，最大的特点是基于索引的快速随机访问。</p></li>
<li><p>链表则由非连续存储的、基于指针链接的结点组成，提供了灵活的插入和删除操作。</p></li>
</ul></li>
<li><p><strong>栈和队列是数组和链表的经典应用场景。</strong>
它们都可以基于数组或链表实现，不同的是栈遵循先进后出的原则，而队列遵循先进先出的原则。</p></li>
<li><p><strong>哈希表</strong>
通常结合数组与链表来实现，用于提供快速的数据查询能力。</p></li>
<li><p><strong>二叉搜索树</strong>
是一种基于树形的数据结构，它提供了优秀的搜索效率。二叉搜索树在实现时可以借鉴链表的实现思路，所以它和链表也有一定的关联。</p></li>
</ol>
<p><strong>如何学习数据结构？</strong></p>
<p>学习一种数据结构，可以从三个角度入手：</p>
<ol type="1">
<li><strong>理论基础与模型。</strong>
学习一种数据结构，首先要做的就是理解它的概念模型以及知晓其理论基础，包括其特点、用途和适用场景等。</li>
<li><strong>基础操作。</strong>
在掌握了基本理论后，就需要进一步熟悉该数据结构的基础操作以及这些操作的工作原理。这些基础操作一般包括：增、删、查以及遍历。(改操作是查操作的扩展)</li>
<li><strong>实现与应用。</strong>
在了解理论和操作后，就可以编写代码来实现这些数据结构了，这不仅有助于巩固理解数据结构，同时也能提升编程能力。</li>
</ol>
<p><strong>推荐两个学习网站：</strong></p>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly92aXN1YWxnby5uZXQvemgv">Visualgo
可视化数据结构与算法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudXNmY2EuZWR1L35nYWxsZXMvdmlzdWFsaXphdGlvbi9BbGdvcml0aG1zLmh0bWw=">Data
Structure Visualization (usfca.edu)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h2 id="动态数组">动态数组</h2>
<p>数组是一种基本的、常见的数据结构，它以其快速的访问速度而著称。</p>
<p>然而，在 C
语言中，传统的数组(指在栈上分配内存空间的数组)拥有一个显著的限制：它们的长度一旦确定便无法更改。这在处理动态数据集时显得尤为不便，如在不确定数据量的情况下存储用户输入。</p>
<p>C++通过引入 Vector 这样的动态数组解决了这个问题(Java 中的 ArrayList
也是类似的)，它可以根据需要动态调整大小。遗憾的是，C
语言标准库中并未提供类似的结构。但不要担心，借助于动态内存分配函数如
malloc 和 realloc，我们完全可以在 C 中手动实现类似的功能。</p>
<h3 id="设计思路">设计思路</h3>
<p>在 C 语言中实现一个动态数组，通常使用一个结构体定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用别名来命名元素类型，如果未来需要改变元素类型，只需修改这个别名即可。</span></span><br><span class="line"><span class="comment">// 这么做提升代码的可维护性和扩展性, 这实际上是模拟了 C++的泛型编程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElementType *data;      <span class="comment">// 指向动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">// 当前动态数组中元素的数量</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 动态数组当前分配的最大容量</span></span><br><span class="line">&#125; Vector;</span><br></pre></td></tr></table></figure>
可以用下图来理解一个 Vector 动态数组：
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311131037946.png" alt="Vector动态数组-内存示意图" style="zoom: 33%;" />
</div>
<p>除此之外，为了满足正常的动态数组的功能，我们还需要实现以下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个 Vector 动态数组.这实际上是模拟了 C++的默认构造函数</span></span><br><span class="line">Vector* <span class="title function_">vector_create</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 销毁一个 Vector 动态数组，释放内存。这实际上模拟了 C++的析构函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_destroy</span><span class="params">(Vector* v)</span>;</span><br><span class="line"><span class="comment">// 向动态数组末尾添加一个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_push_back</span><span class="params">(Vector* v, ElementType element)</span>;</span><br><span class="line"><span class="comment">// 在动态数组最前面添加元素，所有元素依次后移</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_push_front</span><span class="params">(Vector* v, ElementType val)</span>;</span><br><span class="line"><span class="comment">// 将元素 val 添加到索引为 idx 的位置，idx 后面的元素依次后移</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_insert</span><span class="params">(Vector* v, <span class="type">int</span> idx, ElementType val)</span>;</span><br><span class="line"><span class="comment">// 遍历打印整个 Vector 动态数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_print</span><span class="params">(Vector* v)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现">代码实现</h3>
<details>
<summary>
<font size="4" color="orange"> vector.h </font>
</summary>
<pre> <code class="language-c"> #pragma once
// 使用别名来命名元素类型，如果未来需要改变元素类型，只需修改这个别名即可。
// 这么做提升代码的可维护性和扩展性, 这实际上是模拟了 C++/Java 等编程语言的泛型编程
typedef int ElementType;
typedef struct &#123;
    ElementType* data;      // 指向动态分配数组的指针
    int size;    // 当前动态数组中元素的数量
    int capacity; // 动态数组当前分配的最大容量
&#125; Vector;
// 初始化一个 Vector 动态数组.这实际上是模拟了 C++的默认构造函数
Vector* vector_create();
// 销毁一个 Vector 动态数组，释放内存。这实际上模拟了 C++的析构函数
void vector_destroy(Vector* v);
// 向动态数组末尾添加一个元素
void vector_push_back(Vector* v, ElementType element);
// 在动态数组最前面添加元素，所有元素依次后移
void vector_push_front(Vector* v, ElementType val);
// 将元素 val 添加到索引为 idx 的位置，idx 后面的元素依次后移
void vector_insert(Vector* v, int idx, ElementType val);
// 遍历打印整个 Vector 动态数组
void vector_print(Vector* v);
  </code> </pre>
</details>
<p>头文件主要用于存放以下结构：</p>
<ol type="1">
<li>函数的声明</li>
<li>结构体的定义</li>
<li>类型别名的定义</li>
<li>宏定义</li>
<li>…</li>
</ol>
<p><strong>头文件允许程序员在多个源文件之间共享函数的声明以及结构体、类型别名和宏的定义，从这个角度讲头文件类似
C++、Java 等编程语言中的接口。</strong></p>
<p>普遍采取的做法是：<strong>在头文件中声明函数，然后在某个源文件中包含头文件实现这些函数，最后在其余源文件中包含头文件，使用这些函数。</strong></p>
<p>使用头文件，促进了 <strong>模块化编程</strong>，提高了
<strong>代码的复用性</strong>，使得代码更加易于维护。</p>
<p><strong>注意：头文件作为接口的目的是对外暴露公共部分，某些不属于公共部分不需要对外暴露的不要放在头文件当中！！！</strong></p>
<p>包含头文件与实现函数</p>
<details>
<summary>
<font size="4" color="orange"> vector.c </font>
</summary>
<pre> <code class="language-c">#include "vector.h"
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#define DEFAULT_CAPACITY 10 // 设置动态数组的默认最小容量
#define THRESHOLD 1024
static void vector_resize(Vector* v) &#123;
    // 只要调用这个函数肯定就是需要扩容的
    int old_capacity = v-> capacity;
    int new_capacity = (old_capacity < THRESHOLD) ?
        (old_capacity << 1) :   // 容量还未超出阈值每次扩容 2 倍
        (old_capacity + (old_capacity >> 1));   // 容量超出阈值每次扩容 1.5 倍
    // 利用 realloc 重新分配动态数组
    ElementType * tmp = realloc(v-> data, new_capacity * sizeof(ElementType));    // realloc 惯用法
    if (tmp == NULL) &#123;
        printf("realloc failed in resize_vector.\n");
        exit(1);    // 扩容失败，退出整个程序。或者也可以做别的处理
    &#125;
    // 扩容成功，重新赋值 Vector 成员
    v-> data = tmp;
    v-> capacity = new_capacity;
&#125;
Vector* vector_create() &#123;
    Vector * v = (Vector*)calloc(1, sizeof(Vector));
    if (! v)
    &#123;
        printf("Error: calloc failed in vector_create!\n");
        return NULL;
    &#125;
    v-> data = (ElementType*)calloc(DEFAULT_CAPACITY, sizeof(ElementType));
    if (! v-> data) &#123;
        printf("Error: calloc failed in vector_create!\n");
        free(v);
        return NULL;
    &#125;
    // 继续初始化 Vector 的其它成员
    v-> capacity = DEFAULT_CAPACITY;
    // size 已自动初始化为 0 值，所以不需要再次赋值了。但如果用 malloc 就不要忘记初始化它
    return v;
&#125;
void vector_destroy(Vector* v) &#123;
    free(v-> data);
    free(v);
&#125;
void vector_push_back(Vector* v, ElementType element) &#123;
    if (v-> size == v-> capacity)
    &#123;
        vector_resize(v);
    &#125;
    v-> data [v-> size] = element;
    v-> size++;
&#125;
void vector_push_front(Vector* v, ElementType val) &#123;
    if (v-> size == v-> capacity)
    &#123;
        vector_resize(v);
    &#125;
    // 扩容完成后或不需要扩容，即从首元素开始将所有元素向后移动
        // 倒着遍历数组方便向后移动元素
    for (int i = v-> size - 1; i >= 0; i--) &#123;
        v-> data [i + 1] = v-> data [i];
    &#125;
    // 新增的元素成为首元素
    v-> data [0] = val;
    v-> size++;
&#125;
void vector_insert(Vector* v, int idx, ElementType val) &#123;
    // 先做参数校验，避免传入非法索引
    if (idx < 0 || idx > v-> size) &#123;     // 做插入操作时索引合法范围是 [0, size]
        printf("Illegal argument: idx = %d, size = %d\n", idx, v-> size);
        exit(1);    // 直接退出进程，也可以用别的方式进行错误处理
    &#125;
    if (v-> size == v-> capacity)
    &#123;
        vector_resize(v);
    &#125;
    for (int i = v-> size - 1; i >= idx; i--) &#123;
        v-> data [i + 1] = v-> data [i];
    &#125;
    v-> data [idx] = val;
    v-> size++;
&#125;
void vector_print(Vector* v) &#123;
    printf("[");
    for (int i = 0; i < v-> size; i++) &#123;
        printf("%d, ", v-> data [i]);
    &#125;
    printf("\b\b]\n");
&#125;</code> </pre>
</details>
<p>完成一系列关于 Vector 的开发实现后，接下来的关键步骤就是测试。</p>
<p><strong>在实际的开发中，当我们完成了某个独立模块、组件的开发后，都需要编写一系列测试用例，进行彻底的单元测试工作，来及时的发现和修复程序中的缺陷和
bug，从而提高整体代码质量。</strong></p>
<p>编写测试用例，完成单元测试开发，也是一个普通程序员的本职工作之一。</p>
<p>在这里，可以创建一个 “test.c”
的源文件，用于运行一系列的测试用例：</p>
<ol type="1">
<li>创建和销毁。验证 Vector 是否可以成功创建和销毁，没有内存泄漏。</li>
<li>添加元素：测试向 Vector
添加元素的功能，确保数组可以正确地扩容。</li>
<li>边界条件检查：检查 Vector
在极端情况下（如恰好超出容量）的行为是否正确。</li>
<li>….</li>
</ol>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include  &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include "vector.h"
#define N 100
int main(void) &#123;
    Vector *v = vector_create();
    if (v == NULL) &#123;
        printf("error: vector_create failed in main.\n");
        exit(1);
    &#125;
    // 测试自动扩容机制
    for (int i = 0; i < N; ++i) &#123;
        vector_push_back(v, i + 1);
    &#125;
    vector_print(v);    // 期望打印结果: 1-100
    // 测试头部插入新元素
    vector_push_front(v, 0);
    vector_print(v);    // 期望打印结果: 0, 1-100
    // 测试根据索引插入新元素
    vector_insert(v, 0, -1);
    vector_print(v);    // 期望打印结果: -1, 0, 1-100
    vector_destroy(v);
    return 0;
&#125;</code>
</pre>
</details>
<h2 id="链表">链表</h2>
<p>链表：是一种线性数据结构，由一系列结点 <strong>“链接”</strong>
构成。</p>
<p>结点：在 C
语言中，一个结点通常是一个结构体对象。该结构体对象由数据域和指针域两部分组成。数据域用于存储数据，而指针域则用于存放其它结点的指针。</p>
<p>如下图所示(其中 D 代表 <strong>数据域</strong>，P 代表
<strong>指针域</strong>)：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311152035255.png" alt="结点和链表-示意图" style="zoom: 33%;" />
</div>
<p>常见的链表主要可以分为以下几种类型：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311152050220.png" alt="常见链表分类-示意图" style="zoom: 33%;" />
</div>
<h3 id="单向链表">单向链表</h3>
<p>单向链表是由一系列结点单向链接组成的数据结构，简称单链表。</p>
<p>基础概念：</p>
<ol type="1">
<li><p><strong>结点：</strong>
链表中的每一个存储单元被称为结点，每个结点都包含两部分：</p>
<ol type="1">
<li>一部分用于存储结点的数据(数据域)</li>
<li>另一部分用于存储指向下一个结点的指针(指针域)。</li>
</ol>
<p>在 C 程序中一个结点，就是一个结点结构体类型的对象。</p></li>
<li><p><strong>头结点：</strong>
某些单链表的实现中，会在第一个结点前附设一个
<strong>“一般不存储数据或者存储链表长度信息”</strong>
的结点，这个结点就是头结点。</p>
<ol type="1">
<li>头结点也叫做 “哑结点”、“虚拟结点”、“哨兵结点”
等。头结点的指针域指向链表的第一个结点。</li>
<li>在实际应用中，单链表一般不带头结点，但在需要统一链表头部操作的场景中，头结点具有
“奇效”。</li>
</ol></li>
<li><p><strong>尾结点：</strong> 单链表的最后一个结点。它的指针域指向
NULL，表示链表的结束。</p></li>
<li><p><strong>头指针：</strong>
指向链表第一个结点的指针，<strong>头指针非常重要，单链表的任何操作都是以头指针为入口的，单链表一定会有头指针。</strong>
具体而言：</p>
<ol type="1">
<li>如果链表为空，则头指针为 NULL，是一个空指针。</li>
<li>如果单链表没有头结点，那么头指针就指向链表的第一个存储数据的结点。</li>
<li>如果单链表有头结点，那么头指针就指向该头结点。总之，头指针就指向单链表的第一个结点。</li>
</ol></li>
<li><p><strong>尾指针：</strong>
指向链表最后一个结点的指针。对于单链表而言，尾指针不是必须的，但拥有尾指针可以使得链表尾部的操作更加简单高效。</p></li>
</ol>
<p>基本操作：</p>
<ol type="1">
<li><p>创建链表</p></li>
<li><p>销毁链表</p></li>
<li><p>插入结点：对于链表而言，只要在一个确定的结点后面插入结点，都是一个基础的，时间复杂度为
O(1)的操作。</p>
<ol type="1">
<li>在一个存在头指针和尾指针的链表当中，头插和尾插就是基础的插入结点操作。</li>
<li>更复杂的插入操作都是对基础插入操作的扩展，比如根据索引插入一个结点。</li>
</ol></li>
<li><p>搜索结点：链表并不支持随机访问，任何的访问操作都意味着遍历链表。</p>
<ol type="1">
<li>所以不管是有序无序还是搜索的条件是什么，单链表的搜索操作时间复杂度总是
O(n)</li>
<li>比较常见的搜索条件是：根据索引查找或者根据数据查找</li>
</ol></li>
<li><p>删除结点：对于链表而言，只要是删除一个确定结点后面的一个结点，都是一个基础的，时间复杂度为
O(1)的操作。</p>
<ul>
<li><p>在一个存在头指针和尾指针的链表当中，删除第一个结点就是一个基础的
O(1)时间复杂度操作。</p></li>
<li><p>如果需要删除尾结点或中间结点，则通常需要遍历链表，时间复杂度是
O(n)</p></li>
</ul></li>
</ol>
<h4 id="设计思路-1">设计思路</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311161556943.png" alt="单向链表结构-示意图" style="zoom: 33%;" />
</div>
<h4 id="代码实现-1">代码实现</h4>
<details>
<summary>
<font size="4" color="orange"> linked_list.h </font>
</summary>
<pre> <code class="language-c">// 头文件保护语法
#ifndef LINKED_LIST_H
#define LINKED_LIST_H
// 包含 linked_list.h 头文件也会同步包含它包含的其它头文件
// 根据这一特点, 可以选择将一些共用的头文件包含在此头文件中
#include &lt; stdbool.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
#define ERROR_CHECK(ret, error_flag, msg) \
 do &#123; \
     if ((ret) == (error_flag)) &#123; \
         printf("error: %s\n", msg); \
         exit(1); \
     &#125; \
 &#125; while(0)
typedef int DataType;
// 定义链表结点结构
typedef struct node &#123;
    DataType data;      // 数据域
    struct node* next;  // 指针域
&#125; Node;
// 定义链表结构本身
typedef struct &#123;
    Node* head;     // 头指针
    Node* tail;     // 尾结点指针
    int size;       // 用于记录链表的长度
&#125; LinkedList;
// 创建一个空的链表
LinkedList* create_linked_list();
// 销毁链表
void destroy_linked_list(LinkedList* list);
// 头插法
bool add_before_head(LinkedList* list, DataType new_data);
// 尾插法
bool add_behind_tail(LinkedList* list, DataType new_data);
// 根据索引插入一个新结点
bool add_by_idx(LinkedList* list, int idx, DataType new_data);
// 根据索引搜索一个结点
Node * search_by_idx(LinkedList* list, int idx);
// 根据数据搜索一个结点
Node * search_by_data(LinkedList* list, DataType data);
// 根据数据删除一个结点
bool delete_by_data(LinkedList* list, DataType data);
// 扩展: 根据索引删除一个结点
bool delete_by_idx(LinkedList* list, int idx);
// 打印单链表 格式为：1 -> 2 -> 3 ->...
void print_list(LinkedList* list);
#endif // ! LINKED_LIST_H
</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> linked_list.c </font>
</summary>
<pre> <code class="language-c">#include "linked_list.h"
LinkedList* create_linked_list()
&#123;
    LinkedList* list = calloc(1, sizeof(LinkedList));
    ERROR_CHECK(list, NULL, "Error: malloc failed in creat_linked_list.\n");
    return list;
&#125;
void destroy_linked_list(LinkedList* list)
&#123;
    Node* curr = list-> head;
    while (curr) &#123;
        Node* temp = curr-> next;
        free(curr);
        curr = temp;
    &#125;
    free(list);
&#125;
// 头插法
bool add_before_head(LinkedList *list, DataType new_data) &#123;
    // 1.分配一个新结点
    Node *new_node = (Node *)malloc(sizeof(Node));
    if (new_node == NULL) &#123;
        printf("malloc failed in add_before_head.\n");
        return false;
    &#125;
    // 2.初始化这个新结点
    new_node-> data = new_data;
    new_node-> next = list-> head;    // 新结点指向原本的第一个结点
    // 3.更新头指针指向新结点
    list-> head = new_node;  // 新结点成为第一个结点
    // 4.如果尾结点指针是 NULL，说明链表头插前为空，那么新结点同时成为尾结点
    // 需要更新尾结点指针
    if (list-> tail == NULL) &#123;
        list-> tail = new_node;
    &#125;
    list-> size++;
    return true;
&#125;
// 尾插法
bool add_behind_tail(LinkedList *list, DataType new_data) &#123;
    // 1.分配一个新结点
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL) &#123;
        printf("malloc failed in add_behind_tail.\n");
        return false;
    &#125;
    // 2.初始化新结点的指针域和数据域，指针域初始为 NULL
    new_node-> data = new_data;
    new_node-> next = NULL;
    // 3.如果尾结点指针是 NULL，说明链表尾插前为空，那么新结点同时成为第一个结点和尾结点
    if (list-> tail == NULL) &#123;
        // 链表为空
        list-> head = new_node;
        list-> tail = new_node;
        list-> size++;
        return true;
    &#125;
    // 4.如果尾指针不是 NULL，让以前的尾结点指向新结点，然后更新尾指针
    list-> tail-> next = new_node;
    list-> tail = new_node;
    list-> size++;
    return true;
&#125;
bool add_by_idx(LinkedList* list, int idx, DataType new_data)
&#123;
    // 参数校验
    if (idx <0 || idx> list-> size) &#123;
        printf("Index is not valid.\n");
        return false;
    &#125;
    Node* new_node = calloc(1, sizeof(Node));
    if (! new_node)
    &#123;
        printf("Error: calloc failed in add_behind_tail.\n");
        return false;
    &#125;
    if (idx == 0)
    &#123;
        return add_before_head(list, new_data);
    &#125;
    else if (idx == list-> size) &#123;
        return add_behind_tail(list, new_data);
    &#125;
    else
    &#123;
        Node* prev = NULL;
        Node* curr = list-> head;
        for (size_t i = 0; i < idx; i++)
        &#123;
            prev = curr;
            curr = curr-> next;
        &#125;
        new_node-> data = new_data;
        new_node-> next = curr;
        prev-> next = new_node;
        list-> size++;
        return true;
    &#125;
&#125;
Node * search_by_idx(LinkedList* list, int idx)
&#123;
    // 参数校验
    if (idx < 0 || idx > = list-> size) &#123;
        printf("Index is not valid.\n");
        return NULL;
    &#125;
    Node* curr = list-> head;
    if (! curr)
    &#123;
        printf("The list is empty.\n");
        return NULL;
    &#125;
    for (size_t i = 0; i < idx; i++)
    &#123;
        curr = curr-> next;
    &#125;
    return curr;
&#125;
Node * search_by_data(LinkedList* list, DataType data)
&#123;
    Node* curr = list-> head;
    if (! curr)
    &#123;
        printf("The list is empty.\n");
        return NULL;
    &#125;
    while (curr) &#123;
        if (curr-> data == data)
        &#123;
            return curr;
        &#125;
        curr = curr-> next;
    &#125;
    return NULL;
&#125;
bool delete_by_data(LinkedList* list, DataType data)
&#123;
    Node* prev = NULL;
    Node* curr = list-> head;
    ERROR_CHECK(curr, NULL, "The list is empty.\n");
    while (curr) &#123;
        if (curr-> data == data)
        &#123;
            if (curr == list-> head)
            &#123;
                if (curr-> next) &#123; // 删除的第一个节点有后继节点
                    list-> head = curr-> next;
                    free(curr);
                &#125;
                else &#123; // 删除的第一个节点无后继节点
                    list-> head = NULL;
                    list-> tail = NULL;
                    free(curr);
                &#125;
            &#125;
            else
            &#123;
                prev-> next = curr-> next;
                if (curr == list-> tail) &#123;
                    list-> tail = prev;
                &#125;
                free(curr);
            &#125;
            list-> size--;
            return true;
        &#125;
        prev = curr;
        curr = curr-> next;
    &#125;
    return false;
&#125;
bool delete_by_idx(LinkedList* list, int idx)
&#123;
    // 参数校验
    if (idx < 0 || idx > = list-> size) &#123;
        printf("Index is not valid.\n");
        return false;
    &#125;
    Node* prev = NULL;
    Node* curr = list-> head;
    ERROR_CHECK(curr, NULL, "The list is empty.\n");
    if (idx == 0)
    &#123;
        if (curr-> next) &#123; // 删除的第一个节点有后继节点
            list-> head = curr-> next;
        &#125;
        else &#123; // 删除的第一个节点无后继节点
            list-> head = NULL;
            list-> tail = NULL;
        &#125;
    &#125;
    else &#123;
        for (size_t i = 0; i < idx; i++)
        &#123;
            prev = curr;
            curr = curr-> next;
        &#125;
        prev-> next = curr-> next;
        if (curr-> next == NULL) &#123;
            list-> tail = prev;
        &#125;       
    &#125;
    free(curr);
    list-> size--;
    return true;
&#125;
// 打印单链表 格式为：1 -> 2 -> 3 ->...
void print_list(LinkedList *list) &#123;
    Node *curr = list-> head;
    // 遍历此单链表
    while (curr != NULL) &#123;
        printf("%d", curr-> data);
        // 如果不是链表的最后一个结点，就打印箭头
        if (curr-> next != NULL) &#123;
            printf(" -> ");
        &#125;
        curr = curr-> next;
    &#125;
    printf("\n");
&#125;
</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include "linked_list.h"
#define ARR_SIZE(arr) (sizeof(arr)/sizeof(arr [0]))
/*
*/
int main(void) &#123;
    LinkedList* list = create_linked_list();
    add_before_head(list, 4);
    add_before_head(list, 3);
    add_before_head(list, 2);
    add_before_head(list, 1);
    add_behind_tail(list, 5);
    // add_by_idx(list, 0, 0);
    // add_by_idx(list, 3, 111);
    print_list(list);
    //Node* node =  search_by_idx(list, 5);
    //Node* node = search_by_data(list, 7);
    // delete_by_data(list, 4);
    delete_by_idx(list, 4);
    print_list(list);
    destroy_linked_list(list);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h2 id="栈">栈</h2>
<h3 id="概述">概述</h3>
<p>相比较于数组和链表，栈是一种操作受限的线性结构。</p>
<p>这种操作受限体现在：</p>
<ol type="1">
<li>栈只能在 <strong>同一端</strong> 添加、删除以及访问元素（栈顶）</li>
<li>另一端无法执行任何操作（栈底），栈底的元素既不能直接增删，也不能直接访问。</li>
</ol>
<p><strong>可以把栈想象成一个杯子，杯底相当于栈底，无法直接进行任何操作。杯口相当于栈顶，是唯一可以进行添加、删除和访问操作的地方。</strong></p>
<p>在栈中，最先添加到栈中的元素总是最后被删除的，遵循
<strong>后进先出（LIFO, Last In First Out）</strong> 的原则。</p>
<p>如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311210848469.png" alt="栈-示意图" style="zoom: 33%;" />
</div>
<p>栈这种数据结构的基本操作主要包括以下几种：</p>
<ol type="1">
<li>入栈/压栈(push)：在栈顶添加一个元素，成为新的栈顶元素，其余元素则被压入栈底。时间复杂度
O(1)</li>
<li>出栈/弹栈(pop)：删除栈顶元素，下一个元素成为新的栈顶元素。时间复杂度
O(1)</li>
<li>访问栈顶元素(peek)：返回栈顶元素的值。时间复杂度 O(1)</li>
<li>判空(is_empty)：检查栈中是否有任何元素。时间复杂度
O(1)，因为只需要检查一下栈顶元素即可。</li>
</ol>
<p><strong>说白了，栈仍然还是一个线性数据结构(数组或链表都可以)，只不过在实现时，只需要提供栈顶的增删访问操作罢了。</strong></p>
<h3 id="栈的优点">栈的优点</h3>
<p>栈是一种操作受限的线性结构，既然如此，那么为什么非要使用栈呢？直接使用链表或数组不好吗？</p>
<p>使用栈主要有以下好处：</p>
<ol type="1">
<li>高效率。由于栈的操作仅限于顶部，栈的所有基本操作（push、pop、peek）通常都具有
O(1) 的时间复杂度，这使得栈在性能上非常高效。</li>
<li>简化代码、增强代码可读性。由于操作受限，编程时的考虑因素更少，更容易实现。也有助于写出更清晰、更易于维护的代码。</li>
<li>非常适合用于解决特定问题。在实际的某些应用场景中，如函数调用管理、括号匹配问题、表达式求值、浏览器的前进后退功能等，自然而然地符合
“先进后出” 的特点，天然就适合使用栈来解决。</li>
</ol>
<p><strong>在数据结构的选择上，关键在于根据具体的应用需求和场景来决定最合适的结构。</strong></p>
<h3 id="栈的实现方式">栈的实现方式</h3>
<p>栈的实现有两种方式：</p>
<ol type="1">
<li>基于链表实现</li>
<li>基于数组实现</li>
</ol>
<p>这两种实现方式各有优缺点，总得来说：</p>
<ol type="1">
<li>如果以一个固定长度的数组来实现栈，实现方式非常简洁，依赖于数组随机访问效率特别高。也不需要额外的空间来存储指针。但缺点是栈大小固定，无法扩容。</li>
<li>如果用一个动态数组来实现栈，栈具有更灵活的容量，同样随机访问效率高且不需要额外空间存储指针。但缺点是，重分配内存可能是一个较大的性能开销，拖慢整体栈的效率。</li>
<li>如果以链表来实现，灵活性比数组更强，且扩容不涉及内存重分配，栈整体性能稳定。但缺点是空间占用更多，需要存储额外的指针。当然，链表实现肯定会更复杂一些，这也算个小毛病。</li>
</ol>
<p>总的来说：</p>
<ol type="1">
<li>在已知栈大小限制或不需要频繁调整栈大小时，优先考虑使用固定长度的数组来实现栈，这会提供更好的性能以及更简单的实现以及使用方式。</li>
<li>在栈大小未知或需要频繁调整栈大小时，可以考虑使用动态数组或链表来实现栈，它们的区别是：
<ol type="1">
<li>动态数组实现的缺点是如果需要频繁调整大小，那么性能会非常差。所以如果不需要频繁的进行扩容操作，且对性能需求高，则优先选择动态数组实现。而且现代很多高级编程语言（比如
C++、Java 等）都已提供了现成的动态数组实现。</li>
<li>如果栈的大小完全不可预测，使用动态数组实现会导致频繁调整大小的操作，那么可以更多的考虑使用链表实现。</li>
</ol></li>
</ol>
<h3 id="设计思路-2">设计思路</h3>
<h4 id="链式栈模型">链式栈模型</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240920115219055.png" alt="链式栈模型" style="zoom: 67%;" />
</div>
<h4 id="动态数组栈模型">动态数组栈模型</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240921112648213.png" alt="动态数组栈模型" style="zoom: 67%;" />
</div>
<h3 id="代码实现-2">代码实现</h3>
<h4 id="链式栈模型-1">链式栈模型</h4>
<details>
<summary>
<font size="4" color="orange"> linked_stack.h </font>
</summary>
<pre> <code class="language-c">#ifndef LINKED_STACK_H
#define LINKED_STACK_H
#include &lt; stdbool.h&gt;
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
typedef int ElementType;
// 栈的一个结点栈帧, 类型定义
typedef struct node_s &#123;
    ElementType data;
    struct node_s* next;
&#125;StackFrame;
typedef struct &#123;
    StackFrame* top;    // 栈顶指针
&#125;LinkedStack;
// 基本操作
// 创建链式栈
LinkedStack* stack_create();
// 销毁链式栈
void stack_destroy(LinkedStack* stack);
// 判空
bool is_empty(LinkedStack* stack);
// 入栈
void stack_push(LinkedStack* stack, ElementType data);
// 出栈并返回栈顶元素
ElementType stack_pop(LinkedStack* stack);
// 访问栈顶元素
ElementType stack_peek(LinkedStack* stack);
#endif // ! LINKED_STACK_H
</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> linked_stack.c </font>
</summary>
<pre> <code class="language-c">#include "linked_stack.h"
// 新建一个空栈
LinkedStack *stack_create() &#123;
    // callock 可以不用手动初始化空指针
    return calloc(1, sizeof(LinkedStack));
&#125;
// 对于链式栈而言，销毁栈就是销毁链表
void stack_destroy(LinkedStack *stack) &#123;
    // 相当于遍历链表(出栈)然后在遍历中逐个 free 结点
    StackFrame *curr = stack-> top;
    while (curr != NULL) &#123;
        StackFrame *tmp = curr-> next;   // 保存后继结点
        free(curr);
        curr = tmp;
    &#125;
    // 最后 free 栈结构体
    free(stack);
&#125;
bool is_empty(LinkedStack *stack) &#123;
    return stack-> top == NULL;
&#125;
// 相当于链表头插法插入结点，栈顶指针相当于链表的头指针
void stack_push(LinkedStack *stack, ElementType data) &#123;
    // 1.新建一个栈帧结点
    StackFrame *new_frame = malloc(sizeof(StackFrame));
    if (new_frame == NULL) &#123;
        printf("malloc failed in stack_push.\n");
        exit(1);
    &#125;
    // 2.初始化新栈帧
    new_frame-> data = data;
    new_frame-> next = stack-> top;
    // 3.更新栈顶指针
    stack-> top = new_frame;
&#125;
// 相当于链表在头部删除第一个结点, 栈顶指针相当于链表的头指针
ElementType stack_pop(LinkedStack *stack) &#123;
    // 1.栈判空处理
    if (is_empty(stack)) &#123;
        printf("error: stack is empty.\n");
        exit(1);
    &#125;
    // 2.出栈返回栈顶元素, 并 free 结点, 更新栈顶指针
    StackFrame *curr = stack-> top;
    ElementType data = curr-> data;
    stack-> top = curr-> next;
    free(curr);
    return data;
&#125;
ElementType stack_peek(LinkedStack *stack) &#123;
    if (is_empty(stack)) &#123;
        printf("error: stack is empty.\n");
        exit(1);
    &#125;
    return stack-> top-> data;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; string.h&gt;
#include "linked_stack.h"
int main(void) &#123;
    // 创建一个空栈
    LinkedStack *stack = stack_create();
    if (stack == NULL) &#123;
        printf("Failed to create stack.\n");
        return -1;
    &#125;
    // 入栈操作
    stack_push(stack, 1);
    stack_push(stack, 2);
    stack_push(stack, 3);
    // 查看栈顶元素
    printf("当前栈顶元素是: %d\n", stack_peek(stack)); // 应该输出 3
    // 出栈操作，并打印出栈的元素
    printf("依次出栈以下元素:\n");
    while (! is_empty(stack)) &#123;
        printf("%d\n", stack_pop(stack)); // 应该依次输出 3, 2, 1
    &#125;
    // 再次尝试查看栈顶元素，预期会触发错误提示
    printf("栈为空时, 尝试访问栈顶元素:\n");
    stack_peek(stack);  // 应该输出错误信息并退出
    // 销毁栈
    stack_destroy(stack);   return 0;
&#125;</code>
</pre>
</details>
<h4 id="动态数组栈模型-1">动态数组栈模型</h4>
<details>
<summary>
<font size="4" color="orange"> dynamic_stack.h </font>
</summary>
<pre> <code class="language-c">#ifndef DYNAMIC_STACK_H
#define DYNAMIC_STACK_H
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdbool.h&gt;
typedef int ElementType;
typedef struct &#123;
    ElementType* elements;   // 指向动态数组首元素的指针
    int size;   // 元素的个数
    int capacity; // 数组的容量，也就是栈的容量
&#125; DynamicStack;
// 创建动态数组栈
DynamicStack* stack_create();
// 销毁动态数组栈
void stack_destroy(DynamicStack* s);
// 入栈
void stack_push(DynamicStack* s, ElementType val);
// 出栈并返回栈顶元素
ElementType stack_pop(DynamicStack* s);
// 访问栈顶元素
ElementType  stack_peek(DynamicStack* s);
// 判空
bool is_empty(DynamicStack* s);
#endif // ! DYNAMIC_ARR_STACK_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> dynamic_stack.c </font>
</summary>
<pre> <code class="language-c">#include "dynamic_stack.h"
#define DEFAULT_CAPACITY 8  // 动态栈的默认容量
#define THRESHOLD 1024  // 扩容阈值
// 实现扩容机制
static void grow_capacity(DynamicStack* s) &#123;
    // 扩容策略: 超过阈值则 1.5 倍的扩容，否则 2 倍的扩容
    int new_capacity = (s-> capacity > THRESHOLD) ?
        (s-> capacity + (s-> capacity >> 1)) :
        (s-> capacity << 1);
    // 使用 realloc 函数实现扩容，重新分配内存
    ElementType * new_arr = realloc(s-> elements, new_capacity * sizeof(ElementType));
    if (new_arr == NULL) &#123;
        printf("Error: realloc failed in grow_capacity\n");
        exit(1);
    &#125;
    // 更新动态数组栈结构体的信息
    s-> elements = new_arr;
    s-> capacity = new_capacity;
&#125;
// 创建动态数组栈
DynamicStack* stack_create() &#123;
    DynamicStack* stack = calloc(1, sizeof(DynamicStack));
    if (stack == NULL)
    &#123;
        printf("Error: malloc failed in stack_create.\n");
        return NULL;
    &#125;
    stack-> size = 0;
    stack-> capacity = DEFAULT_CAPACITY;
    stack-> elements = malloc(DEFAULT_CAPACITY * sizeof(ElementType));
    if (stack-> elements == NULL)
    &#123;
        free(stack);
        printf("Error: malloc failed in stack_create.\n");
        return NULL;
    &#125;
    return stack;
&#125;
// 销毁动态数组栈
void stack_destroy(DynamicStack* s) &#123;
    // 先释放动态数组
    free(s-> elements);
    // 再释放栈结构体
    free(s);
&#125;
// 入栈
void stack_push(DynamicStack* s, ElementType val) &#123;
    if (s-> size >= s-> capacity)
    &#123;
        grow_capacity(s);
    &#125;
    s-> elements [s-> size] = val;
    s-> size++;
&#125;
// 出栈并返回栈顶元素
ElementType stack_pop(DynamicStack* s) &#123;
    if (is_empty(s)) &#123;
        printf("Error: stack is empty\n");
        exit(1);
    &#125;
    s-> size--;
    return s-> elements [s-> size];
&#125;
// 访问栈顶元素
ElementType  stack_peek(DynamicStack* s) &#123;
    if (is_empty(s)) &#123;
        printf("Error: stack is empty\n");
        exit(1);
    &#125;
    return s-> elements [s-> size - 1];
&#125;
// 判空
bool is_empty(DynamicStack* s) &#123;
    return s-> size == 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include "dynamic_stack.h"
int main(void) &#123;
    DynamicStack* s = stack_create();
    // 入队列 1000 个元素
    for (int i = 0; i < 1000; i++) &#123;
        stack_push(s, i);
    &#125;
    // 出队列直到队列为空
    while (! is_empty(s)) &#123;
        ElementType ele = stack_peek(s);
        printf("%d ", ele); // 预期会将 999-0 倒着输出打印
        stack_pop(s);
    &#125;
    printf("\n");
    // 再次尝试出栈, 此时会打印错误提示信息
    stack_pop(s);
    // 销毁队列
    stack_destroy(s);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="栈的应用场景">栈的应用场景</h3>
<p>栈特别适用那些存在 “后进先出”
逻辑的场景，在实际的开发，栈很常用。栈至少可以应用于以下领域：</p>
<ol type="1">
<li>函数调用机制</li>
<li>括号匹配问题</li>
<li>表达式求值问题</li>
<li>浏览器历史记录前进后退功能</li>
<li>深度优先遍历算法（一般直接用函数调用者递归实现）</li>
<li>…</li>
</ol>
<h2 id="队列">队列</h2>
<h3 id="概述-1">概述</h3>
<p>队列是另一种操作受限的线性结构。但它的受限和栈是不同的：</p>
<ol type="1">
<li>队列只能在一端添加元素（队尾）</li>
<li>在另一端访问、删除元素（队头）</li>
</ol>
<p>队列就不用想象了，它就是我们生活中排队的场景，你只能在队尾插入一个元素，在队头删除一个元素。</p>
<p>在队列中，最先添加到队尾的元素总是最先在队头删除，遵循
<strong>先进先出（FIFO，First In First Out）</strong> 的原则。</p>
<p>如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311211052492.png" alt="队列-概念模型" style="zoom: 80%;" />
</div>
<p>队列这种数据结构的基本操作主要包括以下几种：</p>
<ol type="1">
<li>入队：在队尾添加一个元素，新元素成为新的队尾元素。</li>
<li>出队：在队头删除一个元素，第二个元素称为新的队头元素。</li>
<li>访问队头元素</li>
<li>判空</li>
<li>判满</li>
</ol>
<h3 id="设计思路-3">设计思路</h3>
<h4 id="数组队列模型">数组队列模型</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311231053386.png" alt="数组队列-方案三" style="zoom: 33%;" />
</div>
<p>这种方案，最核心的问题就是：如何移动两个索引，使得它们能够在数组内部循环移动呢？</p>
<p>使用取余运算符 “%” 即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rear = (rear + <span class="number">1</span>) % N</span><br><span class="line">front = (front + <span class="number">1</span>) % N</span><br></pre></td></tr></table></figure>
<p>解释： 对于数组的下标运算，几乎都是要涉及对数组长度 N
的取余运算，现在希望往后移动索引，而且希望从最后一个索引向后移动是第一个索引，所以就这样计算。</p>
<p>这样设计就实现了对数组前面空间的利用，避免了空间浪费，同时出入队的效率也很高。下面思考一个问题：</p>
<p>这种设计方案，如何进行队列判空和判满呢？</p>
<p>实际上如果就单纯按照上述方案设计循环队列，那么它们的判空和判满条件是一样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rear == front</span><br></pre></td></tr></table></figure>
<p>所以对于这两个操作我们还需要进行一点小优化，有两个选择：</p>
<p>（1）牺牲一个存储单元不存储元素，<strong>只要 rear 指向 front
的前一个位置就表示队列满了。</strong> 如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311231058261.png" alt="" style="zoom: 50%;" />
</div>
<p>在这种情况下：</p>
<ul>
<li><strong>队列满了的条件是：(rear + 1) % N == front</strong></li>
<li>队列为空的条件是：rear == front</li>
</ul>
<p>这种办法是教科书中讲数据结构经常使用的方案，在实际开发中可以用一个更简单粗暴，更易于实现和使用的方式——<strong>计数器</strong>。</p>
<p>（2）使用一个额外的计数器变量来统计数组中元素的个数，这样判空和判满都十分简洁了。具体而言可以参考下图的实现：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240415202036317.png" alt="数组队列-方案三改进图2" style="zoom: 50%;" />
</div>
<p>基于上述图中的模型，实现一个
<strong>固定长度的数组队列</strong>，需要注意的是：</p>
<ul>
<li><p><strong>front
用于记录队头元素，出队时就将该元素出队。</strong></p></li>
<li><p><strong>rear
用于指示下一个元素入队的索引，也就是说入队操作时直接将元素插入 rear
索引位置就可以了。</strong></p></li>
<li><p><strong>规定 front(包含)和
rear(不包含)索引之间的元素就是队列元素，出队操作时，直接向后移动索引
front 就可以了，不需要任何赋值操作。</strong></p></li>
<li><p><strong>front 向后移动的方式是：(front + 1) % N</strong></p></li>
<li><p><strong>rear 向后移动的方式是：(rear + 1) % N</strong></p></li>
</ul>
<h4 id="链表队列模型">链表队列模型</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240921154854107.png" alt="链表队列模型" style="zoom: 67%;" />
</div>
<h3 id="代码实现-3">代码实现</h3>
<h4 id="动态数组队列模型">动态数组队列模型</h4>
<details>
<summary>
<font size="4" color="orange"> dynamic_queue.h </font>
</summary>
<pre> <code class="language-c">#ifndef DYNAMIC_QUEUE_H
#define DYNAMIC_QUEUE_H
#include &lt; stdbool.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
typedef int ElementType;    // 该队列当前存储 int 元素
#define DEFAULT_CAPACITY 10 // 数组队列的初始长度是 10
#define THRESHOLD 1000  // 超过阈值每次扩容 1.5 倍扩，否则 2 倍的扩
// 定义队列结构体
typedef struct &#123;
    ElementType* data;   // 动态数组存储队列元素
    int front;           // 标记队头元素的索引
    int rear;            // 标记队尾元素下一个位置的索引
    int size;            // 当前队列中元素数量
    int capacity;        // 队列容量
&#125; DynamicQueue;
// 队列基本操作函数声明
// 创建动态数组队列
DynamicQueue* create_queue();
// 销毁动态数组队列
void destroy_queue(DynamicQueue* q);
// 判空
bool is_empty(DynamicQueue* q);
// 判满
bool is_full(DynamicQueue* q);
// 入队列
bool enqueue(DynamicQueue* q, ElementType data);
// 出队列并且返回队头元素
ElementType dequeue(DynamicQueue* q);
#endif // ! DYNAMIC_QUEUE_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> dynamic_queue.c </font>
</summary>
<pre> <code class="language-c">#include "dynamic_queue.h"
// 创建并初始化队列
DynamicQueue *create_queue() &#123;
    DynamicQueue *q = calloc(1, sizeof(DynamicQueue));
    if (q == NULL) &#123;
        printf("error: calloc failed in create_queue.\n");
        return NULL;
    &#125;
    // front、rear、size 自动初始化 0 值，无需再手动初始化了
    q-> data = calloc(DEFAULT_CAPACITY, sizeof(ElementType));    // 使用 calloc 避免随机值
    if (q-> data == NULL) &#123;
        printf("error: calloc failed in create_queue.\n");
        free(q);
        return NULL;
    &#125;
    q-> capacity = DEFAULT_CAPACITY;
    return q;
&#125;
// 销毁队列
void destroy_queue(DynamicQueue *q) &#123;
    free(q-> data);
    free(q);
&#125;
// 检查队列是否为空
bool is_empty(DynamicQueue *q) &#123;
    return q-> size == 0;
&#125;
// 检查队列是否已满
bool is_full(DynamicQueue *q) &#123;
    return q-> size == q-> capacity;
&#125;
/*
    这里采用一种简单粗暴的扩容手段:
    直接分配新容量的内存块
    然后遍历旧内存块中的队列元素, 将这些元素全部从头开始复制到新内存块中
    这样的操作在完成后, 需要更新 front 索引和 rear 索引
*/
static bool resize_queue(DynamicQueue *q) &#123;
    int old_capacity = q-> capacity;
    int new_capacity = (old_capacity < THRESHOLD) ?
        (old_capacity << 1) :
    (old_capacity + (old_capacity >> 1));
    // 重新分配一个新的, 更长的动态数组
    ElementType *new_data = malloc(new_capacity * sizeof(ElementType));
    if (new_data == NULL) &#123;
        printf("error: realloc failed in resize_queue.\n");
        return false;
    &#125;
    int curr = q-> front;    // curr 索引用于遍历整个队列中的元素
    int index = 0;
    while (index < q-> size) &#123;
        new_data [index] = q-> data [curr];
        curr = (curr + 1) % q-> capacity;
        index++;
    &#125; // while 循环结束时, new_data 就从头开始包含了队列的所有元素 
    free(q-> data);
    q-> data = new_data;
    q-> front = 0;
    q-> rear = q-> size;
    q-> capacity = new_capacity;
    return true;
&#125;
// 入队操作
bool enqueue(DynamicQueue *q, ElementType data) &#123;
    if (is_full(q)) &#123;
        if (! resize_queue(q)) &#123;
            printf("error: 扩容失败.\n");
            return false; // 队列扩容失败, 入队也同步失败
        &#125;
    &#125;
    q-> data [q-> rear] = data;
    q-> rear = (q-> rear + 1) % q-> capacity;  // 循环队列
    q-> size++;
    return true;
&#125;
// 出队操作
ElementType dequeue(DynamicQueue *q) &#123;
    if (is_empty(q)) &#123;
        printf("error: 队列为空，无法出队。\n");
        exit(1);
    &#125;
    ElementType item = q-> data [q-> front];
    q-> front = (q-> front + 1) % q-> capacity; // 循环队列
    q-> size--;
    return item;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include "dynamic_queue.h"
int main(void) &#123;
    // 创建队列
    DynamicQueue* queue = create_queue();
    if (queue == NULL) &#123;
        printf("创建队列失败。\n");
        return 1;
    &#125;
    // 入队测试
    for (int i = 0; i < 15; i++) &#123;
        if (enqueue(queue, i)) &#123;
            printf("已入队: %d\n", i);
        &#125;
        else &#123;
            printf("入队失败: %d\n", i);
        &#125;
    &#125;
    // 打印队列容量和大小
    printf("队列容量: %d, 队列大小: %d\n", queue-> capacity, queue-> size);
    // 出队测试
    printf("正在出队...\n");
    while (! is_empty(queue)) &#123;
        printf("已出队: %d\n", dequeue(queue));
    &#125;
    // 销毁队列
    destroy_queue(queue);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h4 id="链表队列模型-1">链表队列模型</h4>
<details>
<summary>
<font size="4" color="orange"> list_queue.h </font>
</summary>
<pre> <code class="language-c">#ifndef LIST_QUEUE_H
#define LIST_QUEUE_H
#include &lt; stdbool.h&gt;
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
// 定义队列中的元素类型
typedef int ElementType;
// 队列节点的结构
typedef struct node_s &#123;
    ElementType data;
    struct node_s* next;
&#125; QueueNode;
// 队列的结构
typedef struct &#123;
    QueueNode* front;  // 队头结点指针
    QueueNode* rear;   // 队尾结点指针
&#125; LinkedListQueue;
// 函数声明
// 创建链式队列
LinkedListQueue* create_queue();
// 销毁链式队列
void destroy_queue(LinkedListQueue* q);
// 入队列
bool enqueue(LinkedListQueue* q, ElementType element);
// 出队列并返回队头元素
ElementType dequeue(LinkedListQueue* q);
// 访问队头元素
ElementType peek_queue(LinkedListQueue* q);
// 判空
bool is_empty(LinkedListQueue* q);
#endif // ! LIST_QUEUE_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> list_queue.c </font>
</summary>
<pre> <code class="language-c">#include "list_queue.h"
// 创建链式队列
LinkedListQueue* create_queue() &#123;
    return calloc(1, sizeof(LinkedListQueue));
&#125;
// 销毁链式队列
void destroy_queue(LinkedListQueue* q)
&#123;
    QueueNode* curr = q-> front;
    while (curr != NULL) &#123;
        QueueNode* temp = curr-> next;
        free(curr);
        curr = temp;
    &#125;
    free(q);
&#125;
// 入队列
bool enqueue(LinkedListQueue* q, ElementType element)
&#123;
    QueueNode* new_node = calloc(1, sizeof(QueueNode));
    if (new_node == NULL)
    &#123;
        printf("Error: malloc failed in enqueue.\n");
        return false;
    &#125;
    new_node-> data = element;
    new_node-> next = NULL;
    if (q-> front == NULL)
    &#123;
        q-> front = new_node;
        q-> rear = new_node;
    &#125;
    else
    &#123;
        q-> rear-> next = new_node;
        q-> rear = new_node;
    &#125;
    return true;
&#125;
// 出队列并返回队头元素
ElementType dequeue(LinkedListQueue* q)
&#123;
    if (is_empty(q))
    &#123;
        printf("The queue is empty.\n");
        exit(1);
    &#125;
    ElementType item = q-> front-> data;
    QueueNode* temp = q-> front;
    q-> front = temp-> next;
    if (q-> front == NULL)
    &#123;
        q-> rear == NULL;
    &#125;
    free(temp);
    return item;
&#125;
// 访问队头元素
ElementType peek_queue(LinkedListQueue* q)
&#123;
    if (is_empty(q))
    &#123;
        printf("The queue is empty.\n");
        exit(1);
    &#125;
    return q-> front-> data;
&#125;
// 判空
bool is_empty(LinkedListQueue* q)
&#123;
    return q-> front == NULL;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include "list_queue.h"
int main(void) &#123;
    LinkedListQueue* q = create_queue();
    // 逐一入队列
    enqueue(q, 1);
    enqueue(q, 2);
    enqueue(q, 3);
    enqueue(q, 4);
    enqueue(q, 5);
    enqueue(q, 6);
    // 先进先出，出队列全部元素直到队列为空
    while (! is_empty(q)) &#123;
        int val = peek_queue(q);
        printf("%d ", val); // 预期出队列顺序: 1 2 3 4 5 6
        dequeue(q);
    &#125;
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="队列的应用场景">队列的应用场景</h3>
<p>队列是一种非常实用的数据结构，由于其先进先出的特性，队列特别适用于那些需要按顺序处理元素的场景。比如：</p>
<ol type="1">
<li>操作系统的任务调度，进程/线程按照到达顺序来排队等待 CPU
执行权。</li>
<li>各种数据处理系统中的缓冲区/缓存机制。比如 stdin/stdout
缓冲区，先输入缓冲区的数据，总是先从缓冲区输出。</li>
<li>打印机的任务管理，当多个打印任务同时到达时，它们在队列中排队，按照提交的顺序进行打印。</li>
<li>后端应用系统中的消息队列。</li>
<li>广度优先搜索(比如二叉搜索树的层次遍历)</li>
<li>…</li>
</ol>
<h2 id="哈希表">哈希表</h2>
<h3 id="哈希相关概念">哈希相关概念</h3>
<p>哈希（Hash）是一种将 <strong>任意长度大小</strong> 的输入转换处理成
<strong>固定长度大小</strong> 输出的过程：</p>
<ol type="1">
<li>输入可以是一个任意数字或字符串、也可以是一个任意文件等等。<strong>（一般来说同一个哈希过程，输入的类型应该是一致的，但长度大小不限制）</strong></li>
<li>普遍来说，<strong>哈希过程的输出会是一个固定长度的整数</strong>，这个整数就是常说的
<strong>哈希值</strong>。</li>
<li>实现哈希的过程中，代表转换处理规则的就是
<strong>哈希函数</strong>。</li>
</ol>
<p>哈希函数（Hash Function）是实现哈希过程的关键，负责将输入的任意数据
<strong>映射</strong> 到一个哈希值（一般是一个固定长度的整数）上。</p>
<p>哈希函数具有以下特点：</p>
<ol type="1">
<li><strong>同一个输入多次调用哈希函数，必须映射到同一输出上。映射不允许出现一对多。</strong></li>
<li>不同输入多次调用哈希函数，不要求映射到不同输出上。<strong>映射不要求完全一一对应，允许出现多对一，这就是哈希冲突。</strong></li>
</ol>
<p><strong>有关哈希的概念，总结如下：</strong></p>
<p>哈希(过程)：</p>
<ol type="1">
<li>哈希是一种可以接受各种类型、大小的输入，输出一个固定长度整数的过程。</li>
<li><strong>可以将哈希理解成一种特殊的映射，哈希映射，将一个理论无限的集合
A 映射到有限整数集合 B 上。</strong></li>
</ol>
<p><strong>哈希函数</strong>：哈希函数是哈希过程的核心，它决定了哈希映射过程的规则。</p>
<p><strong>哈希冲突</strong>：哈希是一种化无限为有限的映射，允许出现多对一，但绝不允许出现一对多。若映射中出现多对一，就是哈希冲突。哈希冲突可以减少，但绝不可能没有。</p>
<h3 id="哈希表相关概念">哈希表相关概念</h3>
<p>哈希表是一种基于 <strong>“键值对”</strong>
的存储方式的数据结构，能够提供快速的数据查找、插入和删除操作。</p>
<p>哈希表是能够存储键值对元素的数据结构，具体到存储的机制是：</p>
<ol type="1">
<li>先利用哈希函数计算键值对元素中 key <strong>(哈希表的 key
是唯一的)</strong> 对应的哈希值</li>
<li>然后根据哈希值的不同决定这个元素在哈希表中的存储位置。</li>
</ol>
<p>由于哈希冲突的存在，所以哈希表在具体存储元素时，不得不把多个元素存储在同一个位置上，这样就出现了
<strong>哈希桶</strong> 的概念：</p>
<ol type="1">
<li><strong>哈希桶是哈希表存储数据的基本单位，一个哈希表由多个哈希桶组成。</strong></li>
<li><strong>当一个新的键值对需要加入哈希表时，会使用哈希函数计算该键的哈希值，然后根据这个哈希值决定将键值对存储在哪个哈希桶中。</strong></li>
<li><strong>一般而言，每个哈希桶都可以存储一个或多个元素。</strong></li>
</ol>
<p>总之，一个哈希表的概念模型可以用下图描述(不涉及实现)：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311281546792.png" alt="哈希表的概念模型图" style="zoom: 33%;" />
</div>
<p>根据这个理论模型，我们不难发现：</p>
<p>假设在完美情况下，哈希冲突不出现，任何一个哈希桶都只用存储一个元素，那么这个哈希表就是一个数组。</p>
<p>也就是说在理想、完美的情况下，哈希表就是一个数组。当然这种情况，在现实里并不存在，哈希冲突是必然存在的。</p>
<h3 id="哈希函数">哈希函数</h3>
<p>哈希函数是整个哈希过程的核心，那么应该如何设计一个哈希函数呢？什么样的哈希函数是一个优秀的哈希函数呢？</p>
<p>在编程领域，哈希函数的最常见应用就是实现哈希表。为了哈希表的性能考虑，此哈希函数应该：</p>
<ol type="1">
<li>能够快速计算。在实现哈希表时，对安全性没有非常高的要求，但如果哈希函数的效率很差势必影响哈希表的性能。</li>
<li>均匀映射，尽量减少哈希冲突。哈希函数应该将输入均匀地映射到输出当中。这减少了哈希冲突的概率，意味着不同的输入值更有可能得到不同的哈希值。</li>
</ol>
<p>但如果将哈希函数运用到其他领域，比如文件校验，密码存储等(密码学场景)，对哈希函数的要求就会更高：</p>
<ol type="1">
<li>几乎没有哈希冲突。使得哈希值能够像指纹一样，可以作为输入的唯一标识。</li>
<li>通过哈希值逆向破解输入几乎不可能。</li>
<li>对输入的任何一点修改，都最好得到一个完全不同的哈希值。</li>
</ol>
<p>在非密码学场景(追求高效计算、不追求极致减少哈希冲突)，比较常用的哈希算法有：<strong>MurmurHash</strong>，该算法以高运行效率和分布均匀性著称，在实现哈希表时选择它非常合适。</p>
<p>在密码学场景中(追求极致减少哈希冲突，追求安全性)，比较常用的算法有：MD5，SHA1，SHA-256，SHA-3
等。MD5 和 SHA1 由于存在明显的安全漏洞，已基本被淘汰。SHA-256
是目前最常见、最推荐的密码学哈希算法。</p>
<p>在后续实现哈希表时，这里给出一个 MurmurHash 哈希算法在 C
语言中的实现函数：</p>
<details>
<summary>
<font size="4" color="orange"> Show Code </font>
</summary>
<pre> <code class="language-c">/* murmur_hash2 */
static uint32_t hash(const void* key, int len, uint32_t seed) &#123;
    const uint32_t m = 0x5bd1e995;
    const int r = 24;
    uint32_t h = seed ^ len;
    const unsigned char * data = (const unsigned char*)key;
    while (len >= 4) &#123;
        uint32_t k = *(uint32_t*)data;
        k *= m;
        k ^= k >> r;
        k *= m;
        h *= m;
        h ^= k;
        data += 4;
        len -= 4;
    &#125;
    switch (len) &#123;
        case 3: h ^= data [2] << 16;
        case 2: h ^= data [1] << 8;
        case 1: h ^= data [0];
            h *= m;
    &#125;;
    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;
    return h;
&#125;</code>
</pre>
</details>
<p>MurmurHash
是一种非加密哈希函数，适用于一般的哈希检索操作。它以高运行速度和分布均匀性而闻名。其中
uint32_t 表示无符号 32 位整型，要想使用它需要包含 <strong>头文件
&lt;stdint.h&gt;</strong>。</p>
<p>该函数调用需要三个参数：</p>
<ol type="1">
<li><p><strong>void* key，也就是需要计算哈希值的 key 元素。</strong>
此形参的类型是
void*，这意味着它可以传入任何类型的数据，提高了函数的通用性。</p>
<ul>
<li><p>如果 key 是基本数据类型，那就传入指向基本数据类型的指针</p></li>
<li><p>如果 key
本身就是一个指针类型，比如字符串，那么就直接传入这个指针就可以了。</p></li>
</ul></li>
<li><p>int len，表示哈希函数要处理的 key 的大小长度。key
若是字符串可以使用函数 strlen 计算，若是其它类型可以使用 sizeof
计算。</p></li>
<li><p>uint32_t seed，种子值。</p>
<ul>
<li><p>此哈希函数会根据 key 和 seed 共同生成一个哈希值</p></li>
<li><p>不同的种子值会导致相同的数据产生不同的哈希值。<strong>需要注意的是，在程序一次运行中，同一个哈希表应该具有相同的种子值！</strong></p></li>
<li><p>最常见的设置种子值的方式就是用时间戳，也就是
<code>time(NULL);</code> 函数调用。</p></li>
</ul></li>
</ol>
<h3 id="哈希表的核心操作">哈希表的核心操作</h3>
<p>对于一个哈希表而言，最核心的操作是三个：</p>
<ol type="1">
<li><p>插入一个新的键值对。<strong>(哈希表中的 key
是唯一的)</strong></p>
<ul>
<li><p>如果 key 已存在重复，更新对应 value</p></li>
<li><p>如果 key 不存在，将新的键值对添加到哈希表中。</p></li>
</ul></li>
<li><p>根据 key 查找目标 value。</p></li>
<li><p>根据 key 删除目标键值对元素。</p></li>
</ol>
<p>一般来说，不管采用何种方式实现哈希表，都要尽量保证这三个基本操作的时间复杂度接近
O(1)</p>
<p>除此之外，遍历哈希表也是一个常见操作。</p>
<h3 id="如何实现一个哈希表">如何实现一个哈希表？</h3>
<p>在实现一个哈希表的过程中，最需要关注的是两个问题：</p>
<ol type="1">
<li>选择哪一个哈希函数？这一点我们在上面已经给出了答案。</li>
<li>如何设计哈希桶呢？由于哈希冲突一定存在，哈希桶的设计要保证能够处理这种冲突导致的多个元素要存储在一个哈希桶中。所以换句话说，这个问题就是——如何处理哈希冲突呢？</li>
</ol>
<p>关于这个话题，这里给出两种常见办法。</p>
<h4 id="开放寻址法">开放寻址法</h4>
<p>哈希表是一种增查频繁的数据结构，这让我们想起了数组，因为数组根据索引增查效率很高，于是直接将一个数组当成哈希表。那怎么处理冲突问题呢？</p>
<p>一旦出现哈希冲突，就采取下列办法找到一个空位置：</p>
<ol type="1">
<li>线性探测法，逐一探测下一个位置是否为空位置，直到找到。</li>
<li>平方探测法，每次探测都会检查当前位置索引加上探测次数的平方（1, 4, 9,
16, …）的位置。</li>
<li>再哈希法。使用多个哈希函数共同实现哈希表，当插入一个元素时，首先使用第一个哈希函数计算其位置，若冲突，则继续调用后续函数，直到不冲突为止。</li>
<li>…</li>
</ol>
<p>这种解决哈希冲突的方式，就是常说到的
<strong>“开放寻址法”</strong>。</p>
<p>开放寻址法听起来实现简单，利用数组的随机访问，内存连续效率高，但实际上：</p>
<ol type="1">
<li><p>删除操作实现非常困难，复杂。</p>
<ul>
<li><p>删除操作如果只是简单修改数据，那么后续查找可能出现误访问，于是可能需要特殊标记以表示元素被删除。这样实现很麻烦，而且会拖累查询的效率。</p></li>
<li><p>如果通过整体挪动数组元素来表示删除，那删除效率就太差了，也不太可取。</p></li>
</ul></li>
<li><p>数据量较大时哈希冲突难以解决。</p></li>
<li><p>开放寻址法必然意味着，需要经常进行数组扩容。</p>
<ul>
<li><p>这个过程，往往需要重分配内存</p></li>
<li><p>然后将原数组中所有的元素再哈希，拷贝到新数组中。</p></li>
<li><p>这样的一套操作下来，成功过于高昂。</p></li>
</ul></li>
</ol>
<p>但也不是说这种方式完全一无是处，当你有以下场景时：</p>
<ol type="1">
<li>数据量比较少，不需要频繁扩容数组。</li>
<li>删除操作几乎不做，只做增查操作。</li>
</ol>
<p>这时倒也不妨可以使用 “开放寻址法” 来实现哈希表。</p>
<p>但对于大多一般开发场景而言，哈希表的实现基本不会采用开放寻址法。</p>
<h4 id="拉链法常用">拉链法(常用)</h4>
<p>解决哈希冲突，设计实现哈希桶，在开发中最常见的方式还是拉链法，也就是采用
“数组 + 链表” 的方式来实现哈希桶。具体而言：以一个
<strong>键值对结点指针数组</strong>
为哈希表的基本结构，此数组的每一个存储单元都指向一个键值对结点链表。</p>
<p>这种设计下哈希表的基本操作思路如下(大致)：</p>
<ol type="1">
<li><p>进行插入操作时，计算 key
的哈希值以确定存储的哈希桶位置，接下来：</p>
<ul>
<li><p>若哈希桶为空，则此结点成为哈希桶的第一个元素。</p></li>
<li><p>若哈希桶不为空，则需要遍历哈希桶，如果 “Key” 已存在，则更新
Value。若 “Key”
不存在，则再向哈希桶中添加一个元素。此时哈希桶中的多个元素，是以链表的形式挂起来的。</p></li>
</ul></li>
<li><p>进行查找操作时：同样先计算 key
的哈希值，然后在对应索引的链表中遍历查找这个键。</p></li>
<li><p>进行删除操作时：也是先计算 key
的哈希值，然后在对应链表中找到并移除这个键值对。</p></li>
</ol>
<p>拉链法实现的哈希表，实际上就是数组的高访问效率和链表的灵活性的综合应用，是最常见的哈希表实现方式。如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311262031612.png" alt="拉链法-实现哈希表" style="zoom: 33%;" />
</div>
<p>下面，基于 C
语言，以拉链法来实现一个固定容量的哈希表。（若以动态数组实现哈希表，就可实现扩容）</p>
<h3 id="代码实现-4">代码实现</h3>
<details>
<summary>
<font size="4" color="orange"> hash_map.h </font>
</summary>
<pre> <code class="language-c">#ifndef HASH_MAP_H
#define HASH_MAP_H
#include &lt; stdint.h&gt; // 包含它是为了使用别名 uint32_t
#include &lt; stdbool.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
#include &lt; string.h&gt;
#define HASHMAP_CAPACITY 10 // 哈希表中数组的长度固定是 10
// 此时哈希表用于存储字符串类型的键值对
typedef char* KeyType;
typedef char* ValueType;
// 键值对结点
typedef struct node_s &#123;
    KeyType key;
    ValueType val;
    struct node_s* next;
&#125; KeyValueNode;
typedef struct &#123;
    // 哈希桶
    KeyValueNode* buckets [HASHMAP_CAPACITY];    // 直接给定哈希桶的数量是 10 个
    // 哈希函数需要的种子值
    uint32_t hash_seed;
&#125; HashMap;
// 创建一个固定容量的哈希表
HashMap* hashmap_create();
// 销毁一个哈希表
void hashmap_destroy(HashMap* map);
// 插入一个键值对
ValueType hashmap_put(HashMap* map, KeyType key, ValueType val);
// 查询一个键值对
ValueType hashmap_get(HashMap* map, KeyType key);
// 删除某个键值对
bool hashmap_remove(HashMap* map, KeyType key);
#endif // ! HASH_MAP_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> hash_map.c </font>
</summary>
<pre> <code class="language-c">#include "hash_map.h"
/* murmur_hash2 */
static uint32_t hash(const void* key, int len, uint32_t seed) &#123;
    const uint32_t m = 0x5bd1e995;
    const int r = 24;
    uint32_t h = seed ^ len;
    const unsigned char * data = (const unsigned char*)key;
    while (len >= 4) &#123;
        uint32_t k = *(uint32_t*)data;
        k *= m;
        k ^= k >> r;
        k *= m;
        h *= m;
        h ^= k;
        data += 4;
        len -= 4;
    &#125;
    switch (len) &#123;
    case 3: h ^= data [2] << 16;
    case 2: h ^= data [1] << 8;
    case 1: h ^= data [0];
        h *= m;
    &#125;;
    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;
    return h;
&#125;
// 创建一个固定容量的哈希表
HashMap* hashmap_create() &#123;
    HashMap* map = calloc(1, sizeof(HashMap));
    if (map == NULL) &#123;
        printf("error: calloc failed in hashmap_create.\n");
        exit(-1);
    &#125;
    map-> hash_seed = time(NULL);
    return map;
&#125;
// 销毁一个哈希表
void hashmap_destroy(HashMap* map) &#123;
    // 遍历数组, 然后销毁哈希桶中的链表, 最后销毁 HashMap 结构体
    for (size_t i = 0; i < HASHMAP_CAPACITY; i++) &#123;
        KeyValueNode* curr = map-> buckets [i];
        while (curr != NULL) &#123;
            KeyValueNode* tmp = curr-> next;
            free(curr);
            curr = tmp;
        &#125;
    &#125;
    free(map);
&#125;
// 插入一个键值对
ValueType hashmap_put(HashMap* map, KeyType key, ValueType val) &#123;
    // 1.计算哈希值确定哈希桶的位置
    int idx = hash(key, strlen(key), map-> hash_seed) % HASHMAP_CAPACITY;
    // 2.遍历哈希桶，查找 Key 是否重复
    KeyValueNode* curr = map-> buckets [idx];
    while (curr != NULL) &#123;
        // 比较字符串
        if (strcmp(key, curr-> key) == 0) &#123;
            // key 已存在, 更新 value, 并返回旧 value
            ValueType old_val = curr-> val;
            curr-> val = val;
            return old_val;
        &#125;
        curr = curr-> next;
    &#125;
    // 3.只要 Key 不重复肯定都要插入，于是无脑使用链表头插法插入结点
    KeyValueNode* new_node = malloc(sizeof(KeyValueNode));
    if (new_node == NULL) &#123;
        printf("Error: malloc failed in hashmap_put.\n");
        exit(1);
    &#125;
    new_node-> key = key;    // key 和 val 都是指针类型，可以直接 "=" 赋值
    new_node-> val = val;
    // 链表头插法
    new_node-> next = map-> buckets [idx]; // 新结点指向原本的第一个结点
    map-> buckets [idx] = new_node;   // 更新头指针
    // 没有更新键值对返回空指针
    return NULL;
&#125;
// 查询一个键值对
ValueType hashmap_get(HashMap* map, KeyType key) &#123;
    // 1.计算哈希值确定哈希桶的位置
    int idx = hash(key, strlen(key), map-> hash_seed) % HASHMAP_CAPACITY;
    // 2.遍历哈希桶，查找 Key 是否存在
    KeyValueNode* curr = map-> buckets [idx];
    while (curr != NULL) &#123;
        // 比较字符串
        if (strcmp(key, curr-> key) == 0) &#123;
            // 已找到目标键值对
            return curr-> val;
        &#125;
        curr = curr-> next;
    &#125;
    // 目标键值对不存在
    return NULL;
&#125;
// 删除某个键值对
bool hashmap_remove(HashMap* map, KeyType key) &#123;
    // 1.计算哈希值确定哈希桶的位置
    int idx = hash(key, strlen(key), map-> hash_seed) % HASHMAP_CAPACITY;
    // 2.初始化两个指针, 用于删除结点
    KeyValueNode* curr = map-> buckets [idx];
    KeyValueNode* prev = NULL;
    // 3.遍历链表查找目标 Key
    while (curr != NULL) &#123;
        // 比较字符串
        if (strcmp(key, curr-> key) == 0) &#123;
            // 已找到目标键值对
            if (prev == NULL) &#123;
                // 删除的是第一个结点
                map-> buckets [idx] = curr-> next;
            &#125;
            else
            &#123;
                // 删除的不是第一个结点
                prev-> next = curr-> next;
            &#125;
            // free 结点
            free(curr);
            return true;    // 删除成功
        &#125;
        prev = curr;        // 更新 prev 为当前节点
        curr = curr-> next;  // 当前结点向后移动
    &#125;
    // 没找到目标键值对, 删除失败
    return false;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#include "hash_map.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(void) &#123;
    // 创建哈希表
    HashMap* map = hashmap_create();
    if (map == NULL) &#123;
        printf("哈希表创建失败。\n");
        return 1;
    &#125;
    // 插入键值对
    hashmap_put(map, "key1", "value1");  // 首次插入，应成功
    hashmap_put(map, "key2", "value2");  // 再插一个新键值对，应成功
    char* old_value = hashmap_put(map, "key1", "value3");  // 更新已存在的键值对，应返回旧值 "value1"
    printf("更新键值对时返回的旧值应为 value1，实际返回：%s\n", old_value);
    // 查询键值对
    char* value = hashmap_get(map, "key1");
    printf("期待得到 value3，实际得到：%s\n", value);  // 预期输出 value3
    value = hashmap_get(map, "key2");
    printf("期待得到 value2，实际得到：%s\n", value);  // 预期输出 value2
    value = hashmap_get(map, "key3");
    if (value == NULL) &#123;
        printf("如预期，key3 未找到\n");  // 预期找不到 key3
    &#125;
    // 删除键值对
    bool deleted = hashmap_remove(map, "key1");  // 删除 key1, 预期删除成功
    if (deleted) &#123;
        printf("key1 成功删除。\n");
    &#125;
    deleted = hashmap_remove(map, "key3");  // 尝试删除不存在的 key3, 预期删除失败
    if (! deleted) &#123;
        printf("key3 未找到且未删除，符合预期。\n");
    &#125;
    // 销毁哈希表
    hashmap_destroy(map);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析">性能分析</h3>
<p>拉链法解决哈希冲突实现的哈希表，在选择合适的哈希算法，键值对较为平均分布的前提下，其性能取决于哈希表中链表的
<strong>平均长度 L</strong>：</p>
<ol type="1">
<li>在 <strong>最佳情况</strong>
下，即哈希函数均匀分布且冲突较少时，哈希表的插入、查询和删除操作的效率非常高，接近
O(1)。</li>
<li>在 <strong>最坏情况</strong>
下，特别是哈希冲突很多导致链表过长时，这些操作的效率会降低，接近
O(L)，因为此时的哈希表访问几乎相当于链表的访问。</li>
</ol>
<p>为了保证哈希表的性能，就需要控制链表的长度不能太长，也就是要
<strong>控制哈希表不能太满</strong>，要始终留出一定的空位，这样才不会出现过多的元素用链表存储的情况。</p>
<p>为了衡量一个哈希表满的程度，我们提出了 <strong>“负载因子(Load Factor
)”</strong> 的概念： <span class="math display">\[
负载因子 = \frac{哈希表中的键值对总数}{哈希表底层数组的长度}
\]</span> 一般来说，负载因子在 0.7/0.75
以下时，哈希表处在健康、性能优秀的状态。但一旦超出这个阈值，就意味着哈希冲突会增多，链表平均长度变长，从而导致性能下降。</p>
<p>此时，为了维持哈希表的高效性能，通常采取的措施是“扩容”和“重新哈希”。在拉链法的哈希表中也就是
<strong>对数组进行扩容，然后将所有元素重新哈希再映射到新哈希表中</strong>。</p>
<p>既然要扩容，那就需要使用动态数组实现哈希桶的底层，涉及到内存重分配、以及全部元素重新哈希确定存储的哈希桶，显然是一个非常耗费性能的操作。因此，这个过程应该尽量避免频繁发生。</p>
<h3 id="实现动态哈希表">实现动态哈希表</h3>
<h4 id="设计思路-4">设计思路</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202403011402087.png" alt="动态哈希表-概念模型图" style="zoom: 33%;" />
</div>
<h4 id="代码实现-5"><strong>代码实现</strong></h4>
<details>
<summary>
<font size="4" color="orange"> dynamic_hashmap.h </font>
</summary>
<pre> <code class="language-c">#ifndef DYNAMIC_HASHMAP_H
#define DYNAMIC_HASHMAP_H
#include &lt; stdint.h&gt;
#include &lt; stdbool.h&gt;
#include &lt; string.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
typedef char* KeyType;
typedef char* ValueType;
typedef struct node_s &#123;
    KeyType key;
    ValueType val;
    struct node_s* next;
&#125; KeyValueNode;
typedef struct &#123;
    KeyValueNode** buckets;     // 此时哈希桶是一个动态数组，指向 char*元素的指针，所以是一个二级指针
    int size;               // 键值对的个数
    int capacity;           // 数组的长度
    uint32_t hash_seed;     // 哈希函数需要的种子值
&#125; DynamicHashMap;
// 创建一个固定容量的哈希表
DynamicHashMap* hashmap_create();
// 销毁一个哈希表
void hashmap_destroy(DynamicHashMap* map);
// 插入一个键值对
ValueType hashmap_put(DynamicHashMap* map, KeyType key, ValueType val);
// 查询一个键值对
ValueType hashmap_get(DynamicHashMap* map, KeyType key);
// 删除某个键值对
bool hashmap_remove(DynamicHashMap* map, KeyType key);
#endif // ! DYNAMIC_HASHMAP_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> dynamic_hashmap.c </font>
</summary>
<pre> <code class="language-c">#include "dynamic_hashmap.h"
#define DEFAULT_CAPACITY 8  // 哈希表的初始默认容量是 8
#define LOAD_FACTOR_THRESHOLD  0.75     // 负载因子的阈值
#define CAPACITY_THRESHOLE 1024     // 数组容量的阈值
/* murmur_hash2 */
static uint32_t hash(const void* key, int len, uint32_t seed) &#123;
    const uint32_t m = 0x5bd1e995;
    const int r = 24;
    uint32_t h = seed ^ len;
    const unsigned char * data = (const unsigned char*)key;
    while (len >= 4) &#123;
        uint32_t k = *(uint32_t*)data;
        k *= m;
        k ^= k >> r;
        k *= m;
        h *= m;
        h ^= k;
        data += 4;
        len -= 4;
    &#125;
    switch (len) &#123;
    case 3: h ^= data [2] << 16;
    case 2: h ^= data [1] << 8;
    case 1: h ^= data [0];
        h *= m;
    &#125;;
    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;
    return h;
&#125;
// 创建一个固定容量的哈希表
DynamicHashMap* hashmap_create() &#123;
    DynamicHashMap* map = calloc(1, sizeof(DynamicHashMap));
    if (map == NULL)
    &#123;
        printf("Error: malloc failed in hashmap_create.\n");
        exit(1);
    &#125;
    map-> buckets = calloc(DEFAULT_CAPACITY, sizeof(KeyValueNode*));
    if (map-> buckets == NULL)
    &#123;
        printf("Error: malloc failed in hashmap_create.\n");
        free(map);
        exit(1);
    &#125;
    map-> capacity = DEFAULT_CAPACITY;
    map-> hash_seed = time(NULL);
    return map;
&#125;
// 销毁一个哈希表
void hashmap_destroy(DynamicHashMap* map) &#123;
    // 1.先遍历动态数组销毁链表的每一个结点
    for (int i = 0; i < map-> capacity; i++) &#123;
        KeyValueNode* curr = map-> buckets [i];
        while (curr != NULL) &#123;
            KeyValueNode* tmp = curr-> next;
            free(curr);
            curr = tmp;
        &#125;
    &#125;
    // 2.再销毁动态数组
    free(map-> buckets);
    // 3.最后销毁哈希表结构体
    free(map);
&#125;
static void rehash(KeyValueNode * curr, KeyValueNode** new_table, int new_capacity, uint32_t seed) &#123;
    int len = strlen(curr-> key);
    int idx = hash(curr-> key, len, seed) % new_capacity;
    curr-> next = new_table [idx];
    new_table [idx] = curr;
&#125;
// 对哈希表进行扩容操作
static void grow_capacity(DynamicHashMap* map) &#123;
    /*
    * 扩容策略：
    * 1.如果容量没有达到阈值，那就每次将长度扩大为原先的 2 倍
    * 2.如果容量达到阈值，此时哈希表已经很长了，为了避免扩容过程性能损耗过大
    *   所以扩容保守一些，每次只扩容阈值长度的容量
    *
    * 扩容的过程：
    * 1.每个键值对结点都要重新计算哈希值，重新映射到新哈希桶中(新数组)
    * 2.原先的动态数组的链表很复杂，难以进行重哈希操作，建议直接丢弃它
    * 重新创建一个新动态数组
    */
    int new_capacity = (map-> capacity <= CAPACITY_THRESHOLE)
        ? (map-> capacity << 1) : (map-> capacity + CAPACITY_THRESHOLE);
    KeyValueNode** new_buckets = calloc(new_capacity, sizeof(KeyValueNode*));
    if (new_buckets == NULL) &#123;
        printf("Error: calloc failed in grow_capacity\n");
        exit(1);
    &#125;
    uint32_t seed = time(NULL);
    for (size_t i = 0; i < map-> capacity; i++)
    &#123;
        KeyValueNode* curr = map-> buckets [i];
        while (curr != NULL) &#123;
            KeyValueNode* next = curr-> next;
            rehash(curr, new_buckets, new_capacity, seed);
            curr = next;
        &#125;
    &#125;
    // 将旧动态数组 free，但是注意不要 free 键值对结点，结点已经被链接到新数组中了。
    free(map-> buckets);
    // 更新 HashMap 的信息
    map-> buckets = new_buckets;
    map-> capacity = new_capacity;
    map-> hash_seed = seed;
    &#125;
    // 插入一个键值对
    // 1. 如果 key 不存在，则添加键值对结点
    // 2. 如果 key 存在，则更新 val，将旧的 val 返回
    ValueType hashmap_put(DynamicHashMap* map, KeyType key, ValueType val) &#123;
    // 计算 key 的哈希值确定存储位置
    int idx = hash(key, strlen(key), map-> hash_seed) % (map-> capacity);
    // 遍历链表
    KeyValueNode* curr = map-> buckets [idx];
    while (curr != NULL) &#123;
        if (strcmp(key, curr-> key) == 0) &#123;
            // 更新 key 关联的 val, 并将旧的 value 返回
            ValueType old_val = curr-> val;
            curr-> val = val;
            return old_val;
        &#125;
        curr = curr-> next;
    &#125; // while 循环结束时, curr 是一个 NULL
    // 键值对不存在，即需要将键值对插入
    // 插入操作前需要计算当前哈希表的负载因子
    double load_factor = 1.0 * map-> size / map-> capacity;
    if (load_factor >= LOAD_FACTOR_THRESHOLD)
    &#123;
        // 当前哈希表负载因子已达到阈值，将动态数组进行扩容
        grow_capacity(map);
        // 数组长度已变，需要再哈希确定当前键值对的存储位置
        idx = hash(key, strlen(key), map-> hash_seed) % (map-> capacity);
    &#125;
    // 开始插入新键值对
    KeyValueNode* new_node = calloc(1, sizeof(KeyValueNode));
    if (new_node == NULL)
    &#123;
        printf("Error: calloc failed in grow_capacity\n");
        exit(1);
    &#125;
    // 初始化结点
    new_node-> key = key;
    new_node-> val = val;
    // 链表的头插法
    new_node-> next = map-> buckets [idx];
    map-> buckets [idx] = new_node;
    // 不要忘记更新 size
    map-> size++;
    return NULL;
    &#125;
    // 查询一个键值对
    ValueType hashmap_get(DynamicHashMap* map, KeyType key) &#123;
    // 计算 key 的哈希值确定位置
    int idx = hash(key, strlen(key), map-> hash_seed) % (map-> capacity);
    // 遍历链表
    KeyValueNode* curr = map-> buckets [idx];
    while (curr != NULL) &#123;
        if (strcmp(key, curr-> key) == 0) &#123;
            return curr-> val;
        &#125;
        curr = curr-> next;
    &#125; 
    return NULL;
    &#125;
    // 删除某个键值对
    bool hashmap_remove(DynamicHashMap* map, KeyType key) &#123;
    // 计算 key 的哈希值确定位置
    int idx = hash(key, strlen(key), map-> hash_seed) % (map-> capacity);
    // 遍历链表
    KeyValueNode* curr = map-> buckets [idx];
    KeyValueNode* prev = NULL;
    while (curr != NULL) &#123;
        if (strcmp(key, curr-> key) == 0) &#123;
            if (prev == NULL)
            &#123;
                map-> buckets [idx] = curr-> next;
            &#125;
            else
            &#123;
                prev-> next = curr-> next;
            &#125;
            free(curr);
            map-> size--;
            return true;
        &#125;
        prev = curr;
        curr = curr-> next;
    &#125;
    return false;
    &#125;</code>
    </pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include "dynamic_hashmap.h"
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; string.h&gt;
#define N 100 // 初始容量是 8，设置为 10 足以触发一次扩容
int main() &#123;
    // 创建哈希表
    DynamicHashMap* map = hashmap_create();
    if (map == NULL) &#123;
        printf("哈希表创建失败。\n");
        return 1;
    &#125;
    // 插入多个键值对以触发扩容
    char tmp_key [1024], tmp_val [1024];
    for (int i = 0; i < N; i++) &#123;
        /*
            sprintf 是一个将格式化的数据输出到一个字符数组中，并最终保存为字符串的标准库函数
            第一个参数是输出的目的地字符串
            后面的参数则和 printf 使用方式一样
        */
        sprintf(tmp_key, "key%d", i);
        sprintf(tmp_val, "value%d", i);
        // 使用 calloc 分配和复制键值对
        char* key = calloc(strlen(tmp_key) + 1, sizeof(char));
        char* val = calloc(strlen(tmp_val) + 1, sizeof(char));
        strcpy(key, tmp_key);
        strcpy(val, tmp_val);
        hashmap_put(map, key, val);
        printf("插入 %s: %s\n", key, val);
    &#125;
    // 检查扩容前后的数据一致性
    bool flag = true;
    for (int i = 0; i < N; i++) &#123;
        sprintf(tmp_key, "key%d", i);
        ValueType ret_val = hashmap_get(map, tmp_key);
        sprintf(tmp_val, "value%d", i);
        if (ret_val == NULL || strcmp(ret_val, tmp_val) != 0) &#123;
            printf("错误：数据不一致，键 %s 应有的值为 %s，检索得到的值为 %s\n",
                tmp_key, tmp_val,
                ((ret_val != NULL) ? ret_val : "null"));
            flag = false;   // 若数据插入有问题，则修改标志为 false
        &#125;
    &#125;
    if (flag) &#123;
        printf("所有数据在扩容后仍正确无误。\n");
    &#125;
    // free 所有堆上分配的字符串
    for (int i = 0; i < map-> capacity; i++) &#123;
        KeyValueNode* curr = map-> buckets [i];
        while (curr != NULL) &#123;
            free(curr-> key);   // 释放键字符串
            free(curr-> val);   // 释放值字符串
            curr = curr-> next;
        &#125;
    &#125;
    // 销毁哈希表
    hashmap_destroy(map);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="哈希表的应用场景">哈希表的应用场景</h3>
<p>哈希表的应用十分广泛，任何编程语言的程序在日常开发中，哈希表都是必须要使用的数据结构。它大致有以下常见的用途：</p>
<ol type="1">
<li>用作容器，存储键值对元素。用作容器是哈希表最常见的使用场景之一，毕竟键值对数据在开发中出现的频率很高，比如
“用户名-密码”
等。常见的高级编程语言，往往都会提供现成的哈希表库实现，比如：
<ol type="1">
<li>C++ 中的 <code>unordered_map</code> 和 <code>unordered_set</code>。
<ul>
<li>map
是是一种存储键值对的哈希表容器，提供了高效的插入，查询，删除等操作。</li>
<li>set
是一种基于哈希表的集合容器，它存储唯一元素，并提供高效的成员插入、查找和删除操作。</li>
</ul></li>
<li>Java 中的 <code>HashMap</code> 和 <code>HashSet</code> 以及
<code>HashTable</code>，它们都是基于哈希表实现的集合容器。</li>
</ol></li>
<li>在算法领域，哈希表还经常用于以下场景中：
<ol type="1">
<li><strong>查找重复或唯一元素</strong>：哈希表提供了快速查询和插入的功能，且
Key 唯一使得它在查重或查找唯一元素时特别好用。</li>
<li><strong>计数器应用</strong>：统计频率次数，也是哈希表经常应用的场景。</li>
</ol></li>
<li>哈希表可以用于实现数据库的索引，提高数据库的访问效率。</li>
<li>哈希表还常用于实现缓存，利用其快速查询的特点，用于快速查询缓存的消息。比如目前业界最流行的高速缓存中间件——Redis，它有个别名叫：键值对内存数据库，哈希表是
Redis 最常用的类型之一。</li>
</ol>
<h2 id="二叉搜索树">二叉搜索树</h2>
<h3 id="二叉树">二叉树</h3>
<p>树是一种层次化的数据结构，它在现实生活和计算机科学中广泛存在并发挥重要作用。比如：</p>
<ol type="1">
<li>族谱(Family Tree)</li>
<li>组织架构</li>
<li>计算机文件系统的目录结构</li>
<li>…</li>
</ol>
<p>树这种数据结构的特点，是从一个单一的根结点开始，分支出多个结点，每个结点又可能有自己的子结点，形成一个分层次的树状结构。</p>
<p>不过在众多的树形结构中，我们只学习二叉树，原因很简单，它很重要！</p>
<p>它有多重要呢？</p>
<p>单就面试而言，在 LeetCode 中二叉树相关的题目共有 300
多道，占据总题目的近三分之一。同时，二叉树在整个算法板块中还起到承上启下的作用：它不但是数组和链表的延伸，又可以作为图的基础。总之，非常重要！</p>
<p>那什么是 <strong>二叉树(BinaryTree)</strong> 呢？</p>
<p><strong>二叉树的定义：二叉树是一棵树，并且二叉树的每个结点最多有两棵子树。二叉树的子树又分为左子树和右子树。</strong></p>
<p>从根结点开始，每个结点最多有两棵子树，这就是一棵
“二叉树”。二叉树有两种比较独特的形态：完全二叉树和满二叉树。</p>
<p>完全二叉树，若二叉树的深度为 h，除第 h
层外，其它各层(1～h-1)的结点数目都达到最大值，第 h
层的结点都连续排列在最左边，这样的二叉树就是完全二叉树。</p>
<p>满二叉树，每一层的结点数目都达到最大值(包括最下面一层)。</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311300942801.png" alt="完全二叉树和满二叉树-示意图" style="zoom: 67%;" />
</div>
<h3 id="二叉搜索树-1">二叉搜索树</h3>
<p><strong>二叉搜索树是一种特殊的二叉树，其中每个结点的左子树只包含小于当前结点的值，右子树只包含大于当前结点的值。</strong></p>
<p>当然二叉搜索树的定义非常适合使用递归：</p>
<p>二叉搜索树是一种特殊的二叉树，从根结点开始，其每个结点都满足：</p>
<ol type="1">
<li>左子树中的每个结点的值都小于该结点的值，并且左子树本身也是二叉搜索树</li>
<li>右子树中的每个结点的值都大于该结点的值，并且右子树本身也是二叉搜索树</li>
</ol>
<p>所以二叉搜索树在定义时就已经和递归绑定了，我们在下面处理二叉搜索树时，递归是常用的手段。</p>
<p>如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312011624046.png" alt="二叉搜索树-示意图" style="zoom: 33%;" />
</div>
<p><strong>需要注意的是，二叉搜索树只是在二叉树的基础上规定了结点取值的大小关系，二叉搜索树并不一定就是完全二叉树、满二叉树。</strong></p>
<h3 id="设计思路-5">设计思路</h3>
<p>可以用一个结构体描述二叉搜索树的某个结点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="comment">// 二叉搜索树的结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"> KeyType key;       <span class="comment">// 结点 key 值, 具有唯一性</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span> <span class="comment">// 左子树</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span>    <span class="comment">// 右子树</span></span><br><span class="line">&#125; TreeNode;</span><br></pre></td></tr></table></figure>
<p>其中 key
决定了结点在树中的存储位置，也是搜索的凭证。所以出于简化操作的目的，大多二叉搜索树都会规定
<strong>key 是唯一的</strong>。</p>
<p>二叉搜索树最重要、基础的操作有以下：</p>
<ol type="1">
<li>插入。向树中添加一个新的结点。这个操作需要保持二叉搜索树的性质，即插入的结点必须放置在保持左子结点小于父结点，且右子结点大于父结点的正确位置上。</li>
<li>搜索。根据 key
查找目标结点。在二叉搜索树中，搜索操作可以高效进行，通过比较目标值与结点值来决定向左子树或右子树移动。搜索操作的实现是比较简单的。</li>
<li><strong>删除。根据 key
从树中删除某个结点。这是二叉搜索树中最复杂的操作。</strong></li>
<li>遍历。遍历树中的所有结点。常见的遍历方式有前序遍历、中序遍历、后序遍历以及层次遍历。其中，中序遍历二叉搜索树会得到一个有序的结点序列。</li>
</ol>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202401112321181.png" alt="二叉搜索树实现-概念模型" style="zoom: 50%;" />
</div>
<h3 id="代码实现-6">代码实现</h3>
<details>
<summary>
<font size="4" color="orange"> bst.h </font>
</summary>
<pre> <code class="language-c">#ifndef BST_H
#define BST_H
#include &lt; stdbool.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
typedef int KeyType;
typedef struct node &#123;
    KeyType key;        // 结点 key 值, 具有唯一性
    struct node* left;  // 左子树
    struct node* right; // 右子树
&#125; TreeNode;
// 推荐定义一个二叉搜索树的结构体, 这样更便于扩展
typedef struct &#123;
    TreeNode* root; // 根结点指针
&#125;BST;
// 基础操作
// 创建一棵空的 BST
BST* bst_create();
// 销毁一棵 BST
void bst_destroy(BST* tree);
// 根据 key 插入一个新结点
bool bst_insert(BST* tree, KeyType key);
// 根据 key 搜索某个结点并返回
TreeNode * bst_search(BST* tree, KeyType key);
// 根据 key 删除一个结点
bool bst_delete(BST* tree, KeyType key);
// 深度优先-先序遍历
void bst_preorder(BST* tree);
// 深度优先-中序遍历
void bst_inorder(BST* tree);
// 深度优先-后序遍历
void bst_postorder(BST* tree);
// 广度优先-层次遍历
void bst_levelorder(BST* tree);
#endif // ! BST_H
</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> bst.c </font>
</summary>
<pre> <code class="language-c">#include "bst.h"
#include "list_queue.h"
BST* bst_create()
&#123;
    return  calloc(1, sizeof(BST));
&#125;
/*
* 向二叉搜索树中新增一个结点
* 1.若 key 已存在，则不新增，插入失败
* 2.若 key 不存在，则进行新增，插入成功
*/
bool bst_insert(BST* tree, KeyType key) &#123;
    // 1.遍历找到插入的位置
    // 初始化两个指针, 一个用于找到插入位置, 一个用于指向它的父结点
    TreeNode* parent = NULL;
    TreeNode* curr = tree-> root;
    int diff;   // while 循环一定执行, 不用担心 diff 未初始化
    while (curr != NULL) &#123;  // 此遍历就是为了查找 NULL, curr 最终等于 NULL 说明查找到了插入位置
        diff = key - curr-> key;
        if (diff > 0) &#123;
            // 待插入结点的 key 大于当前结点 key
            // 向右遍历查找
            parent = curr;
            curr = curr-> right;
        &#125;
        else if (diff < 0)
        &#123;
            // 待插入结点的 key 小于当前结点 key
            // 向左遍历查找
            parent = curr;
            curr = curr-> left;
        &#125;
        else
        &#123;
            // 待插入结点的 key 等于当前结点 key
            // key 重复, 插入失败
            return false;
        &#125;
    &#125;   // 循环结束, 说明 curr 是 NULL, 即 key 不重复, 找到了插入的位置, parent 指针指向待插入位置的父结点
    // 2.新建一个结点, 初始化结点
    // 重要建议: 在二叉搜索树中新建结点, 请一律使用 calloc, 安全第一!
    TreeNode* new_node = calloc(1, sizeof(TreeNode));
    if (new_node == NULL) &#123;
        printf("calloc failed in bst_insert.\n");
        exit(1);
    &#125;
    new_node-> key = key;
    // 3.将新结点链接到二叉树上(链表的尾插)
    if (parent == NULL) &#123;
        // 说明此时树是一个空树
        tree-> root = new_node;  // 新结点成为根结点
        return true;    // 插入成功
    &#125;
    // 插入的结点不是第一个结点
    if (diff < 0) &#123;
        // 插入左子树
        parent-> left = new_node;
    &#125;
    else &#123;
        // 插入右子树
        parent-> right = new_node;
    &#125;
    return true;
&#125;
TreeNode * bst_search(BST* tree, KeyType key)
&#123;
    TreeNode* curr = tree-> root;
    while (curr != NULL) &#123;
        if (curr-> key == key)
        &#123;
            return curr;
        &#125;
        else  if (curr-> key > key)
        &#123;
            curr = curr-> left;
        &#125;
        else
        &#123;
            curr = curr-> right;
        &#125;
    &#125;
    return NULL;
&#125;
// 根据 key 删除一个结点
bool bst_delete(BST* tree, KeyType key) &#123;
    // 1.利用 curr 和 parent 两个指针找到待删除结点以及它的父节点
    TreeNode* curr = tree-> root;
    TreeNode* parent = NULL;
    // 2.根据 key 值的大小关系, 来遍历这棵树的结点
    while (curr != NULL) &#123;  // 这一点模拟了单链表的遍历, 因为搜索路径就是一条单链表
        int diff = key - curr-> key;
        if (diff > 0) &#123;
            // 待删除 key 值比当前结点 key 值要大, 于是去右子树中遍历查找
            parent = curr;
            curr = curr-> right;
        &#125;
        else if (diff < 0) &#123;
            // 待删除 key 值比当前结点 key 值要小, 于是去左子树中遍历查找
            parent = curr;
            curr = curr-> left;
        &#125;
        else &#123;
            // 找到待删除结点, 下面就开始删除该结点的操作
            break;
        &#125;
    &#125;
    /*
        while 循环结束, 有两种可能性:
        1.找到了目标 key 结点, 依赖 break 结束循环
            此时 curr 指针指向待删除结点, parent 指向它的父结点
        2.没找到目标 key 结点, 依赖 curr 变成 NULL 结束循环
            此时 curr 指针是 NULL 相当于找到了这个不存在 key 结点的插入位置
            而 parent 就指向插入位置的父结点
        以上两种情况, 如果是第一种情况, 我们就继续删除
        但如果是第二种情况, 目标结点不存在, 删除就失败了
    */
    if (curr == NULL) &#123;
        return false;
    &#125;
    // 2.根据度不同来进行不同的处理, 使得待删除结点从树结构中断开
    // 2.1 判断结点的度是否为 2, 如果度为 2, 进行降级处理
    if (curr-> left != NULL && curr-> right != NULL) &#123;
        // 删除的结点是度为 2 的, 于是将它降低为删除度为 0 或 1
        TreeNode* min_node = curr-> right;   // 寻找待删除结点的右子树最小结点, 从 curr 的右子树结点开始
        TreeNode* min_parent = curr;    // 寻找待删除结点的右子树最小结点的父结点
        while (min_node-> left != NULL) &#123;
            min_parent = min_node;
            min_node = min_node-> left;
        &#125;   // while 循环结束时, min_node 指向右子树最小结点, min_parent 指向 min_node 结点的父结点
        // 将右子树最小结点的值替换给 curr 结点, 并且后续将删除右子树最小结点
        curr-> key = min_node-> key;
        // 后续的删除操作都是基于 curr 指针和 parent 指针的, 所以这里要进行一步赋值操作
        curr = min_node;
        parent = min_parent;
    &#125;
    // 接下来待删除的结点就是 curr 结点, 它的父结点就是 parent, 而且这个结点的度一定是 0 或 1
    // 2.2 统一处理度为 0 或 1 结点的删除操作
    // 核心操作: parent -> left/right = curr -> left/right
    // 先确定 parent 指向待删除结点的左子树还是右子树
    TreeNode* child = (curr-> left != NULL) ? curr-> left : curr-> right;
    /*
        考虑特殊情况:
        删除的结点是度为 0 或 1 的根结点
        此时需要更新根结点指针
    */
    if (parent == NULL) &#123;
        // 删除的结点是根结点, 此根结点度为 0 或 1
        tree-> root = child;
    &#125;
    else &#123;
        // 删除的结点不是根结点
        // 执行核心操作: parent -> left/right = child;
        if (parent-> left == curr) &#123;
            // 待删除结点是父结点的左子树, 那么就让父结点的左子树指向 child
            parent-> left = child;
        &#125;
        else &#123;
            // 待删除结点是父结点的右子树, 那么就让父结点的右子树指向 child
            parent-> right = child;
        &#125;
    &#125;
    // 3.free 这个结点
    free(curr); // 删除成功
    return true;
&#125;
/*
  利用递归实现 BST 的先序遍历
  root 参数表示此一轮递归调用中的根结点
  先序遍历是: DLR
  分解的思路是:
  对于任何一棵树 root 来说:
  1.总是先输出根结点的值
  2.然后递归遍历它的左子树
  3.最后递归遍历它的右子树
  preoder(root) = D + preorder(root-> left) + preorder(root-> right)
  这就是递归体
  这样的分解不会无休止进行, 如果分解成一棵空树, 也就是 root 是空指针时, 返回函数
  这就是递归的出口
*/
static void preorder(TreeNode* root) &#123;
    if (root == NULL)
    &#123;
        return;
    &#125;
    printf("%d ", root-> key);
    preorder(root-> left);
    preorder(root-> right);
&#125;
// 深度优先-先序遍历
void bst_preorder(BST* tree)
&#123;
    if (tree == NULL) &#123;
        // 树为空直接返回
        return;
    &#125;
    // 利用辅助函数递归实现 BST 的先序遍历
    preorder(tree-> root);
    printf("\n");
&#125;
/*
  利用递归实现 BST 的中序遍历
  root 参数表示此一轮递归调用中的根结点
  中序遍历是: LDR
  分解的思路是:
  对于任何一棵树 root 来说:
  1.总是先递归遍历它的左子树
  1.然后再输出根结点的值
  3.最后递归遍历它的右子树
  inorder(root) = inorder(root-> left) + D + inorder(root-> right)
  这就是递归体
  这样的分解不会无休止进行, 如果分解成一棵空树, 也就是 root 是空指针时, 返回函数
  这就是递归的出口
*/
static void inorder(TreeNode* root) &#123;
    if (root == NULL)
    &#123;
        return;
    &#125;
    inorder(root-> left);
    printf("%d ", root-> key);
    inorder(root-> right);
&#125;
// 深度优先-中序遍历
void bst_inorder(BST* tree)
&#123;
    if (tree == NULL) &#123;
        // 树为空直接返回
        return;
    &#125;
    // 利用辅助函数递归实现 BST 的中序遍历
    inorder(tree-> root);
    printf("\n");
&#125;
/*
  利用递归实现 BST 的后序遍历
  root 参数表示此一轮递归调用中的根结点
  中序遍历是: LRD
  分解的思路是:
  对于任何一棵树 root 来说:
  1.总是先递归遍历它的左子树
  3.然后递归遍历它的右子树
  3.最后再输出根结点的值
  postorder(root) = postorder(root-> left) + postorder(root-> right) + D
  这就是递归体
  这样的分解不会无休止进行, 如果分解成一棵空树, 也就是 root 是空指针时, 返回函数
  这就是递归的出口
*/
static void postorder(TreeNode* root) &#123;
    // 1.递归的出口
    if (root == NULL) &#123;
        return;
    &#125;
    // 2.递归体
    postorder(root-> left);
    postorder(root-> right);
    printf("%d ", root-> key);
&#125;
void bst_postorder(BST* tree) &#123;
    if (tree == NULL) &#123;
        // 树为空直接返回
        return;
    &#125;
    // 利用辅助函数递归实现 BST 的后序遍历
    postorder(tree-> root);
    printf("\n");
&#125;
static void destroy(TreeNode* root) &#123;
    // 1.递归的出口
    if (root == NULL) &#123;
        return;
    &#125;
    // 2.递归体
    destroy(root-> left);
    destroy(root-> right);
    free(root);
&#125;
void bst_destroy(BST* tree)
&#123;
    if (tree == NULL) &#123;
        // 树为空直接返回
        return;
    &#125;
    // 利用辅助函数递归实现 BST 的销毁
    destroy(tree-> root);
    free(tree);
&#125;
void bst_levelorder(BST* tree) &#123;
    LinkedListQueue* q = create_queue();
    enqueue(q, tree-> root);
    while (! is_empty(q)) &#123;
        int level_size = q-> size;
        for (int i = 0; i < level_size; i++)
        &#123;
            TreeNode* node = dequeue(q);
            printf("%d ", node-> key);
            if (node-> left != NULL)
            &#123;
                enqueue(q, node-> left);
            &#125;
            if (node-> right != NULL)
            &#123;
                enqueue(q, node-> right);
            &#125;
        &#125;
        printf("\n");
    &#125;
    destroy_queue(q); // 完成遍历后，销毁队列释放资源
    printf("\n");
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> list_queue.h </font>
</summary>
<pre> <code class="language-c">#ifndef LIST_QUEUE_H
#define LIST_QUEUE_H
#include &lt; stdbool.h&gt;
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include "bst.h"
// 定义队列中的元素类型
typedef TreeNode* ElementType;
// 队列节点的结构
typedef struct node_s &#123;
    ElementType data;
    struct node_s* next;
&#125; QueueNode;
// 队列的结构
typedef struct &#123;
    QueueNode* front;  // 队头结点指针
    QueueNode* rear;   // 队尾结点指针
    int size;   // 队列中元素的个数
&#125; LinkedListQueue;
// 函数声明
// 创建链式队列
LinkedListQueue* create_queue();
// 销毁链式队列
void destroy_queue(LinkedListQueue* q);
// 入队列
bool enqueue(LinkedListQueue* q, ElementType element);
// 出队列并返回队头元素
ElementType dequeue(LinkedListQueue* q);
// 访问队头元素
ElementType peek_queue(LinkedListQueue* q);
// 判空
bool is_empty(LinkedListQueue* q);
#endif // ! LIST_QUEUE_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> list_queue.c </font>
</summary>
<pre> <code class="language-c">#include "list_queue.h"
// 函数声明
LinkedListQueue* create_queue() &#123;
    return calloc(1, sizeof(LinkedListQueue));
&#125;
void destroy_queue(LinkedListQueue* q) &#123;
    // 从队头开始遍历链表，销毁每一个结点
    QueueNode* current = q-> front;
    while (current != NULL) &#123;
        QueueNode* temp = current-> next;
        free(current);
        current = temp;
    &#125;
    // 销毁队列结构体
    free(q);
&#125;
bool is_empty(LinkedListQueue* q) &#123;
    // 队头指针是空指针，即表示空队列
    return q-> front == NULL;
&#125;
// 入队操作: 只能在队尾插入一个结点
// 由于已存在尾指针，所以这里的操作就是链表尾插
bool enqueue(LinkedListQueue* q, ElementType element) &#123;
    QueueNode* new_node = malloc(sizeof(QueueNode));
    if (new_node == NULL) &#123;
        printf("Error: malloc failed in enqueue.\n");
        return false;
    &#125;
    // 初始化新结点
    new_node-> data = element;
    new_node-> next = NULL;
    // 开始进行尾插法插入一个结点
    // 分两种情况：如果尾插插入的是第一个结点需要同步更新头指针，否则仅需要更新尾指针
    if (q-> front == NULL) &#123;
        // 插入的是第一个结点
        q-> front = new_node;
        q-> rear = new_node;
    &#125;
    else &#123;
        // 插入的不是第一个结点
        q-> rear-> next = new_node;
        q-> rear = new_node;
    &#125;
    q-> size++;
    return true;
&#125;
// 出队，在队头删除一个结点。也就是在删除链表的第一个结点
ElementType dequeue(LinkedListQueue* q) &#123;
    if (is_empty(q)) &#123;
        printf("Error: queue is empty.\n");
        exit(1);
    &#125;
    QueueNode* tmp = q-> front;
    // 将出队的结点数据保存
    ElementType remove_data = tmp-> data;
    // 更新队头指针
    q-> front = tmp-> next;
    if (q-> front == NULL) &#123;
        // 如果队头更新后, 队列为空, 说明出队的就是最后一个元素
        // 于是同步更新队尾指针
        q-> rear = NULL;
    &#125;
    free(tmp);
    q-> size--;
    return remove_data;
&#125;
// 访问队头元素但不出队
ElementType peek_queue(LinkedListQueue* q) &#123;
    if (is_empty(q)) &#123;
        printf("Error: queue is empty.\n");
        exit(1);
    &#125;
    return q-> front-> data;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include "bst.h"
int main(void) &#123;
    // 创建二叉搜索树
    BST* tree = bst_create();
    if (! tree) &#123;
        printf("二叉搜索树创建失败。\n");
        return 1;
    &#125;
    // 插入元素
    int elements [] = &#123; 50, 30, 70, 20, 40, 60, 80, 30 &#125;; // 包含重复元素 30
    printf("正在插入元素: ");
    int arr_len = sizeof(elements) / sizeof(elements [0]);
    for (int i = 0; i < arr_len; i++) &#123;
        if (bst_insert(tree, elements [i])) &#123;
            printf("%d ", elements [i]); // 打印成功插入的元素
        &#125;
        else &#123;
            printf("(重复 %d) ", elements [i]); // 打印重复元素的信息
        &#125;
    &#125;
    printf("\n");
    // 预期结果：重复的元素不应该被插入到树中。
    // 中序遍历，应该输出有序序列
    printf("中序遍历输出(预期有序): ");
    bst_inorder(tree);
    printf("\n");
    // 预期结果：20, 30, 40, 50, 60, 70, 80
    // 先序遍历输出 预期结果：50 30 20 40 70 60 80
    printf("先序遍历输出: ");
    bst_preorder(tree);
    printf("\n");
    // 后序遍历输出 预期结果：20 40 30 60 80 70 50
    printf("后序遍历输出: ");
    bst_postorder(tree);
    printf("\n");
    // 层次遍历输出 预期结果：50 30 70 20 40 60 80
    printf("层次遍历输出: ");
    bst_levelorder(tree);
    printf("\n");
    // 测试搜索存在和不存在的情况 预期结果：找到了
    int searchKey = 40;
    printf("搜索键 %d 的结果: %s\n", searchKey, bst_search(tree, searchKey) ? "找到了" : "未找到");
    // 预期结果：未找到
    searchKey = 100;
    printf("搜索键 %d 的结果: %s\n", searchKey, bst_search(tree, searchKey) ? "找到了" : "未找到");
    // 测试删除操作
    printf("删除元素 70 和 20\n");
    bst_delete(tree, 70);
    bst_delete(tree, 20);
    // 再次进行中序遍历验证删除操作 // 预期结果：30, 40, 50, 60, 80
    printf("删除元素后中序遍历输出: ");
    bst_inorder(tree);
    printf("\n");
    // 销毁二叉搜索树
    bst_destroy(tree);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/lang_c/c_dynamic_memory_allocation_tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lang_c/c_dynamic_memory_allocation_tree/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-28 15:57:57" itemprop="dateCreated datePublished" datetime="2024-08-28T15:57:57+08:00">2024-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-06 15:36:34" itemprop="dateModified" datetime="2024-09-06T15:36:34+08:00">2024-09-06</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="c语言之动态内存分配与释放">C语言之动态内存分配与释放</h1>
<h2 id="通用指针类型void">通用指针类型void</h2>
<p>通用类型指针具有以下特点：</p>
<p><strong>类型无关，赋值灵活：</strong>由于指针本质上是一个存储内存地址的变量，而内存地址是没有类型的，所以void指针可以存储任意类型数据的地址，指向任意类型对象。无论是整数、浮点数、字符或数组、结构体等类型都可以用void指针指向。表现在代码中就是：<strong>可以将任意类型指针(地址)赋值给void指针，这个过程一般是没有风险的。</strong>如下列代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">void</span>* void_ptr = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void指针转换成其它类型指针,在C++语法中必须加上显式类型转换说明</span></span><br><span class="line"><span class="comment">// 但C语言支持void指针隐式类型转换成各种其它指针类型，所以这个强转语法可加可不加</span></span><br><span class="line"><span class="comment">// float* float_ptr = (float*)void_ptr;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的类型转换</span></span><br><span class="line"><span class="type">float</span>* float_ptr = void_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用产生未定义行为</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, *float_ptr);</span><br></pre></td></tr></table></figure>
<p>关于通用指针类型转换成其它指针类型，C语言和C++在语法上会有明显差别：</p>
<ul>
<li><p>C语言更灵活允许隐式的类型转换，所以强转语法可加可不加。</p></li>
<li><p>C++则不支持这类隐式类型转换，必须要加上强转的语法，否则编译无法通过。</p></li>
</ul>
<hr />
<p>在C语言中，想要在堆上动态分配内存空间，主要依赖三个函数来完成，它们都声明在<strong>头文件&lt;stdlib.h&gt;</strong>当中：</p>
<ol type="1">
<li>malloc</li>
<li>calloc</li>
<li>realloc</li>
</ol>
<hr />
<h2 id="内存分配函数malloc">内存分配函数malloc</h2>
<p><strong>函数全名：</strong>memory allocation</p>
<p><strong>函数声明：</strong><code>void* malloc(size_t size);</code></p>
<p>函数作用：</p>
<ul>
<li><p><strong>此函数会在堆空间上分配一片连续的，size个字节大小的内存块</strong></p></li>
<li><p><strong>此函数不会对内存块中的数据进行初始化，内存块中的数据是随机未定义的。</strong></p></li>
</ul>
<p><strong>函数返回值：</strong></p>
<ul>
<li><p>如果分配成功，此函数会返回指向该<strong>内存块地址(首字节地址)</strong>的指针。<strong>注意返回的指针类型是void指针，在操作之前需要进行转换。</strong></p></li>
<li><p>如果分配失败，此函数会返回一个空指针(NULL)。</p></li>
</ul>
<h3 id="内存泄漏">内存泄漏</h3>
<p>以往我们创建数组，创建结构体都是在栈上完成的，它们是栈数组、栈结构体，它们的内存空间都是由栈自动管理完成的。</p>
<p>但使用动态内存分配函数创建的数组、结构体都被存储在堆上，栈上存储的只不过是它的指针，如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311091105358.png" alt="栈上指针指向堆上内存区域-示意图" style="zoom: 33%;" />
</div>
<p>堆上存储的数据由程序员手动管理生命周期，手动申请内存资源，也需要手动释放内存空间。</p>
<p><strong>内存泄漏是指程序在运行过程中，未能适时释放不再使用的内存区域，导致这部分内存在程序的生命周期内始终无法被重用。</strong></p>
<p>内存泄漏在短时间内可能对程序而言，不是巨大的、致命的风险，但：长时间运行或频繁执行的程序中如果存在内存泄漏，随着时间的推移，被泄漏的内存累积会越来越多，最终可能导致程序运行缓慢甚至崩溃，特别是在内存有限的系统中。</p>
<h2 id="内存释放函数free">内存释放函数free</h2>
<p>为了避免内存泄漏，在确定动态分配的内存不再使用后，要及时调用free函数释放它。</p>
<p><strong>函数声明：</strong><code>void free(void *ptr);</code></p>
<p><strong>函数参数：</strong>必须是堆上申请内存块的地址(<strong>首字节地址</strong>)，不能传递别的指针，否则会引发未定义行为。</p>
<p><strong>函数功能：</strong></p>
<ol type="1">
<li><strong>free函数并不会修改它所释放的内存区域中存储的任何数据。</strong>free
的作用仅仅是告诉操作系统这块内存不再被使用了，可以将其标记为可用状态，以供将来的内存分配请求使用。</li>
<li>释放后的内存区域中的数据一般仍然会继续存在，直到被下一次的内存分配操作覆盖。当然即便free前的原始数据一直存在未被覆盖，这片内存区域也不再可用了，因为你不知道什么时候数据就会被覆盖掉了。</li>
<li><strong>free函数不会修改传入指针指向的内容，更不会对实参指针本身做任何修改。</strong></li>
</ol>
<p>free函数调用后，指针指向的内存块就被释放了。但<strong>free函数不会改变传入的实参指针本身</strong>，所以free后的实参指针就变成了指向一片已释放区域的指针。这就是<strong>“悬空指针”</strong>，悬空指针是野指针的一种特例，使用悬空指针同样会引发未定义行为。</p>
<p><strong>为了避免悬空指针为程序安全带来隐患，推荐在free掉指针指向的内存块后，及时将指针置为空指针。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码,p是一个指针类型</span></span><br><span class="line">p = <span class="built_in">malloc</span>(...);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ol type="1">
<li><p><strong>正确传参free函数。</strong>free函数需要传入指向动态分配内存块首字节的指针，free之前不妨检查指针是否已被移动。</p></li>
<li><p><strong>在free内存块后，建议立刻将指针设置为NULL。</strong>这样可以规避一些常见的问题：</p>
<ul>
<li><p>避免了”double
free”的风险。对空指针调用<code>free函数</code>是安全的，它不会有任何效果。</p></li>
<li><p>减少悬空指针出现的风险。解引用空指针导致程序崩溃，比悬空指针带来的未定义行为要更容易检测和修正。</p></li>
</ul></li>
<li><p><strong>慎重改变堆区指针的指向。</strong>指向堆区域的指针，如果需要改变它的指向，在改变之前应当考虑指向的内存块是否需要free。</p></li>
<li><p><strong>多函数共同管理同一块内存区域时，应严格遵循单一原则。</strong>尤其是，哪个函数用于分配内存，哪个函数用于free释放内存，这两个函数一定要明确单一的职责。</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆上动态分配内存拼接两个字符串</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">dynamic_strcat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* prefix, <span class="type">const</span> <span class="type">char</span>* suffix)</span> &#123;</span><br><span class="line"><span class="comment">// 计算拼接后字符串的长度</span></span><br><span class="line"> <span class="type">int</span> new_str_len = <span class="built_in">strlen</span>(prefix) + <span class="built_in">strlen</span>(suffix);</span><br><span class="line"><span class="type">char</span> *new_str = <span class="built_in">malloc</span>(new_str_len + <span class="number">1</span>);    <span class="comment">// char在各平台上长度都是1，所以不用乘了</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (new_str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;ERROR: malloc failed in dynamic_strcat!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 长度是精确计算得出的，不用担心越界访问</span></span><br><span class="line"> <span class="built_in">strcat</span>(<span class="built_in">strcpy</span>(new_str, prefix), suffix);</span><br><span class="line"><span class="keyword">return</span> new_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="type">char</span> str1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot; world!&quot;</span>;</span><br><span class="line"> <span class="type">char</span>* result_str = dynamic_strcat(str1, str2);  <span class="comment">// 注意只要涉及动态内存分配，一律用指针类型。这里不能用数组类型</span></span><br><span class="line"><span class="built_in">puts</span>(result_str);</span><br><span class="line"> <span class="comment">// 现在不再使用result字符串了，不要忘记free它</span></span><br><span class="line"><span class="built_in">free</span>(result_str);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="清零内存分配函数calloc">清零内存分配函数calloc</h2>
<p><strong>函数全名：</strong>cleared
allocation，该函数的最大特点是分配内存空间时会<strong>自动初始化0值</strong>。</p>
<p><strong>函数声明：</strong>
<code>void* calloc(size_t num, size_t size);</code>。</p>
<p><strong>函数参数：</strong></p>
<ol type="1">
<li><code>num</code> 表示要分配的元素数量</li>
<li><code>size</code> 表示每个元素的内存大小</li>
</ol>
<p>此函数也会在堆空间上分配一片连续的内存空间，但不同的是，它基于元素的个数以及每个元素的大小来进行内存分配，所以calloc常用于在堆上分配<strong>数组</strong>的内存空间。</p>
<p><strong>函数返回值：</strong>返回值在分配成功和失败时，和malloc是一致的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 分配一个长度为10的整数数组</span></span><br><span class="line"> <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> *arr = <span class="built_in">calloc</span>(len, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span>* p = arr;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++);   <span class="comment">// 此时数组中的元素都具有0值，而不是随机未定义的</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用完毕，不要忘记free</span></span><br><span class="line"> <span class="built_in">free</span>(arr);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总得来说，推荐在<strong>动态分配数组内存空间</strong>时，尤其是需要将内存空间初始化为0值时，<strong>使用calloc函数</strong>。</p>
<h2 id="内存重分配函数realloc">内存重分配函数realloc</h2>
<p><strong>函数全名：</strong>reallocation，表示内存重新分配。</p>
<p><strong>函数声明：</strong><code>void* realloc(void* ptr, size_t new_size);</code></p>
<p><strong>函数参数：</strong></p>
<ol type="1">
<li><code>ptr</code>：指向原来已分配内存的内存块。</li>
<li><code>new_size</code>：新的内存块大小。</li>
</ol>
<p><strong>函数功能：</strong></p>
<p>该函数根据参数取值的不同，可能表现为malloc或free函数的行为：</p>
<ol type="1">
<li><strong>如果ptr指针是一个空指针，那么该函数的行为和malloc一致——分配new_size字节的内存空间，并且返回该内存块的指针。</strong></li>
<li><strong>如果new_size的取值为0，那么该函数的行为就是free函数，会释放ptr指向的内存块。</strong></li>
</ol>
<p>如果没有出现上述两种特殊情况，realloc用于重新调整已分配内存块的大小(也就是ptr指针指向的已分配内存块的大小)：</p>
<ol type="1">
<li>当new_size的取值和已分配的内存块大小一致时，此函数不会做任何操作。</li>
<li>当new_size的取值比已分配的内存块小时，会在旧内存块的<strong>尾部(高地址)</strong>截断，被截断抛弃的内存块会被自动释放。</li>
<li>当new_size的取值比已分配的内存块大时(新内存块比旧内存块大时)，会尽可能地尝试原地扩大旧内存块(这样效率高)；</li>
<li>如果无法原地进行扩大，则会在<strong>别处</strong>申请空间分配new_size大小的新内存块，并将旧内存块中的数据全部复制进去后，将<strong>旧内存块自动释放</strong>。</li>
<li>不管采用哪种方式扩展旧内存块，<strong>新扩展部分</strong>的内存区域都不会初始化，仍只<strong>具有随机值</strong>。</li>
</ol>
<p><strong>函数返回值：</strong></p>
<p>如果realloc函数分配内存空间成功，它会返回指向新内存块的指针，<strong>若失败，仍会返回空指针，且不会改变旧内存块。</strong></p>
<p>总之，realloc函数适用于调整已分配内存块的大小，特别是在<strong>动态数组或数据结构的大小需要在程序运行时增加或减少时</strong>使用。</p>
<p><strong>惯用法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p和arr_p指针类型一致</span></span><br><span class="line">p = <span class="built_in">realloc</span>(arr_p, new_size);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">   <span class="comment">// 分配失败处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码运行到这里,realloc分配内存成功</span></span><br><span class="line">arr_p = p;</span><br></pre></td></tr></table></figure>
<p>这样写既避免了arr_p成为悬空指针，也不会因为realloc分配失败导致内存泄漏。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/lang_c/sort_algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/lang_c/sort_algorithm/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-07 11:16:51" itemprop="dateCreated datePublished" datetime="2024-08-07T11:16:51+08:00">2024-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-14 16:31:34" itemprop="dateModified" datetime="2024-10-14T16:31:34+08:00">2024-10-14</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>50 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="排序算法">排序算法</h1>
<p>排序算法，就是将一个无序数组内的全部元素，按照递增或递减的顺序重新排列起来的程序实现方法。在结构体中，还有针对结构体数组排序的排序算法。对于多种属性数据对象集合，按照其中的某一个或某一些属性的大小进行排序。例如：对一个公司的员工信息排序时，可以分别按工号、姓名或年龄等属性进行排序。</p>
<p>基础排序算法包括冒泡排序、选择排序和插入排序三种，高级排序包括快速排序、归并排序、堆排序和希尔排序等等。七种常见的、经典的基于”比较”的排序算法：</p>
<ol type="1">
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>堆排序</li>
</ol>
<p>这些排序算法各有各的特点、适用场景，没有一种算法总是最优解。但相对而言比较重要、更常用的是：快速排序、归并排序、堆排序以及插入排序。</p>
<p><strong>如何评估一个排序算法？</strong></p>
<p>从三个维度去分析一个排序算法：<strong>时间复杂度、空间复杂度和稳定性。</strong></p>
<p>下面这张图展示了算法随着数据规模的增大，指令数量和额外内存空间占用，在不同级别下的增加趋势：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202401151901805.png" alt="不同级别大O表示法的增加趋势-图" style="zoom: 50%;" />
</div>
<p>其中，常数级别O(1)和对数级别O(log
n)被认为是特别优秀的，稳定且高效。</p>
<p>而从O(n2)开始，就表示算法随着数据规模的增大而迅速变得低效，在实际应用中要尽量避免选择这样的算法去进行大数据集的处理。</p>
<h2 id="冒泡排序">冒泡排序</h2>
<h3 id="算法思想">算法思想</h3>
<ol type="1">
<li><strong>第一轮冒泡排序：</strong>从数组的第一个元素开始，比较相邻的元素。如果第一个元素比第二个元素大，则交换它们的位置。然后，移动到下一对相邻元素，重复这个过程，直到比较最后一对元素。每一轮冒泡排序都会使当前比较序列的最大值到达数组末尾，随后第二轮排序过程中，需要比较的元素就减1。(将尾部最大的元素减去不再排序)</li>
<li><strong>第二轮冒泡排序：</strong>重复第一轮的过程，但这次只比较和交换直到倒数第二个元素（因为最后一个元素已经是最大的了）。在这一轮结束时，倒数第二大的元素会被“冒泡”到倒数第二的位置。</li>
<li>…</li>
<li><strong>结束条件：</strong>
<ol type="1">
<li>在不设置任何额外结束条件的前提下，冒泡排序每一轮都会将未排序序列的最大值”冒泡”到末尾。冒泡排序需要进行固定的(n
- 1)轮！</li>
<li>但实际上在这(n -
1)轮冒泡排序的过程中，只要某一轮完全不存在元素的交换，就说明数组已经完全有序了，排序就可以结束了。</li>
<li>所以我们可以设定一个布尔值来标记此轮冒泡排序是否存在元素交换，如果没有元素交换，直接结束整个排序。这种做法可以优化冒泡排序的性能，尤其是当原数组已基本有序时。</li>
</ol></li>
</ol>
<h3 id="代码实现">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">冒泡排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j ) &#123;      \
    int tmp = arr[i];           \
    arr[i] = arr[j];            \
    arr[j] = tmp;               \
&#125;
void print_arr(int arr[], int len) &#123;
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 冒泡排序
void bubble_sort(int arr[], int len) &#123;
    for (size_t i = 0; i < len-1; i++)
    &#123;
        // 标记在这一次冒泡排序中有没有交换,false表示没有交换
        bool swapped = false;
        for (size_t j = 0; j < len - i- 1; j++) &#123;
            if (arr[j]>arr[j+1])
            &#123;
                SWAP(arr, j, j+1);
                // 发生了交换改变标记
                swapped = true;
            &#125;
        &#125;
        // 在一轮冒泡排序中没有任何交换,则排序已经完成,终止循环
        if (!swapped) &#123;
            break;
        &#125;
        // 打印一轮冒泡排序后数组的元素排列
        print_arr(arr, len);
    &#125;
&#125;
int main(void) &#123;
    // 测试冒泡排序
    int arr[] = &#123; 1,10,2,5,3,4,5,6,3,2 &#125;;
    int len = ARR_LEN(arr);
    bubble_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析">性能分析</h3>
<p><strong>时间复杂度分析：</strong></p>
<p>最佳情况：由于使用了”swapped”标记，所以在最佳情况下，即输入的数组已经是有序的情况下，算法仅需要一次数组遍历就可以确定排序完成。</p>
<p>即：</p>
<p>比较次数： (n - 1)</p>
<p>交换次数： 0</p>
<p><strong>所以最佳情况下的时间复杂度是 O(n)。</strong></p>
<p>最坏情况：</p>
<p>在最坏的情况下（当数组完全逆序时），冒泡排序第一轮需要执行( n - 1)
次比较和交换，第二次执行( n - 2 )次，依此类推，直到最后一次执行 1
次。所以，总的执行次数是等差数列求和：n * ( n - 1) /
2。所以<strong>最坏情况下的时间复杂度是<span
class="math inline">\(O(n^2)\)</span> 。</strong></p>
<p>平均情况：<strong>在平均情况下，时间复杂度也是<span
class="math inline">\(O(n^2)\)</span>
。</strong>虽然不是所有的元素都需要交换，但总体而言，性能接近最坏情况。</p>
<p><strong>空间复杂度分析：</strong></p>
<p>冒泡排序是一种原地排序算法，不需要占用额外内存空间。空间复杂度是O(1)</p>
<p><strong>稳定性分析：</strong></p>
<p>冒泡排序显然是一种稳定的排序算法，因为交换的过程中不会交换任何两个相同的元素。</p>
<h2 id="选择排序">选择排序</h2>
<h3 id="算法思想-1">算法思想</h3>
<p>①先假设第一个数是最小的,然后拿这个数去和后面的n个数依次进行比较,
②如果发现有比最小值还小的数 则通过中间变量记录下下标和值,
③然后继续拿这个最小值往后进行比较,如果又发现比最小值还小的值
就执行第②步,直到比完最后一个元素
④最后把存在中间变量的最小值和最小值的下标 和假设的那个最小值进行交换</p>
<h3 id="代码实现-1">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">选择排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j ) &#123;      \
    int tmp = arr[i];           \
    arr[i] = arr[j];            \
    arr[j] = tmp;               \
&#125;
void print_arr(int arr[], int len) &#123;
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 选择排序
void selection_sort(int arr[], int len) &#123;
    /*
    * i表示未排序序列的开头元素
    * 最后一轮选择排序时, 未排序序列的开头元素是数组倒数第二个元素
    * i的每个取值都表示一轮选择排序
    * 也就是选择排序一共执行9趟
    */
    for (int i = 0; i < len - 1; i++) &#123;
        // 不妨直接假设未排序序列的开头i位置元素就是最小值
        int min_index = i;
        // 遍历未排序数组序列,找出真正的最小值下标,此时应遍历最后一个元素
        for (int j = i + 1; j < len; j++) &#123;
            if (arr[j] < arr[min_index]) &#123;
                min_index = j;  // 记录较小值的下标
            &#125;
        &#125;   // for循环结束时，未排序序列的最小值下标就是min_index
        // 交换min_index和下标i的元素
        SWAP(arr, min_index, i);
        // 选择排序一趟打印一次数组
        print_arr(arr, len);
    &#125;
&#125;
int main(void) &#123;
    // 测试选择排序
    int arr[] = &#123; 1,10,2,5,3,4,5,6,3,2 &#125;;
    int len = ARR_LEN(arr);
    selection_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-1">性能分析</h3>
<p><strong>时间复杂度分析：</strong></p>
<p>在分析以比较为核心的排序算法的时间复杂度时，重点关注两点：</p>
<ol type="1">
<li>比较次数</li>
<li>交换元素次数</li>
</ol>
<p>在选择排序当中，无论什么情况下，比较次数和交换元素次数都是一样的：</p>
<ol type="1">
<li>比较次数：</li>
<li>每一轮的比较次数会随着未排序序列减少递减</li>
<li>即一共比较(n - 1) + (n - 2) + … + 1 = n * (n - 1) / 2
次（等差数列求和）</li>
<li>交换元素次数：数组一共有n个元素，除了末尾元素不需要交换，其它元素都需要交换，固定交换(n
- 1)次。</li>
</ol>
<p>将两者加起来就是总的指令执行数量。</p>
<p>除此之外，我们发现选择排序，在数组已经有序、逆序还是完全无序的各种情况下，这些比较和交换都不会减少。</p>
<p>所以用大O表示法，<strong>选择排序的时间复杂度是<span
class="math inline">\(O(n^2)\)</span>，任何情况下都一样。</strong></p>
<p><strong>空间复杂度分析：</strong></p>
<p>选择排序是一种原地排序算法，不需要占用额外内存空间。空间复杂度是O(1)</p>
<p><strong>稳定性分析：</strong></p>
<p>选择排序稳定吗？答：不稳定！</p>
<p>选择排序在每轮中选择最小元素，并与未排序部分的第一个元素交换。如果存在相等的元素，选择排序可能会改变它们的相对顺序。所以选择排序不是稳定的排序算法。</p>
<p>这样的例子随手可举，比如对于一个数组：</p>
<blockquote>
<p>[3, 5, 3’, 2, 8]</p>
</blockquote>
<p>两个3是相同的元素，相对位置是3在前，3’在后。在选择排序后，得出结果是：</p>
<blockquote>
<p>[2, 3’, 3 , 5, 8]</p>
</blockquote>
<p>变成3’在前，3在后。</p>
<h2 id="插入排序">插入排序</h2>
<h3 id="算法思想-2">算法思想</h3>
<ol type="1">
<li><strong>以数组的首元素为初始状态：</strong>这个初始状态相当于抓到的第一张牌，它默认就是有序的。</li>
<li><strong>从数组的第二个元素开始遍历：</strong>相当于抓一张牌，然后从小到大整理手牌。</li>
<li><strong>比较与交换：</strong>将新插入的元素和前面的元素逐一比较，如果新插入元素较小，则交换两个元素，直到完全不可交换，则完成一轮排序。</li>
<li><strong>重复步骤2和3，直到步骤2遍历到最后一个元素。</strong></li>
</ol>
<h3 id="代码实现-2">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">插入排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j ) &#123;      \
    int tmp = arr[i];           \
    arr[i] = arr[j];            \
    arr[j] = tmp;               \
&#125;
void print_arr(int arr[], int len) &#123;
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 插入排序
void insert_sort(int arr[], int len) &#123;
    for (int i = 1; i < len; i++)
    &#123;
        for (int j = i - 1; j >= 0; j--) &#123;
            if (arr[j] > arr[j + 1])
            &#123;
                SWAP(arr, j, j + 1);
            &#125;
            else
            &#123;
                break;
            &#125;
        &#125;
        // 打印一轮插入排序后数组的元素排列
        print_arr(arr, len);
    &#125;
&#125;
// 插入排序 优化: 用向后移动腾出插入位置,然后插入实现插入排序
void insertion_sort2(int arr[], int len) &#123;
    // 现在第一个元素就是第一张手牌,从第二个元素开始就是每一次要摸的牌
    // 外层for循环代表每一轮摸到的新手牌, 也就是每一轮插入排序
    for (int i = 1; i < len; i++) &#123;
        // 先记录一下新手牌的值, 便于后续的插入操作
        int tmp = arr[i];
        int j = i - 1;
        for (; j >= 0; j--) &#123;
            if (arr[j] > tmp) &#123; // 注意:不能加=,加了就不是稳定排序算法了
                arr[j + 1] = arr[j];    // 将旧手牌中大于新手牌的所有牌都向后移
            &#125;
            else
            &#123;
                break;  // 只要发现一张旧手牌更小或相等, 就说明已经找到新手牌的插入位置了
            &#125;
        &#125;
        /*
            现在还有一件事情没做:新手牌要插入,需要确定插入位置
            分析: for循环什么时候结束?
            两种情况:
            1.j=-1时,循环结束,说明新手牌是最小的,所以插入到0这个位置,也就是j+1
            2.arr[j] <= tmp 也就是旧手牌更小或相等,此时新手牌放在j+1的位置
        */
        arr[j + 1] = tmp;
        print_arr(arr, len);    // 每一轮摸牌后查看排序后的数组
    &#125;
&#125;
int main(void) &#123;
    // 测试插入排序
    int arr[] = &#123; 1,10,2,5,3,4,5,6,3,2 &#125;;
    int len = ARR_LEN(arr);
    //insert_sort(arr, len);
    insert_sort2(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-2">性能分析</h3>
<p>以版本2为选择排序的实现，假设n为数组的长度，分析以下复杂度：</p>
<p><strong>时间复杂度分析：</strong></p>
<p>最佳情况：</p>
<ol type="1">
<li>当输入的数组已经是排序好的，此时不需要移动任何元素，但比较还是需要的。</li>
<li>比较次数(外层for循环次数)：(n - 1)</li>
<li>移动次数：0</li>
</ol>
<p><strong>所以最佳情况下的时间复杂度是 O(n)。</strong></p>
<p>最坏情况：</p>
<ol type="1">
<li>在最坏的情况下，即数组完全逆序时。</li>
<li>比较和交换的次数是相同的，第一轮需要比较和移动1次，第二轮需要比较和移动2次….最后一个元素需要比较和移动
(n - 1)次</li>
<li>等比数列求和：需要比较和移动各n(n-1)/2次，加起来就是<strong><span
class="math inline">\(T(n^2- n)\)</span></strong></li>
</ol>
<p>所以<strong>最坏情况下的时间复杂度是$ O(n^2)$。</strong></p>
<p>平均情况：</p>
<ol type="1">
<li>在平均情况下，可以粗略的认为移动次数和比较次数是最坏情况除以2</li>
<li><strong>所以在平均情况下，时间复杂度也是$ O(n^2)$。</strong></li>
</ol>
<p><strong>空间复杂度分析：</strong></p>
<p>插入排序是一种原地排序算法，不需要占用额外内存空间。空间复杂度是O(1)</p>
<p><strong>稳定性分析：</strong></p>
<p>插入排序显然也是一种稳定的排序算法，因为对于两个相同的元素，我们始终都不会交换它们的相对位置。</p>
<p>注意：如果判断的条件改成<code>arr[j] &gt;= arr[j + 1]</code>，即在前后元素相等时也交换/移动元素，算法就会变成不稳定的。</p>
<h2 id="基础排序算法总结">基础排序算法总结</h2>
<p><strong>选择排序、冒泡排序和插入排序都是基础的排序算法，同样的基于比较而实现，同样的简单直观，同样的原地算法。</strong></p>
<p>这里对它们做一个总结分析：</p>
<ol type="1">
<li><strong>选择排序</strong>在任何情况下时间复杂度都是<span
class="math inline">\(O(n^2)\)</span>，且它是一个不稳定的排序算法。比起作为算法去使用，它更具有教学意义，一般不推荐去使用它。</li>
<li><strong>冒泡排序</strong>和<strong>插入排序</strong>看起来很类似，它们都有最坏和平均情况下<span
class="math inline">\(O(n^2)\)</span>的时间复杂度，都有最优情况下<span
class="math inline">\(O(n)\)</span>的时间复杂度。但<strong>在小数据集或者数据集基本有序的情况下，仍然更推荐使用插入排序。</strong></li>
</ol>
<p>这是因为：</p>
<ol type="1">
<li><strong>插入排序的移动操作比冒泡排序的交换操作效率更高。</strong>在冒泡排序中，每轮冒泡都可能涉及大量交换元素操作，而插入排序用移动操作替代了交换。从指令执行数量上来说，移动操作效率更高。</li>
<li><strong>在数据基本有序的情况下，插入排序往往表现要更好。</strong>这是因为在数据基本有序的情况下，插入排序往往只需要挪动元素很少的次数，而冒泡排序可能还需要，慢慢的一步步的两两交换多次。这里同样存在移动操作和交换操作指令数量上的差异！</li>
</ol>
<h2 id="希尔排序">希尔排序</h2>
<h3 id="算法思想-3">算法思想</h3>
<p><strong>希尔排序(Shell
Sort)</strong>是美国计算机科学家，<strong>唐纳德·希尔</strong>在1959年提出的排序算法。</p>
<p>希尔排序是插入排序的一种改进和扩展，它基于插入排序的两个特点来进行改进：</p>
<ol type="1">
<li>插入排序的缺点就是当较小元素处于末尾时，需要移动元素的次数过多，希尔排序通过比较和交换不相邻的元素来改进插入排序，可以一次性将后面的小元素向前面移动多个位置，从而提高效率。</li>
<li>插入排序在排序基本有序的序列时，效率很高。<strong>可以将希尔排序理解成——先通过几次分组的、较小的组间插入排序将原数组变得有序，最后再进行一次序列基本有序的完整插入排序。</strong></li>
</ol>
<p>整个希尔排序的过程，可以看成多个人轮流抓牌 –&gt; 整理手牌 –&gt;
抓牌，然后再把手牌合并变成更少的人抓牌，直到回归一个人抓牌(直到变成插入排序)。</p>
<h3 id="代码实现-3">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">希尔排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j ) &#123;      \
    int tmp = arr[i];           \
    arr[i] = arr[j];            \
    arr[j] = tmp;               \
&#125;
void print_arr(int arr[], int len) &#123;
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 希尔排序: 缩小增量排序, 其实就是多人摸牌, 逐渐减少摸牌人数
// 希尔排序中, 增量序列的设计非常重要,这里采取简单的gap序列: 长度减半..一直减半,直到为1
// gap为1时就是一个在数组元素基本有序情况下的,插入排序
void shell_sort(int arr[], int len) &#123;
    // 第一个元素是第一个人的初始手牌,一直到第gap个元素都是初始手牌
    int gap = len >> 1;
    while (gap > 0) &#123;
        // 外层for的i仍然代表新摸到的手牌的下标,i从gap开始,直到摸完整个数组元素
        for (int i = gap; i < len; i++) &#123;
            // 先记录一下新手牌的值, 便于后续的插入操作
            int tmp = arr[i];
            int j = i - gap;    // 代表每一个人旧手牌的最后一张牌
            for (; j >= 0; j -= gap) &#123;
                // 内层for代表 每个人每摸到一张新手牌,都会和原本的旧手牌比较,但由于gap存在,所以需要减去gap
                if (arr[j] > tmp) &#123; // 注意:不能加=,加了就不稳定了
                    arr[j + gap] = arr[j];  // 将旧手牌中大于新手牌的所有牌都向后移
                &#125;
                else
                &#123;
                    break;  // 只要发现一张旧手牌更小或相等, 就说明已经找到新手牌的插入位置了
                &#125;
            &#125;
            arr[j + gap] = tmp;
        &#125;
        print_arr(arr, len);    // 每一轮希尔排序后查看数组排序结果
        gap >>= 1; // 每一轮希尔排序,增量都减半
    &#125;
&#125;
int main(void) &#123;
    // 测试希尔排序
    int arr[] = &#123; 16, 1, 45, 23, 99, 2, 18, 67, 42, 10 &#125;;
    int len = ARR_LEN(arr);
    shell_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-3">性能分析</h3>
<p><strong>时间复杂度：</strong></p>
<p>希尔排序的时间复杂度，和选择的增量序列有密切的关联：</p>
<p>若使用希尔本人提出的减半序列，时间复杂度通常会小于<span
class="math inline">\(O(n^2)\)</span>，但在最坏情况也会接近<span
class="math inline">\(O(n^2)\)</span>。</p>
<p><strong>空间复杂度分析：</strong></p>
<p>希尔排序是一种原地排序算法，不需要占用额外内存空间。空间复杂度是O(1)。</p>
<p><strong>稳定性分析：</strong></p>
<p>希尔排序显然不是一种稳定的排序算法，因为它先分组再插入排序的方式，使得相同元素可能会由于分组不同改变位置。</p>
<p>比如：</p>
<p>假设我们有一个数组 [4a, 3, 4b, 2, 1]，选择的增量是3…1</p>
<p>那么第一轮希尔排序后的结果就是：[2, 1, 4b, 4a,
3]，很明显这不是稳定的排序算法。</p>
<blockquote>
<p><strong>希尔排序的地位如何？</strong></p>
<p>希尔排序的实现比起插入排序更加复杂，思路更加不直观，并且还牺牲了算法的稳定性，从而换取了一定的性能提升。</p>
<p>但总得来说，希尔排序处在一共尴尬的境地：在小数据集的情况下，插入排序的性能和希尔排序相当甚至会更优。</p>
<p>在大数据集的情况下，希尔排序的性能又不及归并、快排等高级排序算法。希尔排序更像是一个介于简单排序算法和高级排序算法之间的一个桥梁，不需要作为重点去学习。</p>
</blockquote>
<h2 id="归并排序">归并排序</h2>
<h3 id="算法思想-4">算法思想</h3>
<p>归并排序的分治策略思路大体上如下：</p>
<ol type="1">
<li>分解大问题：将一个大数组分解成两个或更多的子数组，直到每个子数组足够小，通常是直到每个子数组只包含一个元素或者是空数组。</li>
<li>解决子问题：数组小到只有一个元素或者没有元素，那自然是”有序数组”，所以这些子问题可以视为被解决了。</li>
<li>合并：归并排序的核心在于合并步骤，也可以叫”归并”操作，它会将两个有序的子数组合并成一个大的有序数组。这个过程通常需要反复比较元素，比较复杂。</li>
</ol>
<p><strong>分解过程：</strong></p>
<p>可以采用递归作为手段来实现分治的过程。首先存在一个递归分解的过程，递归的思路参考如下：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312151131058.png" alt="归并排序-递归过程" style="zoom: 40%;" />
</div>
<p>那么这个递归的递归体和递归的出口是什么呢？</p>
<p>很明显，递归分解的过程会不停地将大数组分解成两个小的子数组，这个分解的过程会根据大数组的左右界限求一个中间索引，然后将大数组尽量等分为两份。所以，递归分解的函数，至少需要三个参数：</p>
<ol type="1">
<li>递归分解的数组arr</li>
<li>数组分解的左下标left</li>
<li>数组分解的右下标right</li>
</ol>
<p>此递归分解的函数会将arr数组的[left, right]区间分解成两个小数组。</p>
<p><strong>于是递归的出口就很明显了是：left &gt;=
right，这表示子数组缩小到只包含一个元素或没有元素时，递归将停止。</strong></p>
<p>在计算中索引时，我们将采用一种优化的方案：</p>
<ol type="1">
<li>一般情况下，可以直接使用 “(left + right) &gt;&gt; 1”
来直接求中间索引。</li>
<li>但C语言中int类型可能只占2个字节，此时int类型取值范围较小，上面的表达式可能会出现数据溢出失真。为避免这种情况发生，我们可以采用表达式<strong>“left
+ (right - left &gt;&gt; 1)”</strong>去求中间索引。</li>
</ol>
<p><strong>合并过程：</strong></p>
<p>合并操作的思路是：</p>
<ol type="1">
<li>从左到右轮流比较待合并子数组中的元素，把比较过程中的较小元素存入临时数组中，直到某个子数组元素为空。</li>
<li>然后再将存在剩余元素的子数组中的所有元素，轮流放入临时数组中。</li>
<li>最后把临时数组中的元素，复制回原数组。</li>
</ol>
<p>注：临时数组的长度和原数组是一致的，且合并过程共有同一套下标索引。</p>
<h3 id="代码实现-4">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">归并排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
// 打印数组的函数
void print_arr(int arr[], int left, int right) &#123;
    for (int i = left; i <= right; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
/*
* 合并的思路:
* 1.把左右子数组中元素按照顺序合并到临时数组中,过程类似"穿针引线"
* 2.将排好序的临时数组元素按照下标赋值给原数组
* 注：临时数组和原数组共有一套下标
* 传入函数逻辑上的左右子数组是有序的,相当于合并两个有序的左右子数组
*/
static void merge(int arr[], int left, int mid, int right, int* temp) &#123;
    /*
    * tmp_idx: 用于存放合并结果的临时数组的开始下标
    * left_idx: 左子数组的开始下标
    * right_idx: 右子数组的开始下标
    */
    int temp_idx = left, left_idx = left, right_idx = mid + 1;
    // 只要左右子数组同时还有元素
    while (left_idx <= mid && right_idx <= right) &#123;
        // 逐对比较左右子数组的元素, 按照从小到大放入临时数组
        // <=判断不会改变相同元素的相对位置,是稳定算法。反之则不是稳定算法
        if (arr[left_idx]<=arr[right_idx])
        &#123;
            temp[temp_idx++] = arr[left_idx++];
        &#125;
        else
        &#123;
            temp[temp_idx++] = arr[right_idx++];
        &#125;
    &#125;
    // while结束时，左右子数组必然有一个没有元素了,此时另一个数组必然还有元素
    // 也就是说只会有一个数组是空的
    // 但我们无法确定是哪个数组没有元素了
    // 所以我们都判断一下将左右子数组还剩余的元素取出来
    while (left_idx <= mid) &#123;
        temp[temp_idx++] = arr[left_idx++];
    &#125;
    while (right_idx <= right) &#123;
        temp[temp_idx++] = arr[right_idx++];
    &#125;
    // 将临时数组中已排序好的元素复制到原始数组中
    for (int i = left; i <= right; i++)
    &#123;
        arr[i] = temp[i];
    &#125;
    // 打印此一轮归并排序的元素
    print_arr(arr, left, right);
&#125;
/*
* 辅助函数,实现对[left, right]范围内的数组递归分解合并
* left表示递归分解的区间起点,right表示递归分解区间的终点,是一个闭区间
* 递归分解的思路是:
* 对[left, right]区间元素的排序,可以分解成:
* [left, mid]区间,和[mid + 1, right]区间的排序合并
* 递归的出口是:
* 如果区间仅有一个元素或没有元素,递归结束
*/
static void divide_merge(int arr[], int left, int right, int* temp) &#123;
    // 递归的出口
    if (left>=right)
    &#123;
        return;
    &#125;
    // 递归体
    // 计算中间索引
    int mid = left + (right - left >> 1);
    divide_merge(arr, left, mid, temp);
    divide_merge(arr, mid + 1, right, temp);
    /*
     * 归并，归并排序的核心操作
     * 需要一个临时数组完成此操作
     * 这个临时数组至少要和原先的数组一般大
     * 有两种方案：
     * 1.用全局变量数组或局部变量,该方式简洁易实现,无需考虑内存回收
     *   但缺点是
     *   a.必须编译时期确定数组长度,无法运行时期动态分配
     *   b.栈区和数据段都无法创建长数组,在大数据集下容易产生溢出错误
     * 为了解决这两个缺点,我们可以在堆上动态分配数组
     *   但同样也有缺点:
     *   a.内存管理风险
     *   b.动态分配数组会带来额外性能开销
    */
    merge(arr,left,mid,right,temp);
&#125;
// 归并排序
void merge_sort(int arr[], int len) &#123;
    int* temp = calloc(len, sizeof(int));
    if (temp==NULL)
    &#123;
        printf("Error: malloc failed in merge_sort.\n");
        exit(1);
    &#125;
    // 将整个数组进行递归分解合并,即完成归并排序
    divide_merge(arr, 0, len - 1, temp);
    // 不要忘记free释放资源
    free(temp);
&#125;
int main(void) &#123;
    // 测试归并排序
    int arr[] = &#123; 8, 3, 2, 6, 9, 7, 1, 0, 4, 5 &#125;;
    int len = ARR_LEN(arr);
    merge_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-4">性能分析</h3>
<p><strong>时间复杂度：</strong></p>
<p>无论原始数组处在什么状态，归并排序都会按照既定步骤分解、合并。所以<strong>在最好，最坏，平均情况下，归并排序的时间复杂度都是一样的，都是<span
class="math inline">\(O(nlogn)\)</span>。</strong></p>
<p>归并排序的时间复杂度分析需要考虑它的两个主要操作，分解和合并：</p>
<ol type="1">
<li>分解过程也就是递归调用的过程，这个过程大概分解了<span
class="math inline">\(log_2{n}\)</span>次（每次都将数组折半，也就是递归的深度）</li>
<li>在合并的过程中，需要遍历并比较子数组的元素，然后将它们按顺序复制回原数组。每次合并操作的时间复杂度都是O(n)，因为它涉及到整个数组的遍历。合并的次数和分解的次数是一样的，都是log2n次，所以对于合并操作，总的时间复杂度是<span
class="math inline">\(O(nlogn)\)</span>。</li>
</ol>
<p>综合起来，时间复杂度就是<span
class="math inline">\(O(nlogn)\)</span>。</p>
<p><strong>空间复杂度：</strong></p>
<p>归并排序显然不是一个原地算法。它需要额外的内存空间：</p>
<ol type="1">
<li>需要一个与原始数组大小相同的，长度是n的辅助数组来进行合并操作。</li>
<li>递归调用，占用额外的栈空间。因为每次递归调用都会将数组分为两个大致相等的部分，所以每次都将问题的规模减半。递归深度大致是<strong><span
class="math inline">\(log_2{n}\)</span></strong>。</li>
</ol>
<p><strong>所以空间复杂度是O(n)。</strong></p>
<p><strong>稳定性：</strong></p>
<p><strong>归并排序是稳定的排序算法。</strong>这是因为如果两个元素相等，归并排序不会改变它们的相对顺序。</p>
<h2 id="快速排序">快速排序</h2>
<p><strong>快速排序(Quick
Sort)</strong>是一种建立在<strong>分区(partition)操作</strong>上的，非常高效的排序算法，由托尼·霍尔在1960年代提出。快速排序同样是分治思想的典型应用，由于其优秀的性能和较为简单的实现，它通常是实际应用中，<strong>大数据集下</strong>首选的排序算法。</p>
<p>通过分区，快速排序实现了对数组的分解，大体思路是：</p>
<ol type="1">
<li>分解大问题：挑选一个基准值(pivot)，然后通过一轮遍历将数组分成两个子数组：一个包含所有小于等于基准的元素，另一个包含所有大于基准的元素。这个过程就是分区操作，该过程结束后，基准值一定位于其排序最终位置上。</li>
<li>解决子问题：递归地对两个子数组进行快速排序。由于这两个子数组都比原始数组小，这就是解决子问题的过程。如果子数组足够小，可以直接认定它就是有序的。</li>
<li>合并：快速排序的操作都是在原数组上直接进行的，所以快速排序的合并步骤实际上并不需要做任何操作，只有解决子问题，原数组就是直接排好序的。</li>
</ol>
<p>在具体到实现时，快速排序根据分区操作的不同，可以分为两种：</p>
<ol type="1">
<li>单向分区</li>
<li>双向分区</li>
</ol>
<p>其中双向分区泛用性最强，也最常用。</p>
<h3 id="单向分区">单向分区</h3>
<p><strong>所谓单向分区，指的是快速排序算法在分区的过程中，元素比较和交换的操作是单向进行的，也就是从数组的一端进行到另外一端。</strong></p>
<p>单向分区快速排序算法，具体而言，它的思路是：</p>
<ol type="1">
<li>选择一个基准值（pivot），可以是随机选择，也可以是直接选首尾元素。选定基准值后，一般会将pivot交换到数组末尾，这样做可以简化分区操作。</li>
<li>设置一个索引(比如叫idx)来追踪小于基准值的元素应该插入的位置，一开始idx索引指向数组的首元素。</li>
<li><strong>遍历数组进行分区操作：</strong>
<ol type="1">
<li>从数组首元素开始遍历整个数组</li>
<li>如果元素小于基准值，则将该元素与idx位置的元素交换，idx索引加1。</li>
<li>如果元素大于或等于基准值，则不做任何操作，继续遍历下一个元素。</li>
</ol></li>
<li>当遍历到最后一个元素，也就是pivot时，遍历结束：
<ol type="1">
<li>最后将pivot元素和此时idx索引元素进行交换，完成这一轮分区操作。</li>
<li>此时pivot左侧的元素一定都是小于基准值的。</li>
<li>pivot右侧的元素一定都是大于等于基准值的。</li>
</ol></li>
<li>对基准值左右两边的子数组递归地执行以上步骤，直到每个子数组的大小减少到1或0，此时数组就被完全排序了。</li>
</ol>
<h3 id="双向分区">双向分区</h3>
<p>比起单向分区，双向分区是更常用的快排分区策略，<strong>一般而言当提起快速排序，指的都是双向分区策略的快速排序。</strong></p>
<p><strong>所谓双向分区，指的是在分区过程中，元素比较和交换操作的方向是，同时从数组的两端向中间逼近的。</strong></p>
<p>双向分区快速排序算法，具体而言，它的思路是：</p>
<ol type="1">
<li><p>选择基准值pivot，基准值可以是一个随机元素，也可以选择一个固定元素。然后将基准值元素和首元素交换，这样做的目的是为了将交换元素操作优化成一个赋值操作。<strong>并且要将基准值存储起来。</strong></p></li>
<li><p>设置两个索引 low 和 high ：</p>
<ol type="1">
<li><p>索引 low
一开始指向数组首元素，它的含义是指示小于基准值的元素应该置于的位置。</p></li>
<li><p>索引 high
一开始指向数组尾元素，它的含义是指示大于等于基准值的元素应该置于的位置。</p></li>
</ol></li>
<li><p>率先移动索引high，它从尾元素开始向左移动，目标是找到第一个小于基准值的元素：</p>
<ol type="1">
<li><p>找到该元素后，直接将该元素赋值给low索引位置，也就是覆盖掉基准值。</p></li>
<li><p><strong>赋值结束后，low索引和high索引都不需要移动。</strong></p></li>
</ol></li>
<li><p>然后向右移动索引 low，找到第一个大于等于基准值的元素：</p>
<ol type="1">
<li><p>找到该元素后，直接将该元素赋值给high索引位置</p></li>
<li><p><strong>赋值结束后，low索引和high索引都不需要移动。</strong></p></li>
</ol></li>
<li><p>重复过程3和4，直到索引high和low相遇。最后将基准值放入它们相遇的位置。</p></li>
<li><p>于是分区就结束了，基准值到达了排序的最终位置，基准值左边都是小于基准值的元素，右边都是大于等于基准值的元素。</p></li>
<li><p>对基准值左右两边的子数组递归地执行以上步骤，直到每个子数组的大小减少到1或0，此时数组就被完全排序了。</p></li>
</ol>
<h3 id="代码实现-5">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">快速排序算法单向分区C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#define ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j) &#123;   \
    int tmp = arr[i];       \
    arr[i] = arr[j];        \
    arr[j] = tmp;           \
&#125;
// 打印数组的函数
void print_arr(int arr[], int left, int right) &#123;
    for (int i = left; i <= right; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 分区核心操作实现,返回一轮快排选择的pivot的下标
int partition(int arr[], int left, int right) &#123;
    // 1.随机选择一个基准值,然后把它先放到数组末尾
    int pivot_idx = left + rand() % (right - left + 1); // 得到一个[left, right]范围内的随机索引
    int pivot = arr[pivot_idx];
    SWAP(arr, pivot_idx, right);
    // 2.设置一个partition_idx索引,指示小于pivot的元素应该插入的位置
    // 同时该索引最终表示分区的界限索引,所以命名为partition_idx
    int partition_idx = left;
    // 3.遍历整个数组,当元素小于pivot时,将它和partition_idx位置元素交换,partition_idx加1
    // 希望遍历结束时，i指向数组末尾的pivot，所以i < right
    for (int i = left; i < right; i++) &#123;
        if (arr[i] < pivot) &#123;
            SWAP(arr, i, partition_idx);
            partition_idx++;
        &#125;
    &#125;
    // 4.遍历结束后,将pivot元素(最后一个元素)交换到partition_idx位置
    SWAP(arr, right, partition_idx);
    printf("此一轮分区操作,选择的pivot是: %d\n分区结束后的数组是: ", pivot);
    print_arr(arr, left, right);
    // 5.返回基准值的位置索引
    return partition_idx;
&#125;
/*
* 辅助函数
* 用于对对[left, right]区间中的元素进行递归分区操作
*/
void partition_recursion(int arr[], int left, int right) &#123;
    // 递归出口
    if (left >= right) &#123;
        return;
    &#125;
    // 递归体
    int idx = partition(arr, left, right);  // 分区操作,找到pivot元素的下标位置
    partition_recursion(arr, left, idx - 1);
    partition_recursion(arr, idx + 1, right);
&#125;
void quick_sort_one_way(int arr[], int len) &#123;
    // 初始化随机数生成器,time(NULL)获取当前时间戳
    // 用于生成随机索引
    srand(time(NULL));
    // 调用辅助函数进行递归分解
    partition_recursion(arr, 0, len - 1);
&#125;
int main(void) &#123;
    // 测试单向分区快速排序
    int arr[] = &#123; 8,3,2,6,9,5 &#125;;
    int len = ARR_SIZE(arr);
    quick_sort_one_way(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange">快速排序算法双向分区C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
// 打印数组的函数
void print_arr(int arr[], int left, int right) &#123;
    for (int i = left; i <= right; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 快速排序的核心操作: 双向分区, 也就是确定pivot的最终位置
// 挑选一个基准值,通过双向分区操作,决定最终的位置,最终位置就是基准值排好序的位置
static int partition(int arr[], int left, int right) &#123;
    // 1.为了简化实现,直接挑选首元素为基准值(因为基准值要交换到开头,所以直接挑选首元素作为基准值,可以减少一步交换)
    int pivot = arr[left];
    // 2.初始化两个索引low和high,分别指向数组两端
    int low = left, high = right;
    // 3.循环遍历这个数组区间
    while (low < high) &#123;    // 两个索引没有相遇就继续循环
        // 在两个索引没有相遇的情况下,high索引用于寻找比基准值小的元素
        while (low < high && arr[high] >= pivot) &#123;
            high--;
        &#125;   // while循环结束时,要么两个索引相遇了,要么high索引已经找到了一个比基准值小的元素
        arr[low] = arr[high];   // 将这个比基准值小的元素覆盖到low位置
        //low++;    该行语句不能加，因为若此时两个索引相遇结束while，low++将导致相遇的索引不再相遇
        // 
        // 在两个索引没有相遇的情况下,low索引用于寻找比基准值大和相等的元素
        while (low < high && arr[low] < pivot) &#123;
            low++;
        &#125;   // while循环结束时,要么两个索引相遇了,要么low索引已经找到了一个比基准值大或相等的元素
        arr[high] = arr[low];   // 将这个比基准值大或相等的元素覆盖到high位置
        //high--;   该行语句不能加，因为若此时两个索引相遇结束while，high--将导致相遇的索引不再相遇
        //
    &#125;   // while循环结束时,说明low和high索引相遇,此时该位置就是pivot应该放置的位置
    arr[low] = pivot;
    printf("此一轮分区操作选择的pivot = %d\n", pivot);
    print_arr(arr, left, right);
    return low;
&#125;
// 对[left, right]区间进行递归分区操作
void partition_recursion(int arr[], int left, int right) &#123;
    // 递归出口
    if (left >= right) &#123;
        return;
    &#125;
    // 递归体
    int idx = partition(arr, left, right);  // 分区操作,找到pivot下标位置
    partition_recursion(arr, left, idx - 1);
    partition_recursion(arr, idx + 1, right);
&#125;
void quick_sort_two_way(int arr[], int len) &#123;
    partition_recursion(arr, 0, len - 1);
&#125;
int main(void) &#123;
    int arr[] = &#123; 8,3,2,6,9,5 &#125;;
    int len = ARR_SIZE(arr);
    // 测试双向分区-快速排序
    quick_sort_two_way(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-5">性能分析</h3>
<p><strong>时间复杂度：</strong></p>
<p>一般提起快速排序算法，不管采取单双向哪一种分区策略，都只会说它的时间复杂度是O(nlogn)级别。</p>
<p><strong>空间复杂度：</strong></p>
<p>快速排序，无论什么分区策略，都不需要额外的数组空间来辅助排序，但考虑到需要使用递归来实现算法。</p>
<p><strong>在最佳和平均情况下，递归深度大约是<span
class="math inline">\(log_2{n}\)</span>，空间复杂度是<span
class="math inline">\(O(logn)\)</span></strong></p>
<p>但如果是在最坏情况下，递归深度接近n，此时空间复杂度为<span
class="math inline">\(O(n)\)</span></p>
<p><strong>稳定性：</strong></p>
<p>快速排序是一种不稳定的排序算法，无论选取什么分区方案，快速排序都有可能改变两个相同元素的相对位置。</p>
<h2 id="堆排序">堆排序</h2>
<p><strong>堆排序(HeapSort)</strong>是一种高效的排序算法，它利用了堆这种数据结构来实现排序。</p>
<p>堆是一种特殊的完全二叉树，它满足以下性质：</p>
<ol type="1">
<li>大顶堆(最大堆)：每个父节点的值都大于或等于其子节点的值<strong>(递归定义)</strong>。这意味着树的根节点（堆顶）是所有节点中的最大值。</li>
<li>小顶堆(最小堆)：每个父节点的值都小于或等于其子节点的值<strong>(递归定义)</strong>。这意味着树的根节点（堆顶）是所有节点中的最小值。</li>
</ol>
<p>在实现堆排序时，一般选择使用大顶堆。</p>
<h3 id="算法思想-5">算法思想</h3>
<p>堆排序的过程可以分为两个主要步骤：</p>
<ol type="1">
<li>构建一个大顶堆</li>
<li>堆排序过程</li>
</ol>
<p>下面分别解释一下这两个过程：</p>
<p><strong>步骤一：构建一个大顶堆</strong></p>
<p>首先，堆排序基于一个大顶堆来实现排序并不意味着需要借助额外的数据结构，而是只需要把原数组在逻辑上看成是一个大顶堆即可。</p>
<p>在这个过程中，数组首元素(下标为0的元素)就是完全二叉树的根结点，而一个下标为i的元素，它的两个子结点是：</p>
<ol type="1">
<li><strong>2i + 1</strong></li>
<li><strong>2i + 2</strong></li>
</ol>
<p>比如：根结点元素下标为0，它的两个子结点就是下标为1和2的元素。而下标为1的元素，它的两个子结点就是下标为3和4的元素。</p>
<p>以数组[4, 10, 3, 5,
1]为例，这个数组可以构建下面一棵完全二叉树<strong>(还不是大顶堆，因为结点数据大小关系不对)</strong>：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312121727197.png" alt="数组-构建完全二叉树" style="zoom: 33%;" />
</div>
<p>构建好这样一棵完全二叉树后，就需要调整元素的位置，使得它成为一个大顶堆。具体来说需要这么做：</p>
<p>从数组尾元素开始，找到第一个非叶子结点<strong>（因为叶子结点可以视为已经是大顶堆了）</strong>。遍历这个非叶子结点的左右子树，比较元素的大小关系，以决定是否需要调整元素位置。这个过程会自下而上的将一棵完全二叉树调整成为一个大顶堆，这个过程就是<strong>堆化(heapify)</strong></p>
<p><strong>注意：在堆化的过程中，一旦进行了子树结点和父节点的交换操作以后，就需要再判断以该子树结点为父节点的二叉树是否为大顶堆，从而决定是否再次进行调整！！！</strong></p>
<p>那么哪一个元素是这棵树的最后一个非叶子结点（从尾元素开始的第一个非叶子结点）？</p>
<p>我们可以假设最后一个非叶子结点的下标是<code>i</code>，它一定有左子树，且左子树的下标是<code>2i + 1</code>，这个下标不能超出数组的索引界限，假如数组长度是<code>len</code>，下标最大是<code>len-1</code></p>
<p>计算过程如下：</p>
<p><code>2i + 1 &lt;= len - 1 i &lt;= (len - 2) / 2</code></p>
<p>最后一个非叶子结点就是取等号的位置，也就是<code>(len - 2 ) / 2</code>索引位置就是数组这棵树的最后一个结点。</p>
<p>比如在本案例中：</p>
<ol type="1">
<li>第一个非叶子结点是下标为1的元素10，遍历它的左右子树即下标为3和4的结点，发现符合大顶堆的定义。此父结点不需要调整。</li>
<li>第二个非叶子结点就是根结点，下标为0的元素4，遍历它的左右子树即下标为1和2的结点，发现左子树的10比4大，于是交换它们。这样交换后的数组就变成了：[10,
4, 3, 5, 1]。</li>
<li>但这样不算完，下标为0的父节点和下标为1的左子树交换了元素，所以就需要再次判断下标为1的左子树是否还符合大顶堆定义，此时发现已经不符合了。所以再次调整，交换元素4和5。此时被交换元素的结点已经是叶子结点了，没有左右子树，这样整个数组才完全构建成了一个大顶堆。数组堆化结束最终为：[10,
5, 3, 4, 1]</li>
</ol>
<p>经过上述调整，此时该数组就可以在逻辑上看成一个大顶堆。如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312122153960.png" alt="数组-构建大顶堆过程示意图" style="zoom: 40%;" />
</div>
<p>这样第一步，构建大顶堆就完成了。</p>
<p><strong>步骤二：堆排序过程</strong></p>
<p>基于一个大顶堆，知道此时数组的首元素(也就是堆顶元素)，一定是此数组的最大值，那这就好办了。</p>
<p>所谓堆排序的过程，也就是通过不断将堆顶元素移动到数组末尾，再重构大顶堆(重新堆化)，再移动堆顶元素….重复的过程。</p>
<p>具体来说步骤就是：</p>
<ol type="1">
<li>将堆顶元素和堆末尾的元素交换，第一次也就是数组的首尾元素进行交换，这样数组的最大值就到了数组的末尾。于是数组就变成了[1,
5, 3, 4, 10]</li>
<li>将堆的逻辑大小减少1，数组就变成[1, 5, 3, 4]</li>
<li>重构大顶堆(重新堆化)。
<ol type="1">
<li>在上述过程中，数组末尾元素被去掉了，首元素是新赋值的。所以如果新数组逻辑上不是一个大顶堆，只可能是首元素违反了规则。</li>
<li>此时只需要比较首元素和左右子树结点的大小，然后进行调整就可以重新堆化。</li>
<li><strong>不要忘记上述过程如果出现了元素交换，那么就需要去判断被交换的左右子树是否还符合大顶堆的规则。</strong></li>
<li>在本案例中，首先需要将元素5和元素1交换，将1交换到左子树后发现左子树不再是一个大顶堆，于是就继续交换元素1和4。最终数组重新堆化，变成了[5,
4, 3, 1]</li>
</ol></li>
<li>重复过程1~3，直到堆的大小减少为1，堆排序结束。</li>
</ol>
<p>这一过程，可以用下图来描述：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312122257230.png" alt="堆排序过程示意-图" style="zoom: 33%;" />
</div>
<p><strong>于是第二步堆排序过程就完成了，最终就在原地得到了一个排序好的数组。</strong></p>
<p>以上两个步骤合起来，就是一个完整的堆排序过程，下面就可以基于这个思路来实现堆排序。</p>
<h3 id="实现思路">实现思路</h3>
<p>上述堆排序算法在具体实现时，要分为两个步骤：</p>
<ol type="1">
<li>将待排序的原始数组，在逻辑上进行第一次堆化的操作</li>
<li>将大顶堆的根结点元素移到数组末尾，交换首尾元素，逻辑上堆大小减1，以新的根结点进行堆化操作。</li>
</ol>
<p>这两个步骤中的核心操作逻辑都是——堆化。</p>
<p>于是我们把堆化这个操作，提取出一个函数，那么这个函数应该给什么参数呢？怎么写呢？</p>
<p>堆化的过程，其实就是自父结点开始，向下检查左右子树和这个父结点大小关系的过程：</p>
<ol type="1">
<li>如果左子树大于父结点，那么交换左子树和父结点</li>
<li>如果右子树大于父结点，那么交换右子树和父结点</li>
<li><strong>如果出现了交换，那么被交换的左子树或右子树就要重新进行堆化操作。</strong></li>
<li>如果根结点已经是最大值(相等的最大值也算)，没有交换，那么堆化结束。</li>
</ol>
<p>为什么这么设计堆化函数呢？为了让堆排序两个过程，都能复用这个函数：</p>
<ol type="1">
<li>在第一个步骤中，我们只需要从原数组的最后一个非叶子结点开始，将每一个非叶子结点作为父结点，逐一堆化。最终将根结点作为父结点传入，完成整个堆化过程。</li>
<li>在第二个步骤中，会将已生成的大顶堆的首尾元素交换，并将尾元素(最大值)移除，堆结点数量减1。此时如果这个堆不是大顶堆了，只可能是首元素(原本的尾元素)影响了大顶堆的性质。于是我们就以这个首元素为父结点，重新进行堆化。</li>
</ol>
<p>那么这个堆化函数的声明就应该如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> heap_len, <span class="type">int</span> idx)</span>;</span><br></pre></td></tr></table></figure>
<p>解释一下：</p>
<ol type="1">
<li><strong>arr参数：</strong>待堆化的原数组</li>
<li><strong>heap_len参数：</strong>逻辑上堆结点的数量。
<ol type="1">
<li>一开始它就是数组的长度</li>
<li>每一轮堆排序会去掉一个最大值，逐渐减少</li>
<li>直到堆的逻辑大小减少为1，堆排序就结束了，原数组排序完成。</li>
</ol></li>
<li><strong>idx参数：</strong>可能违反大顶堆规则的父结点的下标。</li>
</ol>
<p>把这个核心逻辑函数分析清楚了，代码实现就很容易了。</p>
<h3 id="代码实现-6">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">堆排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP_ELEMENT(arr, i, j)&#123;    \
    int tmp = arr[i];       \
    arr[i] = arr[j];        \
    arr[j] = tmp;       \
&#125;
void print_arr(int arr[], int n) &#123;
    for (int i = 0; i < n; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 该函数会把以root_idx索引元素为根结点的
// 逻辑长度是tree_len的一棵完全二叉树arr，构建成一个大顶堆
static void heapify(int arr[], int tree_len, int root_idx) &#123;
    /*
        堆化操作必然是需要循环来完成的
        如果对于某个循环,既不清楚循环的次数,循环结束的条件也不太好找到
        那么可以先写一个死循环, 然后具体到代码中再用break,return等结束循环
    */
    while (1) &#123;
        // 根据根节点的下标,先计算出左右子树的下标
        int lchild_idx = (root_idx << 1) + 1;
        int rchild_idx = (root_idx << 1) + 2;
        int max_idx = root_idx;     // 先假设根节点就是最大值
        if (lchild_idx < tree_len && arr[lchild_idx] > arr[max_idx]) &#123;
            // 如果左子树存在且左子树值比假设的最大值要大,那么左子树下标就是新的最大值下标
            max_idx = lchild_idx;
        &#125;
        if (rchild_idx < tree_len && arr[rchild_idx] > arr[max_idx]) &#123;
            // 如果右子树存在且右子树值比假设的最大值要大,那么右子树下标就是新的最大值下标
            max_idx = rchild_idx;
        &#125;
        if (max_idx != root_idx) &#123;
            // 交换左右子树较大者和根节点的值
            SWAP_ELEMENT(arr, max_idx, root_idx);
            // 此时max_idx结点的值就是以前根节点的值,此时由于数据发生了改变,max_idx结点的树就不一定是大顶堆了
            // 所以接下来要以max_idx为根节点,继续构建大顶堆
            root_idx = max_idx;
        &#125;
        else &#123;
            // 不需要交换了,说明以root_idx为根节点的树已经是大顶堆了
            break;
        &#125;
    &#125;
&#125;
// 第一次将数组构建成大顶堆，自下而上将每一个非叶子结点构建大顶堆
static void first_build_heap(int arr[], int len) &#123;
    int last_idx = len - 2 >> 1;    //最后一个非叶子结点的下标
    for (int i = last_idx; i >= 0; i--) &#123;
        heapify(arr, len, i);
    &#125;
    printf("第一次堆化后数组为: \n");
    print_arr(arr, len);
&#125;
void heap_sort(int arr[], int len) &#123;
    // 1.将原arr数组构建成大顶堆，第一次构建大顶堆
    first_build_heap(arr, len);
    // 2.反复移除根结点元素，然后再重建大顶堆
    int heap_len = len; // 堆逻辑上的长度，一开始就是数组长度，随着反复移除重建大顶堆，这个长度会一直减少1
    while (heap_len > 1) &#123;  // 只要堆还有两个元素就需要继续构建移除
        SWAP_ELEMENT(arr, 0, heap_len - 1);
        heap_len--;
        /*
            堆排序的核心操作：
            重新构建大顶堆
        */
        heapify(arr, heap_len, 0);  // 堆排序核心操作：堆化
        printf("重新构建大顶堆后: \n");
        print_arr(arr, heap_len);
    &#125;
&#125;
int main(void) &#123;
    int arr[] = &#123; 4, 10, 3, 5, 1 &#125;;
    int len = ARR_SIZE(arr);
    heap_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-6">性能分析</h3>
<p><strong>时间复杂度：</strong></p>
<p><strong>堆排序在任何情况下，时间复杂度都是<span
class="math inline">\(O(nlogn)\)</span></strong>。</p>
<p><strong>空间复杂度：</strong></p>
<p>堆排序显然是一个原地算法，不需要任何额外内存空间，空间复杂度是O(1)</p>
<p><strong>稳定性：</strong></p>
<p>堆排序是一种不稳定的排序算法，在堆化的过程需要交换父节点和左右子树结点，这个过程非常容易出现改变相同元素位置的情况。</p>
<h2 id="排序算法总结">排序算法总结</h2>
<div data-align="center">
<table>
<tr>
<th>
</th>
<th>
</th>
<th>
选择排序
</th>
<th>
冒泡排序
</th>
<th>
插入排序
</th>
<th>
希尔排序
</th>
<th>
归并排序
</th>
<th>
快速排序
</th>
<th>
堆排序
</th>
</tr>
<tr>
<td rowspan="3">
时间复杂度
</td>
<td>
最佳情况
</td>
<td>
O(n^2)
</td>
<td>
<b>O(n)</b>
</td>
<td>
<b>O(n)</b>
</td>
<td>
小于O(n^2)
</td>
<td>
O(nlogn)
</td>
<td>
O(nlogn)
</td>
<td>
O(nlogn)
</td>
</tr>
<tr>
<td>
平均情况
</td>
<td>
O(n^2)
</td>
<td>
O(n^2)
</td>
<td>
O(n^2)
</td>
<td>
小于O(n^2)
</td>
<td>
O(nlogn)
</td>
<td>
O(nlogn)
</td>
<td>
O(nlogn)
</td>
</tr>
<tr>
<td>
最坏情况
</td>
<td>
O(n^2)
</td>
<td>
O(n^2)
</td>
<td>
O(n^2)
</td>
<td>
接近O(n^2)
</td>
<td>
O(nlogn)
</td>
<td>
O(n^2)
</td>
<td>
O(nlogn)
</td>
</tr>
<tr>
<td colspan="2">
空间复杂度
</td>
<td>
O(1)
</td>
<td>
O(1)
</td>
<td>
O(1)
</td>
<td>
O(1)
</td>
<td>
O(n)
</td>
<td>
O(logn)~O(n)
</td>
<td>
<b>O(1)</b>
</td>
</tr>
<tr>
<td colspan="2">
稳定性
</td>
<td>
不稳定
</td>
<td>
稳定
</td>
<td>
稳定
</td>
<td>
不稳定
</td>
<td>
<b>稳定</b>
</td>
<td>
不稳定
</td>
<td>
不稳定
</td>
</tr>
</table>
</div>
<p>对于这七种排序算法，我们同样可以在适用场景上，对它们做一个总结：</p>
<ol type="1">
<li>选择排序：建议任何情况都不用。</li>
<li>冒泡排序：建议任何情况都不用。</li>
<li><strong>插入排序：适合小数据集，尤其当数据已基本有序时非常好用。</strong></li>
<li>希尔排序：一般不使用。</li>
<li><strong>归并排序：大数据集的场景下，需要稳定排序算法时使用。</strong></li>
<li><strong>快速排序：大数据集的场景下，通用的排序算法，效率高，但不稳定。</strong></li>
<li><strong>堆排序：大数据集的场景下，性能均衡的不稳定排序算法，优点是不占用额外内存空间。</strong></li>
</ol>
<p><strong>除此之外，我们还可以总结记忆排序算法的稳定和不稳定性的特点：</strong></p>
<p>只要排序算法涉及到<strong>大范围的、远距离的元素交换</strong>，那么该算法肯定不是稳定算法，因为远距离的数据交换没办法控制元素的相对位置不变。</p>
<p>举例：</p>
<ol type="1">
<li>选择排序：选择最小（或最大）元素放在排序数组的起始位置，涉及远距离交换。</li>
<li><strong>希尔排序</strong>：通过使用间隔序列，它在远距离进行元素比较和交换。</li>
<li><strong>快速排序</strong>：通过分区操作，导致可能出现远距离的元素交换。</li>
<li><strong>堆排序</strong>：可能出现将根结点元素一直交换到叶子结点，这是远距离交换元素。</li>
</ol>
<p>这些排序算法，都是因为存在不相邻元素的远距离交换，所以是不稳定的</p>
<p>而<strong>冒泡排序、插入排序以及归并排序，由于总是交换相邻元素，它们就是稳定的。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://invinc-z.com/computer_organization/code_original_inverse_complement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Invinc-Z">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Invinc-Z Blog">
      <meta itemprop="description" content="Welcome to my blog! Here I share tech tips and life stories.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Invinc-Z Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/computer_organization/code_original_inverse_complement/" class="post-title-link" itemprop="url">有符号整数的三种编码方式：原码、反码和补码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-01 05:12:18" itemprop="dateCreated datePublished" datetime="2024-01-01T05:12:18+08:00">2024-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-07 19:16:11" itemprop="dateModified" datetime="2025-06-07T19:16:11+08:00">2025-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" itemprop="url" rel="index"><span itemprop="name">计算机组成</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在计算机中，<strong>原码、反码、补码</strong>
是用于表示有符号整数的三种编码方式，主要用于解决二进制数的
<strong>正负表示</strong> 和 <strong>加减运算</strong>
问题。它们的核心区别在于 <strong>符号位的处理</strong> 和
<strong>负数的表示方法</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/computer_organization/code_original_inverse_complement/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Invinc-Z</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">85k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:10</span>
  </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ludmluYy1a" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
