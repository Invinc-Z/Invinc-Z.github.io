<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言之二分查找算法</title>
    <url>/lang-c/c-binary-search-algorithm/</url>
    <content><![CDATA[<p>本文介绍了二分查找算法，首先分析了算法的基本实现思想，接着使用C语言以递归和循环两种方式进行代码实现，并且给出了一些二分查找的变体代码，最后简述了其典型的应用场景。</p>
<span id="more"></span>
<hr />
<h2 id="基本思想">基本思想</h2>
<p>二分查找的基本思想如下：</p>
<ol type="1">
<li><strong>找到中间元素：</strong>查找过程从数组的中间元素开始，如果中间元素恰好是目标元素，则查找过程结束。</li>
<li><strong>比较并缩小范围：</strong>如果中间元素不是目标元素，那么将中间元素与目标值进行比较：
<ol type="1">
<li>如果目标值小于中间元素，则说明目标值位于当前搜索范围的左半部分。</li>
<li>如果目标值大于中间元素，则说明目标值位于当前搜索范围的右半部分。</li>
</ol></li>
<li><strong>重复上述过程。</strong>不断重复上述过程，每次都将搜索范围缩小一半，直到找到目标值或者发现目标元素不存在。</li>
</ol>
<p>二分查找的关键在于每次比较后都能排除一半的搜索范围，这使得查找效率非常高，尤其是在大型数组中。</p>
<p><strong>这种算法的时间复杂度为 O(log n)，其中 n
是数组的长度。</strong></p>
<hr />
<h2 id="代码实现">代码实现</h2>
<h3 id="递归实现">递归实现</h3>
<details>
<summary>
<font size="4" color="orange">递归实现二分查找</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int bs_recursion(int arr[], int left, int right, int target) &#123;
    // 递归的出口
    // 如果区间已不存在, 则二分查找结束, 没找到目标元素
    if (left > right) &#123;
        return -1;
    &#125;
    int mid = left + (right - left >> 1);
    int diff = target - arr[mid];
    if (diff < 0)
        return bs_recursion(arr, left, mid - 1, target);
    if (diff > 0)
        return bs_recursion(arr, mid + 1, right, target);
    return mid;
&#125;
int binary_search(int arr[], int len, int target) &#123;
    bs_recursion(arr, 0, len - 1, target);
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 7;
    int idx = binary_search(arr, len, target);
    printf("查找目标元素%d, 它在数组中的索引是%d\n", target, idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="循环实现">循环实现</h3>
<details>
<summary>
<font size="4" color="orange">循环实现二分查找</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        int diff = target - arr[mid];
        if (diff < 0)
            right = mid - 1;
        else if (diff > 0)
            left = mid + 1;
        else
            return mid;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 100;
    int idx = binary_search(arr, len, target);
    printf("查找目标元素%d, 它在数组中的索引是%d\n", target, idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="二分查找变体">二分查找变体</h3>
<details>
<summary>
<font size="4" color="orange">查找数组中第一个与目标值相等的元素</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search_first(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        int diff = target - arr[mid];
        if (diff < 0)
            right = mid - 1;
        else if (diff > 0)
            left = mid + 1;
        else &#123;
            if (mid == left || arr[mid - 1] < target)
            &#123;
                return mid;
            &#125;
            right = mid - 1;
        &#125;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 7;
    int idx = binary_search_first(arr, len, target);
    printf("查找目标元素%d, 它在数组中的第一个索引是%d\n", target, idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange">查找数组中最后一个与目标值相等的元素</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search_last(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        int diff = target - arr[mid];
        if (diff < 0)
            right = mid - 1;
        else if (diff > 0)
            left = mid + 1;
        else &#123;
            if (mid == right || arr[mid + 1] > target)
            &#123;
                return mid;
            &#125;
            left = mid + 1;
        &#125;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 7;
    int idx = binary_search_last(arr, len, target);
    printf("查找目标元素%d, 它在数组中的最后一个索引是%d\n", target, idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange">查找数组中第一个大于等于目标值的元素</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search_first_gt(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        if (arr[mid] < target)
            left = mid + 1;
        else &#123;
            if (mid == left || arr[mid - 1] < target)
            &#123;
                return mid;
            &#125;
            right = mid - 1;
        &#125;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 7;
    int idx = binary_search_first_gt(arr, len, target);
    printf("查找数组中第一个大于等于目标值%d的元素, 它是%d, 在索引%d\n", target,arr[idx], idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange">查找数组中最后一个小于等于目标值的元素</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_search_last_lt(int arr[], int len, int target) &#123;
    int left = 0, right = len - 1;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        if (arr[mid] > target)
            right = mid - 1;
        else &#123;
            if (mid == right || arr[mid + 1] > target)
            &#123;
                return mid;
            &#125;
            left = mid + 1;
        &#125;
    &#125;
    return -1;
&#125;
int main(void) &#123;
    int arr[] = &#123; 0,3,5,7,7,7,9,10, 20,100 &#125;;
    int len = ARR_LEN(arr);
    int target = 8;
    int idx = binary_search_last_lt(arr, len, target);
    printf("查找数组中最后一个小于等于目标值%d的元素, 它是%d, 在索引%d\n", target, arr[idx], idx);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<hr />
<h2 id="典型应用">典型应用</h2>
<h3 id="ip归属地查询">IP归属地查询</h3>
<h3 id="改进插入排序">改进插入排序</h3>
<p>二分查找是可以改进插入排序的，其核心思路是，每一轮插入排序都会有一张”新抓手牌”，而”旧手牌”是一个已经有序的数组。传统的做法是：</p>
<p>让”新手牌”逐一和”旧手牌”有序数组中的元素逐一比较，然后确定”新手牌”的插入位置，向后移动元素，将”新手牌”插入。如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202401150718625.png" alt="二分查找-改进插入排序" style="zoom: 50%;" />
</div>
<p>当数据量比较大时，“旧手牌”比较多，有序数组很长时，可以考虑用二分查找，替代逐一比较查找待插入位置。那么这个二分查找是在找什么呢？</p>
<p>当然是查找<strong>最后一个小于等于”新手牌”值的元素</strong>，这样就可以直接将它后面的所有元素后移一位，然后再它后面直接插入”新手牌”。</p>
<p>当然，这种改进在实际应用中并不常见：</p>
<ol type="1">
<li>插入排序本身就应用于小数据集，大数据集情况下大多不会选择插入排序。</li>
<li>既然是应用于小数据集，数组本身较短，用二分查找的意义就不大了。对效率的提升不明显，而且还增加了复杂性。</li>
</ol>
<details>
<summary>
<font size="4" color="orange">使用二分查找改进的插入排序</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr)/sizeof(arr[0]))
int binary_sort(int arr[], int left,int right, int target) &#123;
    while (left <= right) &#123;
        int mid = left + (right - left >> 1);
        if (arr[mid]>target)
        &#123;
            right = mid - 1;
        &#125;
        else
        &#123;
            if (mid == right||arr[mid+1]>target)
            &#123;
                return mid;
            &#125;
            left = mid + 1;
        &#125;
    &#125;
    return -1;
&#125;
void binary_insertion_sort(int arr[], int len) &#123;
    for (int i = 1; i < len; i++)
    &#123;
        int value = arr[i];
        // 使用二分查找找到应插入的位置
        // idx(不包括)后面的所有元素都有后移一位，idx + 1是value要插入的位置
        int idx = binary_sort(arr, 0,i-1, value);
        int j = i - 1;  // j在这里赋值为有序数组的最后一个元素
        while (j > idx) &#123;       // 有序数组中的元素只要下标大于idx就后移 也就是不包括idx，但idx后面的所有元素都要后移
            arr[j + 1] = arr[j];
            j--;
        &#125; // j == idx;
        arr[j + 1] = value;
    &#125;
&#125;
int main(void) &#123;
    int arr[] = &#123; 9, 5, 2, 7, 1, 3, 4, 0, 8, 6 &#125;;
    int len = ARR_LEN(arr);
    binary_insertion_sort(arr, len);
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
]]></content>
      <categories>
        <category>C语言</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言之动态内存分配与释放</title>
    <url>/lang-c/c-dynamic-memory-allocation-tree/</url>
    <content><![CDATA[<p>本文首先介绍了通用指针类型void的特点，接着给出了在堆上动态分配内存空间主要依赖的三个函数（malloc、calloc和realloc）和内存释放函数free的使用方法和注意事项。</p>
<span id="more"></span>
<hr />
<h2 id="通用指针类型void">通用指针类型void</h2>
<p>通用类型指针具有以下特点：</p>
<p><strong>类型无关，赋值灵活：</strong>由于指针本质上是一个存储内存地址的变量，而内存地址是没有类型的，所以void指针可以存储任意类型数据的地址，指向任意类型对象。无论是整数、浮点数、字符或数组、结构体等类型都可以用void指针指向。表现在代码中就是：<strong>可以将任意类型指针(地址)赋值给void指针，这个过程一般是没有风险的。</strong>如下列代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">void</span>* void_ptr = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void指针转换成其它类型指针,在C++语法中必须加上显式类型转换说明</span></span><br><span class="line"><span class="comment">// 但C语言支持void指针隐式类型转换成各种其它指针类型，所以这个强转语法可加可不加</span></span><br><span class="line"><span class="comment">// float* float_ptr = (float*)void_ptr;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的类型转换</span></span><br><span class="line"><span class="type">float</span>* float_ptr = void_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用产生未定义行为</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, *float_ptr);</span><br></pre></td></tr></table></figure>
<p>关于通用指针类型转换成其它指针类型，C语言和C++在语法上会有明显差别：</p>
<ul>
<li><p>C语言更灵活允许隐式的类型转换，所以强转语法可加可不加。</p></li>
<li><p>C++则不支持这类隐式类型转换，必须要加上强转的语法，否则编译无法通过。</p></li>
</ul>
<hr />
<p>在C语言中，想要在堆上动态分配内存空间，主要依赖三个函数来完成，它们都声明在<strong>头文件<code>&lt;stdlib.h&gt;</code></strong>当中：</p>
<ol type="1">
<li>malloc</li>
<li>calloc</li>
<li>realloc</li>
</ol>
<hr />
<h2 id="内存分配函数malloc">内存分配函数malloc</h2>
<p><strong>函数全名：</strong>memory allocation</p>
<p><strong>函数声明：</strong><code>void* malloc(size_t size);</code></p>
<p>函数作用：</p>
<ul>
<li><p><strong>此函数会在堆空间上分配一片连续的，size个字节大小的内存块</strong></p></li>
<li><p><strong>此函数不会对内存块中的数据进行初始化，内存块中的数据是随机未定义的。</strong></p></li>
</ul>
<p><strong>函数返回值：</strong></p>
<ul>
<li><p>如果分配成功，此函数会返回指向该<strong>内存块地址(首字节地址)</strong>的指针。<strong>注意返回的指针类型是void指针，在操作之前需要进行转换。</strong></p></li>
<li><p>如果分配失败，此函数会返回一个空指针(NULL)。</p></li>
</ul>
<h3 id="内存泄漏">内存泄漏</h3>
<p>以往我们创建数组，创建结构体都是在栈上完成的，它们是栈数组、栈结构体，它们的内存空间都是由栈自动管理完成的。</p>
<p>但使用动态内存分配函数创建的数组、结构体都被存储在堆上，栈上存储的只不过是它的指针，如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311091105358.png" alt="栈上指针指向堆上内存区域-示意图" style="zoom: 33%;" />
</div>
<p>堆上存储的数据由程序员手动管理生命周期，手动申请内存资源，也需要手动释放内存空间。</p>
<p><strong>内存泄漏是指程序在运行过程中，未能适时释放不再使用的内存区域，导致这部分内存在程序的生命周期内始终无法被重用。</strong></p>
<p>内存泄漏在短时间内可能对程序而言，不是巨大的、致命的风险，但：长时间运行或频繁执行的程序中如果存在内存泄漏，随着时间的推移，被泄漏的内存累积会越来越多，最终可能导致程序运行缓慢甚至崩溃，特别是在内存有限的系统中。</p>
<hr />
<h2 id="内存释放函数free">内存释放函数free</h2>
<p>为了避免内存泄漏，在确定动态分配的内存不再使用后，要及时调用free函数释放它。</p>
<p><strong>函数声明：</strong><code>void free(void *ptr);</code></p>
<p><strong>函数参数：</strong>必须是堆上申请内存块的地址(<strong>首字节地址</strong>)，不能传递别的指针，否则会引发未定义行为。</p>
<p><strong>函数功能：</strong></p>
<ol type="1">
<li><strong>free函数并不会修改它所释放的内存区域中存储的任何数据。</strong>free
的作用仅仅是告诉操作系统这块内存不再被使用了，可以将其标记为可用状态，以供将来的内存分配请求使用。</li>
<li>释放后的内存区域中的数据一般仍然会继续存在，直到被下一次的内存分配操作覆盖。当然即便free前的原始数据一直存在未被覆盖，这片内存区域也不再可用了，因为你不知道什么时候数据就会被覆盖掉了。</li>
<li><strong>free函数不会修改传入指针指向的内容，更不会对实参指针本身做任何修改。</strong></li>
</ol>
<p>free函数调用后，指针指向的内存块就被释放了。但<strong>free函数不会改变传入的实参指针本身</strong>，所以free后的实参指针就变成了指向一片已释放区域的指针。这就是<strong>“悬空指针”</strong>，悬空指针是野指针的一种特例，使用悬空指针同样会引发未定义行为。</p>
<p><strong>为了避免悬空指针为程序安全带来隐患，推荐在free掉指针指向的内存块后，及时将指针置为空指针。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码,p是一个指针类型</span></span><br><span class="line">p = <span class="built_in">malloc</span>(...);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ol type="1">
<li><p><strong>正确传参free函数。</strong>free函数需要传入指向动态分配内存块首字节的指针，free之前不妨检查指针是否已被移动。</p></li>
<li><p><strong>在free内存块后，建议立刻将指针设置为NULL。</strong>这样可以规避一些常见的问题：</p>
<ul>
<li><p>避免了”double
free”的风险。对空指针调用<code>free函数</code>是安全的，它不会有任何效果。</p></li>
<li><p>减少悬空指针出现的风险。解引用空指针导致程序崩溃，比悬空指针带来的未定义行为要更容易检测和修正。</p></li>
</ul></li>
<li><p><strong>慎重改变堆区指针的指向。</strong>指向堆区域的指针，如果需要改变它的指向，在改变之前应当考虑指向的内存块是否需要free。</p></li>
<li><p><strong>多函数共同管理同一块内存区域时，应严格遵循单一原则。</strong>尤其是，哪个函数用于分配内存，哪个函数用于free释放内存，这两个函数一定要明确单一的职责。</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆上动态分配内存拼接两个字符串</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">dynamic_strcat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* prefix, <span class="type">const</span> <span class="type">char</span>* suffix)</span> &#123;</span><br><span class="line"><span class="comment">// 计算拼接后字符串的长度</span></span><br><span class="line"> <span class="type">int</span> new_str_len = <span class="built_in">strlen</span>(prefix) + <span class="built_in">strlen</span>(suffix);</span><br><span class="line"><span class="type">char</span> *new_str = <span class="built_in">malloc</span>(new_str_len + <span class="number">1</span>);    <span class="comment">// char在各平台上长度都是1，所以不用乘了</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (new_str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;ERROR: malloc failed in dynamic_strcat!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 长度是精确计算得出的，不用担心越界访问</span></span><br><span class="line"> <span class="built_in">strcat</span>(<span class="built_in">strcpy</span>(new_str, prefix), suffix);</span><br><span class="line"><span class="keyword">return</span> new_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="type">char</span> str1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot; world!&quot;</span>;</span><br><span class="line"> <span class="type">char</span>* result_str = dynamic_strcat(str1, str2);  <span class="comment">// 注意只要涉及动态内存分配，一律用指针类型。这里不能用数组类型</span></span><br><span class="line"><span class="built_in">puts</span>(result_str);</span><br><span class="line"> <span class="comment">// 现在不再使用result字符串了，不要忘记free它</span></span><br><span class="line"><span class="built_in">free</span>(result_str);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="清零内存分配函数calloc">清零内存分配函数calloc</h2>
<p><strong>函数全名：</strong>cleared
allocation，该函数的最大特点是分配内存空间时会<strong>自动初始化0值</strong>。</p>
<p><strong>函数声明：</strong>
<code>void* calloc(size_t num, size_t size);</code>。</p>
<p><strong>函数参数：</strong></p>
<ol type="1">
<li><code>num</code> 表示要分配的元素数量</li>
<li><code>size</code> 表示每个元素的内存大小</li>
</ol>
<p>此函数也会在堆空间上分配一片连续的内存空间，但不同的是，它基于元素的个数以及每个元素的大小来进行内存分配，所以calloc常用于在堆上分配<strong>数组</strong>的内存空间。</p>
<p><strong>函数返回值：</strong>返回值在分配成功和失败时，和malloc是一致的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 分配一个长度为10的整数数组</span></span><br><span class="line"> <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> *arr = <span class="built_in">calloc</span>(len, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span>* p = arr;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++);   <span class="comment">// 此时数组中的元素都具有0值，而不是随机未定义的</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用完毕，不要忘记free</span></span><br><span class="line"> <span class="built_in">free</span>(arr);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总得来说，推荐在<strong>动态分配数组内存空间</strong>时，尤其是需要将内存空间初始化为0值时，<strong>使用calloc函数</strong>。</p>
<hr />
<h2 id="内存重分配函数realloc">内存重分配函数realloc</h2>
<p><strong>函数全名：</strong>reallocation，表示内存重新分配。</p>
<p><strong>函数声明：</strong><code>void* realloc(void* ptr, size_t new_size);</code></p>
<p><strong>函数参数：</strong></p>
<ol type="1">
<li><code>ptr</code>：指向原来已分配内存的内存块。</li>
<li><code>new_size</code>：新的内存块大小。</li>
</ol>
<p><strong>函数功能：</strong></p>
<p>该函数根据参数取值的不同，可能表现为malloc或free函数的行为：</p>
<ol type="1">
<li><strong>如果ptr指针是一个空指针，那么该函数的行为和malloc一致——分配new_size字节的内存空间，并且返回该内存块的指针。</strong></li>
<li><strong>如果new_size的取值为0，那么该函数的行为就是free函数，会释放ptr指向的内存块。</strong></li>
</ol>
<p>如果没有出现上述两种特殊情况，realloc用于重新调整已分配内存块的大小(也就是ptr指针指向的已分配内存块的大小)：</p>
<ol type="1">
<li>当new_size的取值和已分配的内存块大小一致时，此函数不会做任何操作。</li>
<li>当new_size的取值比已分配的内存块小时，会在旧内存块的<strong>尾部(高地址)</strong>截断，被截断抛弃的内存块会被自动释放。</li>
<li>当new_size的取值比已分配的内存块大时(新内存块比旧内存块大时)，会尽可能地尝试原地扩大旧内存块(这样效率高)；</li>
<li>如果无法原地进行扩大，则会在<strong>别处</strong>申请空间分配new_size大小的新内存块，并将旧内存块中的数据全部复制进去后，将<strong>旧内存块自动释放</strong>。</li>
<li>不管采用哪种方式扩展旧内存块，<strong>新扩展部分</strong>的内存区域都不会初始化，仍只<strong>具有随机值</strong>。</li>
</ol>
<p><strong>函数返回值：</strong></p>
<p>如果realloc函数分配内存空间成功，它会返回指向新内存块的指针，<strong>若失败，仍会返回空指针，且不会改变旧内存块。</strong></p>
<p>总之，realloc函数适用于调整已分配内存块的大小，特别是在<strong>动态数组或数据结构的大小需要在程序运行时增加或减少时</strong>使用。</p>
<p><strong>惯用法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p和arr_p指针类型一致</span></span><br><span class="line">p = <span class="built_in">realloc</span>(arr_p, new_size);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">   <span class="comment">// 分配失败处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码运行到这里,realloc分配内存成功</span></span><br><span class="line">arr_p = p;</span><br></pre></td></tr></table></figure>
<p>这样写既避免了arr_p成为悬空指针，也不会因为realloc分配失败导致内存泄漏。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言之文件流常用API</title>
    <url>/lang-c/c-file-stream-api/</url>
    <content><![CDATA[<p>本文总结了在C语言中与文件流相关的标准库函数。</p>
<span id="more"></span>
<hr />
<h2 id="文件流常用api">文件流常用API</h2>
<p>使用下列文件流API需要包含头文件<code>stdio.h</code>。</p>
<div data-align="center">
<table>
<thead>
<tr>
<th style="text-align:left">
</th>
<th style="text-align:left">
函数
</th>
<th style="text-align:left">
作用
</th>
<th style="text-align:left">
注意事项
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left" rowspan="2">
打开或关闭文件流
</td>
<td style="text-align:left">
<code>fopen</code>
</td>
<td style="text-align:left">
打开文件，返回指向FILE的指针
</td>
<td style="text-align:left">
需要指定模式（如“r”, “w”, “a”等），并处理可能的文件打开错误
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fclose</code>
</td>
<td style="text-align:left">
关闭文件流，释放流资源
</td>
<td style="text-align:left">
确保每个打开的文件流最终都被关闭，避免资源泄露
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
读写二进制文件流
</td>
<td style="text-align:left">
<code>fread</code>
</td>
<td style="text-align:left">
从文件流中读取数据
</td>
<td style="text-align:left">
需要检查返回值以确定读取的数据量和是否遇到错误或EOF
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fwrite</code>
</td>
<td style="text-align:left">
向文件流中写入数据
</td>
<td style="text-align:left">
需要检查返回值以确保数据正确写入
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
逐字符读写文本文件流
</td>
<td style="text-align:left">
<code>fgetc</code>
</td>
<td style="text-align:left">
从文件流中读取下一个字符
</td>
<td style="text-align:left">
在达到文件末尾或出现错误时返回EOF
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fputc</code>
</td>
<td style="text-align:left">
将一个字符写入文件流
</td>
<td style="text-align:left">
返回写入的字符，若出现错误则返回EOF
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
逐行读写文本文件流
</td>
<td style="text-align:left">
<code>fgets</code>
</td>
<td style="text-align:left">
从文件流中读取字符串（一行）
</td>
<td style="text-align:left">
确保正确处理缓冲区长度和行尾字符
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fputs</code>
</td>
<td style="text-align:left">
将字符串（不包括NUL终止符）写入文件流
</td>
<td style="text-align:left">
不会自动添加换行符，需手动处理
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
格式化读写文本文件流
</td>
<td style="text-align:left">
<code>fscanf</code>
</td>
<td style="text-align:left">
从文件流中格式化读取数据
</td>
<td style="text-align:left">
与<code>scanf</code>类似，但从文件流读取
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fprintf</code>
</td>
<td style="text-align:left">
格式化输出到文件流
</td>
<td style="text-align:left">
类似于<code>printf</code>，但输出到文件流
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="2">
文件流状态检查
</td>
<td style="text-align:left">
<code>feof</code>
</td>
<td style="text-align:left">
检查文件流的EOF标志
</td>
<td style="text-align:left">
通常用于循环读取数据时判断文件是否结束
</td>
</tr>
<tr>
<td style="text-align:left">
<code>ferror</code>
</td>
<td style="text-align:left">
检查文件流的错误指示器
</td>
<td style="text-align:left">
用于错误处理和调试
</td>
</tr>
<tr>
<td style="text-align:left" rowspan="3">
文件定位
</td>
<td style="text-align:left">
<code>ftell</code>
</td>
<td style="text-align:left">
返回文件流的当前文件位置指示器
</td>
<td style="text-align:left">
配合<code>fseek</code>可实现文件的随机访问
</td>
</tr>
<tr>
<td style="text-align:left">
<code>fseek</code>
</td>
<td style="text-align:left">
设置文件流的文件位置指示器
</td>
<td style="text-align:left">
可用于移动文件指针到特定位置
</td>
</tr>
<tr>
<td style="text-align:left">
<code>rewind</code>
</td>
<td style="text-align:left">
将文件流的文件位置指示器重置到文件开头
</td>
<td style="text-align:left">
等同于<code>fseek(stream, 0, SEEK_SET)</code>
</td>
</tr>
<tr>
<td style="text-align:left">
刷新输出缓冲区
</td>
<td style="text-align:left">
<code>fflush</code>
</td>
<td style="text-align:left">
清空文件流的输出缓冲区
</td>
<td style="text-align:left">
常用于确保所有输出已经从缓冲区写入文件
</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>文件流</tag>
      </tags>
  </entry>
  <entry>
    <title>有符号整数的三种编码方式：原码、反码和补码</title>
    <url>/computer-organization/code-original-inverse-complement/</url>
    <content><![CDATA[<p>在计算机中，<strong>原码、反码、补码</strong>
是用于表示有符号整数的三种编码方式，主要用于解决二进制数的
<strong>正负表示</strong> 和 <strong>加减运算</strong>
问题。它们的核心区别在于 <strong>符号位的处理</strong> 和
<strong>负数的表示方法</strong>。</p>
<span id="more"></span>
<hr />
<h2 id="原码sign-magnitude">原码（Sign-Magnitude）</h2>
<h3 id="定义">定义</h3>
<ul>
<li>最高位（最左边的一位）表示符号：
<ul>
<li><strong><code>0</code> 表示正数</strong>（如 <code>+5</code>）</li>
<li><strong><code>1</code> 表示负数</strong>（如 <code>-5</code>）</li>
</ul></li>
<li>其余位表示数值的绝对值。</li>
</ul>
<h3 id="示例8位二进制">示例（8位二进制）</h3>
<table>
<thead>
<tr>
<th>十进制</th>
<th>原码表示（8位）</th>
</tr>
</thead>
<tbody>
<tr>
<td>+5</td>
<td><code>0000 0101</code></td>
</tr>
<tr>
<td>-5</td>
<td><code>1000 0101</code></td>
</tr>
</tbody>
</table>
<h3 id="特点">特点</h3>
<p>✅ <strong>直观</strong>：和人类书写习惯一致（正负号+数值）。<br />
❌ <strong>问题</strong>：</p>
<ol type="1">
<li><strong><code>+0</code> 和 <code>-0</code> 不唯一</strong>：
<ul>
<li><code>+0</code> = <code>0000 0000</code></li>
<li><code>-0</code> = <code>1000 0000</code>（计算机无法区分）</li>
</ul></li>
<li><strong>加减运算复杂</strong>：
<ul>
<li>需要额外判断符号位，硬件实现麻烦。</li>
</ul></li>
</ol>
<hr />
<h2 id="反码ones-complement">反码（Ones’ Complement）</h2>
<h3 id="定义-1">定义</h3>
<ul>
<li><strong>正数</strong>：和原码相同。</li>
<li><strong>负数</strong>：在原码基础上，<strong>符号位不变，数值位取反</strong>（<code>0</code>→<code>1</code>，<code>1</code>→<code>0</code>）。</li>
</ul>
<h3 id="示例8位二进制-1">示例（8位二进制）</h3>
<table>
<thead>
<tr>
<th>十进制</th>
<th>反码表示（8位）</th>
</tr>
</thead>
<tbody>
<tr>
<td>+5</td>
<td><code>0000 0101</code></td>
</tr>
<tr>
<td>-5</td>
<td><code>1111 1010</code></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 63%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">十进制运算</th>
<th style="text-align: center;">反码计算</th>
<th style="text-align: center;">反码计算结果（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 +（-1）= 0</td>
<td style="text-align: center;">[0000 0001]反 + [1111 1110]反 = [1111
1111]反 = [1000 0000]原</td>
<td style="text-align: center;">-0</td>
</tr>
<tr>
<td style="text-align: center;">1 +（-2）= -1</td>
<td style="text-align: center;">[0000 0001]反 + [1111 1101]反 = [1111
1110]反 = [1000 0001]原</td>
<td style="text-align: center;">-1</td>
</tr>
<tr>
<td style="text-align: center;">-1 +（2）= 1</td>
<td style="text-align: center;">[1111 1110]反 + [0000 0010]反 = [0000
0000]反<strong>（溢出）</strong> = [0000 0000]原</td>
<td style="text-align: center;">0（<strong>溢出归0</strong>）</td>
</tr>
</tbody>
</table>
<p>从上表可以看出，如果用反码直接进行计算，虽然有所改善，但仍有问题，所以计算机中的运算也不能直接用反码。</p>
<h3 id="特点-1">特点</h3>
<p><strong>仍然存在 <code>+0</code> 和 <code>-0</code> 问题</strong></p>
<ul>
<li><code>+0</code> = <code>0000 0000</code></li>
<li><code>-0</code> = <code>1111 1111</code>（仍然无意义）</li>
</ul>
<p><strong>运算仍需调整</strong>：</p>
<ul>
<li>加减法后可能需要 <strong>“循环进位”</strong>（如
<code>1 + (-1)</code> = <code>0000 0001</code> + <code>1111 1110</code>
= <code>1111 1111</code>（<code>-0</code>），需要额外加 <code>1</code>
修正）。</li>
</ul>
<hr />
<h2 id="补码twos-complement现代计算机标准">补码（Two’s
Complement）⭐（现代计算机标准）</h2>
<h3 id="定义-2">定义</h3>
<ul>
<li><strong>正数</strong>：和原码相同。</li>
<li><strong>负数</strong>：在反码基础上 <strong>+1</strong>（即
<code>原码取反 + 1</code>）。</li>
</ul>
<h3 id="示例8位二进制-2">示例（8位二进制）</h3>
<table>
<thead>
<tr>
<th>十进制</th>
<th>补码表示（8位）</th>
</tr>
</thead>
<tbody>
<tr>
<td>+5</td>
<td><code>0000 0101</code></td>
</tr>
<tr>
<td>-5</td>
<td><code>1111 1011</code></td>
</tr>
</tbody>
</table>
<h3 id="计算--5-的补码">计算 <code>-5</code> 的补码</h3>
<ol type="1">
<li><code>+5</code> 原码 = <code>0000 0101</code></li>
<li><strong>取反</strong> = <code>1111 1010</code>（反码）</li>
<li><strong>+1</strong> = <code>1111 1011</code>（补码）</li>
</ol>
<p>举个例子，如果是8位的二进制数：</p>
<blockquote>
<p>[+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补</p>
<p>[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补</p>
<p>[-2] = [1000 0010]原 = [1111 1101]反 = [1111 1110]补</p>
</blockquote>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 63%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">十进制运算</th>
<th style="text-align: center;">补码计算</th>
<th style="text-align: center;">补码计算结果（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 +（-1）= 0</td>
<td style="text-align: center;">[0000 0001]补 + [1111 1111]补 = [0000
0000]补 = [0000 0000]原</td>
<td style="text-align: center;">0（<strong>溢出位舍弃</strong>）</td>
</tr>
<tr>
<td style="text-align: center;">1 +（-2）= -1</td>
<td style="text-align: center;">[0000 0001]补 + [1111 1110]补 = [1111
1111]补 = [1111 1110]反 = [1000 0001]原</td>
<td style="text-align: center;">-1</td>
</tr>
<tr>
<td style="text-align: center;">-1 +（2）= 1</td>
<td style="text-align: center;">[1111 1111]补 + [0000 0010]补 = [0000
0001]补 = [0000 0001]原</td>
<td style="text-align: center;">1（<strong>溢出位舍弃</strong>）</td>
</tr>
</tbody>
</table>
<p>从上表可以看出，如果使用补码进行计算，就可以正常的进行加法算术运算了。</p>
<h3 id="特点-2">特点</h3>
<p>✅ <strong>解决所有问题</strong>：</p>
<ol type="1">
<li><p><strong><code>+0</code> 和 <code>-0</code> 统一</strong>：</p>
<ul>
<li><code>+0</code> = <code>0000 0000</code></li>
<li><code>-0</code> ：原码 <code>1000 0000</code> → 反码
<code>1111 1111</code> → 补码 <code>0000 0000</code>（和 <code>+0</code>
相同）。</li>
</ul></li>
<li><p><strong>加减法直接运算</strong>：</p>
<ul>
<li><code>5 + (-3)</code> = <code>0000 0101</code> +
<code>1111 1101</code> =
<code>0000 0010</code>（<code>2</code>，正确）。</li>
</ul></li>
<li><p><strong>表示范围更大</strong>：</p>
<ul>
<li>8位补码范围：<code>-128</code>（<code>1000 0000</code>）~
<code>+127</code>（<code>0111 1111</code>），比原码/反码多一个数（<code>-128</code>）。</li>
</ul></li>
</ol>
<p>那么至此，总结两个非常重要的结论：</p>
<ol type="1">
<li><strong>正数的原码反码补码是一致的，负数的反码是原码除符号位取反，补码是反码+1。</strong></li>
<li><strong>计算机中有符号整数的存储方式都是以补码的形式存储的，运算也是以补码的形式计算的。</strong></li>
</ol>
<hr />
<h2 id="三种编码对比8位二进制">三种编码对比（8位二进制）</h2>
<table>
<thead>
<tr>
<th>十进制</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
</tr>
</thead>
<tbody>
<tr>
<td>+5</td>
<td><code>0000 0101</code></td>
<td><code>0000 0101</code></td>
<td><code>0000 0101</code></td>
</tr>
<tr>
<td>-5</td>
<td><code>1000 0101</code></td>
<td><code>1111 1010</code></td>
<td><code>1111 1011</code></td>
</tr>
<tr>
<td>+0</td>
<td><code>0000 0000</code></td>
<td><code>0000 0000</code></td>
<td><code>0000 0000</code></td>
</tr>
<tr>
<td>-0</td>
<td><code>1000 0000</code></td>
<td><code>1111 1111</code></td>
<td><code>0000 0000</code></td>
</tr>
<tr>
<td>-128</td>
<td>无法表示</td>
<td>无法表示</td>
<td><code>1000 0000</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="为什么计算机使用补码">为什么计算机使用补码</h2>
<blockquote>
<ol type="1">
<li><strong>统一 <code>+0</code> 和
<code>-0</code></strong>，避免歧义。</li>
<li><strong>加减法可以直接运算</strong>，无需额外判断符号。</li>
<li><strong>硬件实现简单</strong>，CPU 只需加法器，无需额外电路。</li>
<li><strong>表示范围更大</strong>（如 8 位补码可表示
<code>-128</code>~<code>127</code>，而原码/反码只能
<code>-127</code>~<code>127</code>）。</li>
</ol>
</blockquote>
<hr />
<h2 id="常见问题">常见问题</h2>
<h3 id="补码-1000-0000-代表多少">补码 <code>1000 0000</code>
代表多少</h3>
<ul>
<li>在 8 位补码中，<code>1000 0000</code> 表示
<code>-128</code>（没有对应的原码/反码）。</li>
</ul>
<h3 id="补码的运算溢出怎么办">补码的运算溢出怎么办</h3>
<ul>
<li>例如 <code>127 + 1</code> = <code>0111 1111</code> +
<code>0000 0001</code> =
<code>1000 0000</code>（<code>-128</code>，溢出）。</li>
<li>CPU 会设置 <strong>溢出标志位（OF）</strong>，由程序员处理。</li>
</ul>
<hr />
<h2 id="总结"><strong>总结</strong></h2>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 31%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr>
<th>编码</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>原码</strong></td>
<td>直观</td>
<td><code>±0</code> 问题，运算复杂</td>
<td>早期计算机（已淘汰）</td>
</tr>
<tr>
<td><strong>反码</strong></td>
<td>改进负数表示</td>
<td><code>±0</code> 仍存在，运算需调整</td>
<td>过渡方案（基本不用）</td>
</tr>
<tr>
<td><strong>补码</strong></td>
<td>无 <code>±0</code> 问题，运算简单</td>
<td>负数计算稍复杂</td>
<td><strong>现代计算机标准</strong></td>
</tr>
</tbody>
</table>
<p>补码是计算机存储和处理有符号整数的
<strong>最优方案</strong>，理解它对于学习
<strong>计算机组成原理、编程（如整数溢出）、逆向工程</strong>
都至关重要！</p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 的基本概念（一）</title>
    <url>/lang-latex/notes-lshort/01-basic-concepts/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>欢迎使用 <span
class="math inline">\(\LaTeX{}\)</span>！本文开头介绍了<span
class="math inline">\(\LaTeX{}\)</span>的来源，然后介绍了<span
class="math inline">\(\LaTeX{}\)</span>源代码的写法，编译<span
class="math inline">\(\LaTeX{}\)</span>源代码生成文档的方法，以及理解接下来的章节的一些必要知识。</p>
<span id="more"></span>
<hr />
<h2 id="概述">概述</h2>
<h3 id="tex"><span class="math inline">\(\TeX\)</span></h3>
<p><span class="math inline">\(\TeX{}\)</span> 是高德纳 (Donald
E.~Knuth) 为排版文字和数学公式而开发的软件。1977
年，正在编写《计算机程序设计艺术》的高德纳意识到每况愈下的排版质量将影响其著作的发行，为扭转这种状况，他着手开发
<span
class="math inline">\(\TeX{}\)</span>，发掘当时刚刚用于出版工业的数字印刷设备的潜力。1982
年，高德纳发布 <span class="math inline">\(\TeX{}\)</span>
排版引擎，而后在 1989 年又为更好地支持 8-bit
字符和多语言排版而予以改进。<span class="math inline">\(\TeX{}\)</span>
以其卓越的稳定性、跨平台能力和几乎没有 bug
的特性而著称。它的版本号不断趋近于 <span
class="math inline">\(\pi\)</span>，当前为 3.141592653。</p>
<h3 id="latex"><span class="math inline">\(\LaTeX{}\)</span></h3>
<p><span class="math inline">\(\LaTeX{}\)</span> 是一种使用 <span
class="math inline">\(\TeX{}\)</span>
程序作为排版引擎的格式，可以粗略地将它理解成是对 <span
class="math inline">\(\TeX{}\)</span> 的一层封装。 <span
class="math inline">\(\LaTeX{}\)</span>
最初的设计目标是分离内容与格式，以便作者能够专注于内容创作而非版式设计，并能以此得到高质量排版的作品。<span
class="math inline">\(\LaTeX{}\)</span> 起初由 Leslie Lamport
博士开发，目前由 <span class="math inline">\(\LaTeX{}\)</span> 工作组<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>进行维护。</p>
<h3 id="latex-的优缺点"><span class="math inline">\(\LaTeX{}\)</span>
的优缺点</h3>
<p><span class="math inline">\(\LaTeX{}\)</span> 的一些优点：</p>
<blockquote>
<ul>
<li>具有专业的排版输出能力，产生的文档看上去就像“印刷品”一样。</li>
<li>具有方便而强大的数学公式排版能力，无出其右者。</li>
<li>绝大多数时候，用户只需专注于一些组织文档结构的基础命令，无需（或很少）操心文档的版面设计。</li>
<li>很容易生成复杂的专业排版元素，如脚注、交叉引用、参考文献、目录等。</li>
<li>强大的可扩展性。世界各地的人开发了数以千计的 <span
class="math inline">\(\LaTeX{}\)</span> 宏包用于补充和扩展 <span
class="math inline">\(\LaTeX{}\)</span> 的功能。</li>
<li>能够促使用户写出结构良好的文档——而这也是 <span
class="math inline">\(\LaTeX{}\)</span> 存在的初衷。</li>
<li><span class="math inline">\(\LaTeX{}\)</span> 和 <span
class="math inline">\(\TeX{}\)</span>
及相关软件是跨平台、免费、开源的。</li>
</ul>
</blockquote>
<p><span class="math inline">\(\LaTeX{}\)</span> 的缺点：</p>
<blockquote>
<ul>
<li>入门门槛高。</li>
<li>不容易排查错误。<span class="math inline">\(\LaTeX{}\)</span>
作为一个依靠编写代码工作的排版工具，其使用的宏语言比 C++ 或 Python
等语言在错误排查方面困难得多。它虽然能够提示错误，但不提供调试的机制，有时错误提示还很难理解。</li>
<li>不容易定制样式。<span class="math inline">\(\LaTeX{}\)</span>
提供了一个基本上良好的样式，为了让用户不去关注样式而专注于文档结构。但如果想要改进
<span class="math inline">\(\LaTeX{}\)</span>
生成的文档样式则是十分困难的。</li>
<li>相比“所见即所得”的模式有一些不便，为了查看生成文档的效果，用户总要不停地编译。</li>
</ul>
</blockquote>
<h2 id="hello-world">Hello, World</h2>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">``Hello world!&#x27;&#x27; from <span class="keyword">\LaTeX</span>.</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先介绍如何编译使用这份源代码，在后续小节中再介绍源代码的细节。你可以将这份源代码保存为helloworld.tex，而后编译。具体来说:</p>
<ul>
<li><p>如果使用TeXworks 或TeXstudio
等编辑器，可以使用编辑器提供的“编译”或“排版”按钮。建议使用 pdfLaTeX 或
XeLaTeX 作为默认的编译方式。</p></li>
<li><p>如果使用命令行方式进行编译，打开终端，在源代码所在的目录下输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pdflatex helloworld</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xelatex helloworld</span><br></pre></td></tr></table></figure>
<p>如果编译成功，可以在helloworld.tex 所在目录看到生成的helloworld.pdf
以及一些其它文件。</p></li>
</ul>
<p>下面是排版中文的一个最简示例。编译的方式与上一份源代码相同，但需使用
XeLaTeX编译方式。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">“你好，世界！”来自<span class="keyword">\LaTeX</span>&#123;&#125; 的问候。</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="latex-命令和代码结构"><span
class="math inline">\(\LaTeX{}\)</span> 命令和代码结构</h2>
<p><span class="math inline">\(\LaTeX{}\)</span>
的源代码为文本文件。这些文本除了文字本身，还包括各种命令，用在排版公式、划分文档结构、控制样式等等不同的地方。</p>
<h3 id="latex-命令和环境"><span class="math inline">\(\LaTeX{}\)</span>
命令和环境</h3>
<p><span class="math inline">\(\LaTeX{}\)</span> 中命令以反斜线
<code>\</code> 开头，为以下两种形式之一：</p>
<ul>
<li><p>反斜线和后面的一串字母，如
<code>\&#123;LaTeX&#125;</code>。它们以任意非字母符号（空格、数字、标点等）为界限。</p></li>
<li><p>反斜线和后面的单个非字母符号，如 <code>\$</code>。</p></li>
</ul>
<p>注意 <span class="math inline">\(\LaTeX{}\)</span>
命令<strong>对大小写敏感</strong>，比如输入 <code>\&#123;LaTeX&#125;</code>
命令可生成错落有致的 <span class="math inline">\(\LaTeX{}\)</span>
字母组合，但输入 <code>\&#123;Latex&#125;</code> 或 <code>\&#123;LaTex&#125;</code>
什么都得不到，还会报错。</p>
<p>字母形式的 <span class="math inline">\(\LaTeX{}\)</span>
命令忽略其后的所有连续空格。如果要人为引入空格，需要在命令后面加一对花括号阻止其忽略空格:
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250113150429995.png"
alt="image-20250113150429995" /></p>
<p>一些 <span class="math inline">\(\LaTeX{}\)</span>
命令可以接收一些参数，参数的内容会影响命令的效果。<span
class="math inline">\(\LaTeX{}\)</span>
的参数分为可选参数和必选参数。可选参数以方括号 [ 和 ]
包裹；必选参数一般以花括号 { 和 } 包裹<a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>。还有些命令可以带一个星号
*，带星号和不带星号的命令效果有一定差异。初次接触这些概念时，可以粗略地把星号看作一种特殊的可选参数。</p>
<p><span class="math inline">\(\LaTeX{}\)</span>
中还包括<strong>环境</strong>，用以令一些效果在局部生效，或是生成特殊的文档元素。<span
class="math inline">\(\LaTeX{}\)</span> 环境的用法为一对命令
<code>\begin</code> 和 <code>\end</code>：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;&lt;environment name&gt;&#125;[&lt;optional arguments&gt;]&#123;&lt;mandatory arguments&gt;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;&lt;environment name&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>有些命令（如
<code>\bfseries</code>）会对其后所有内容产生作用。若要限制其作用范围，则需要使用<strong>分组</strong>。<span
class="math inline">\(\LaTeX{}\)</span> 使用一对花括号{ }
作为分组，在分组中使用的命令被限制在分组内，不会影响到分组外的内容<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>。上文提到的 <span
class="math inline">\(\LaTeX{}\)</span>
环境隐含了一个分组，在环境中的命令被包裹在分组内。</p>
<h3 id="latex-源代码结构"><span class="math inline">\(\LaTeX{}\)</span>
源代码结构</h3>
<p><span class="math inline">\(\LaTeX{}\)</span> 源代码以一个
<code>\&#123;documentclass&#125;</code>
命令作为开头，它指定了文档使用的<strong>文档类</strong>。<code>document</code>
环境当中的内容是文档正文。 在 <code>\documentclass</code> 和
<code>\begin&#123;document&#125;</code> 之间的位置称为<strong>导言区</strong>。
在导言区中常会使用 <code>\usepackage&#123;&#125;</code>
命令调用<strong>宏包</strong>，还会进行文档的全局设置。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;...&#125;  <span class="comment">% ... 为某文档类</span></span><br><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;comment&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">% 正文内容</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br><span class="line"><span class="comment">% 此后内容会被忽略</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="latex-宏包和文档类"><span
class="math inline">\(\LaTeX{}\)</span> 宏包和文档类</h2>
<h3 id="文档类">文档类</h3>
<p><strong>文档类</strong>规定了 <span
class="math inline">\(\LaTeX{}\)</span>
源代码所要生成的文档的性质——普通文章、书籍、演示文稿、个人简历等。<span
class="math inline">\(\LaTeX{}\)</span>
源代码的开头须用<code>\documentclass</code>指定文档类：
<code>\documentclass[&lt;options&gt;]&#123;&lt;class-name&gt;&#125;</code>
其中<code>&lt;class-name&gt;</code>为文档类的名称，如 <span
class="math inline">\(\LaTeX{}\)</span> 提供的
<code>article</code>、<code>report</code>、<code>book</code>，在其基础上派生的一些文档类，如支持中文排版的
<code>ctexart</code>、<code>ctexrep</code>、<code>ctexbook</code>，或者有其它功能的文档类，如
<code>moderncv</code>、<code>beamer</code> 等。<span
class="math inline">\(\LaTeX{}\)</span>
提供的基础文档类见下表，其中前三个习惯上称为“标准文档类”。</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">文档类</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">article</td>
<td
style="text-align: left;">文章格式的文档类，广泛用于科技论文、报告、说明文档等。</td>
</tr>
<tr>
<td style="text-align: left;">report</td>
<td
style="text-align: left;">长篇报告格式的文档类，具有章节结构，用于综述、长篇论文、简单的书籍等。</td>
</tr>
<tr>
<td style="text-align: left;">book</td>
<td
style="text-align: left;">书籍文档类，包含章节结构和前言、正文、后记等结构。</td>
</tr>
<tr>
<td style="text-align: left;">proc</td>
<td style="text-align: left;">基于<code>article</code>
文档类的一个简单的学术文档模板。</td>
</tr>
<tr>
<td style="text-align: left;">slides</td>
<td style="text-align: left;">幻灯格式的文档类，使用无衬线字体。</td>
</tr>
<tr>
<td style="text-align: left;">minimal</td>
<td
style="text-align: left;">一个极其精简的文档类，只设定了纸张大小和基本字号，用作代码测试的最小工作示例。</td>
</tr>
</tbody>
</table>
<p>可选参数 <code>&lt;options&gt;</code>
为文档类指定选项，以全局地规定一些排版的参数，如字号、纸张大小、单双面等等。比如调用
<code>article</code> 文档类排版文章，指定纸张为 A4 大小，基本字号为
11pt，双面排版：
<code>\documentclass[11pt,twoside,a4paper]&#123;article&#125;</code></p>
<p><span class="math inline">\(\LaTeX{}\)</span>
的三个标准文档类可指定的选项包括：</p>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">options</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span class="math inline">\(\texttt{10pt,
11pt, 12pt}\)</span></td>
<td style="text-align: left;">指定文档的基本字号。默认为 <span
class="math inline">\(\texttt{10pt}\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{a4paper,letterpaper,...}\)</span></td>
<td style="text-align: left;">指定纸张大小，默认为美式信纸（<span
class="math inline">\(8.5\,\text{in}\times11\,\text{in}\)</span>大约相当于
<span
class="math inline">\(21.6\,\text{cm}\times28.0\,\text{cm}\)</span>）。可指定选项还包括
<span class="math inline">\(\texttt{a5paper}\)</span>，<span
class="math inline">\(\texttt{b5paper}\)</span>，<span
class="math inline">\(\texttt{executivepaper}\)</span> 和 <span
class="math inline">\(\texttt{legalpaper}\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{twoside, oneside}\)</span></td>
<td
style="text-align: left;">指定单面/双面排版。双面排版时，奇偶页的页眉页脚、页边距不同。<code>article</code>
和 <code>report</code> 默认为 <span
class="math inline">\(\texttt{oneside}\)</span>，<code>book</code>
默认为 <span class="math inline">\(\texttt{twoside}\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{onecolumn, twocolumn}\)</span></td>
<td style="text-align: left;">指定单栏/双栏排版。默认为 <span
class="math inline">\(\texttt{onecolumn}\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{openright, openany}\)</span></td>
<td style="text-align: left;">指定新的一章 <code>chapter</code>
是在奇数页（右侧）开始，还是直接紧跟着上一页开始。<code>report</code>
默认为 <span
class="math inline">\(\texttt{openany}\)</span>，<code>book</code>
默认为 <span class="math inline">\(\texttt{openright}\)</span>。对
<code>article</code> 无效。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{landscape}\)</span></td>
<td style="text-align: left;">指定横向排版。默认为纵向。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{titlepage, notitlepage}\)</span></td>
<td style="text-align: left;">指定标题命令 <code>\maketitle</code>
是否生成单独的标题页。<code>article</code>默认为 <span
class="math inline">\(\texttt{notitlepage}\)</span>，<code>report</code>
和 <code>book</code> 默认为 <span
class="math inline">\(\texttt{titlepage}\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{fleqn}\)</span></td>
<td style="text-align: left;">令行间公式左对齐。默认为居中对齐。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{leqno}\)</span></td>
<td style="text-align: left;">将公式编号放在左边。默认为右边。</td>
</tr>
<tr>
<td style="text-align: left;"><span class="math inline">\(\texttt{draft,
final}\)</span></td>
<td
style="text-align: left;">指定草稿/终稿模式。草稿模式下，断行不良（溢出）的地方会在行尾添加一个黑色方块；插图、超链接等功能也会受这一组选项影响，具体见后文。默认为
<span class="math inline">\(\texttt{final}\)</span>。</td>
</tr>
</tbody>
</table>
<h3 id="宏包">宏包</h3>
<p>在使用 <span class="math inline">\(\LaTeX{}\)</span>
时，时常需要依赖一些扩展来增强或补充 <span
class="math inline">\(\LaTeX{}\)</span>
的功能，比如排版复杂的表格、插入图片、增加颜色甚至超链接等等。这些扩展称为<strong>宏包</strong>。调用宏包的方法非常类似调用文档类的方法：
<code>\usepackage[&lt;options&gt;]&#123;&lt;package-name&gt;&#125;</code></p>
<p><code>\usepackage</code>可以一次性调用多个宏包，在
<code>&lt;package-name&gt;</code>
中用逗号隔开。这种用法一般不要指定选项<a href="#fn4"
class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 一次性调用三个排版表格常用的宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;tabularx, makecell, multirow&#125;</span><br></pre></td></tr></table></figure>
<p>在使用宏包和文档类之前，一定要首先确认它们是否安装在你的计算机中，否则
<code>\usepackage</code>等命令会报错误。</p>
<p>宏包（包括前面所说的文档类）可能定义了许多命令和环境，或者修改了
<span class="math inline">\(\LaTeX{}\)</span>
已有的命令和环境。它们的用法说明记在相应宏包和文档类的帮助文档。在
Windows 命令提示符或者 Linux 终端下输入命令可查阅相应文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">texdoc &lt;pkg-name&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;pkg-name&#125;&gt;</code> 是宏包或者文档类的名称。</p>
<hr />
<h2 id="latex-用到的文件一览"><span
class="math inline">\(\LaTeX{}\)</span> 用到的文件一览</h2>
<p>除了源代码文件 <span class="math inline">\(\texttt{.tex}\)</span>
以外，我们在使用 <span class="math inline">\(\LaTeX{}\)</span>
时还可能接触到各种格式的文件。本节简单介绍一下经常见到的文件。</p>
<p>每个宏包和文档类都是带特定扩展名的文件，除此之外也有一些文件出现于
<span class="math inline">\(\LaTeX{}\)</span> 模板中：</p>
<table>
<thead>
<tr>
<th style="text-align: left;"><span
class="math inline">\(\texttt{.sty}\)</span></th>
<th style="text-align: left;">宏包文件。宏包的名称与文件名一致。</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.cls}\)</span></td>
<td style="text-align: left;">文档类文件。文档类名称与文件名一致。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.bib}\)</span></td>
<td style="text-align: left;">参考文献数据库文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.bst}\)</span></td>
<td style="text-align: left;">用到的参考文献格式模板。</td>
</tr>
</tbody>
</table>
<p>在编译过程中可能会生成相当多的辅助文件和日志。一些功能如交叉引用、参考文献、目录、索引等，需要先通过编译生成辅助文件，然后再次编译时读入辅助文件得到正确的结果，所以复杂的源代码可能要编译多次。</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">中间文件</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.log}\)</span></td>
<td
style="text-align: left;">排版引擎生成的日志文件，供排查错误使用。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.aux}\)</span></td>
<td
style="text-align: left;">生成的主辅助文件，记录交叉引用、目录、参考文献的引用等。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.toc}\)</span></td>
<td style="text-align: left;">生成的目录记录文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.lof}\)</span></td>
<td style="text-align: left;">生成的图片目录记录文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.lot}\)</span></td>
<td style="text-align: left;">生成的表格目录记录文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.bbl}\)</span></td>
<td style="text-align: left;">BibTeX生成的参考文献记录文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.blg}\)</span></td>
<td style="text-align: left;">BibTeX生成的日志文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.idx}\)</span></td>
<td style="text-align: left;">生成的供 <code>makeindex</code>
处理的索引记录文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.ind}\)</span></td>
<td style="text-align: left;"><code>makeindex</code> 处理 <span
class="math inline">\(\texttt{.idx}\)</span>
生成的用于排版的格式化索引文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.ilg}\)</span></td>
<td style="text-align: left;"><code>makeindex</code>
生成的日志文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{.out}\)</span></td>
<td style="text-align: left;"><code>hyperref</code> 宏包生成的 PDF
书签记录文件。</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="文件的组织方式">文件的组织方式</h2>
<p>当编写长篇文档时，例如当编写书籍、毕业论文时，单个源文件会使修改、校对变得十分困难。将源文件分割成若干个文件，例如将每章内容单独写在一个文件中，会大大简化修改和校对的工作。
<span class="math inline">\(\LaTeX{}\)</span> 提供了命令
<code>\include</code> 用来在源代码里插入文件：</p>
<p><code>\include&#123;&lt;filename&gt;&#125;</code></p>
<p><code>&lt;filename&gt;</code> 为文件名（不带 <span
class="math inline">\(\texttt{.tex}\)</span> 扩展名）<a href="#fn5"
class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>，如果和要编译的主文件不在一个目录中，则要加上相对或绝对路径，例如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\include</span>&#123;chapters/file&#125; <span class="comment">% 相对路径</span></span><br><span class="line"><span class="keyword">\include</span>&#123;/home/Bob/file&#125; <span class="comment">% *nix（包含 Linux、macOS）绝对路径</span></span><br><span class="line"><span class="keyword">\include</span>&#123;D:/file&#125; <span class="comment">% Windows 绝对路径，用正斜线</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是 <code>\include</code>
在读入<filename>之前会<strong>另起一页</strong>。有的时候我们并不需要这样，而是用<code>\input</code>
命令，它<strong>纯粹是把文件里的内容插入</strong>：</p>
<p><code>\input&#123;&lt;filename&gt;&#125;</code></p>
<p>当导言区内容较多时，常常将其单独放置在一个 <span
class="math inline">\(\texttt{.tex}\)</span> 文件中，再用
<code>\input</code>
命令插入。复杂的图、表、代码等也会用类似的手段处理。</p>
<p><span class="math inline">\(\LaTeX{}\)</span> 还提供了一个
<code>\includeonly</code>
命令来组织文件，用于导言区，指定只载入某些文件。导言区使用了
<code>\includeonly</code> 后，正文中不在其列表范围的
<code>\include</code> 命令不会起效：</p>
<p><code>\includeonly&#123;&lt;filename1&gt;,&lt;filename2&gt;,...&#125;</code></p>
<p>需要注意的是，使用 <code>\include</code> 和 <code>\input</code>
命令载入的文件名最好不要加空格和特殊字符，也尽量避免使用中文名，否则很可能会出错。</p>
<p>最后介绍一个实用的工具宏包<code>syntonly</code>。加载这个宏包后，在导言区使用
<code>\syntaxonly</code> 命令，可令编译后不生成 DVI 或者 PDF
文档，只排查错误，编译速度会快不少：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;syntonly&#125;</span><br><span class="line"><span class="keyword">\syntaxonly</span></span><br></pre></td></tr></table></figure>
<p>如果想生成文档，则用 % 注释掉 <code>\syntaxonly</code> 命令即可。</p>
<hr />
<h2 id="latex-和-tex-相关的术语和概念"><span
class="math inline">\(\LaTeX{}\)</span> 和 <span
class="math inline">\(\TeX{}\)</span> 相关的术语和概念</h2>
<p>在本章的最后有必要澄清几个概念：</p>
<ul>
<li><strong>引擎</strong>
全称为排版引擎，是编译源代码并生成文档的程序，如 pdfTeX、XeTeX等
。有时也称为<strong>编译器</strong>(类似于GCC、MSVC的功能)。</li>
<li><strong>格式</strong>
是定义了一组命令的代码集（类似于库函数）。<span
class="math inline">\(\LaTeX{}\)</span>
就是最广泛应用的一个格式，高德纳本人还编写了一个简单的 plain TeX
格式，没有定义诸如 <code>\documentclass</code> 和 <code>\section</code>
等命令。</li>
<li><strong>编译命令</strong> 是实际调用的、结合了引擎和格式的命令。如
<span class="math inline">\(\texttt{xelatex}\)</span> 命令是结合
XeTeX引擎和 <span class="math inline">\(\LaTeX{}\)</span>
格式的一个编译命令（类似于编译并链接库函数的过程）。</li>
</ul>
<p>常见的引擎、格式和编译命令的关系总结于下表。</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 22%" />
<col style="width: 27%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>文档格式</th>
<th>plain TeX 格式</th>
<th>LaTeX 格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>TeX 引擎</td>
<td><span class="math inline">\(\textrm{DVI}\)</span></td>
<td><span class="math inline">\(\texttt{tex}\)</span></td>
<td>N/A</td>
</tr>
<tr>
<td>pdfTeX 引擎</td>
<td><span class="math inline">\(\textrm{DVI}\)</span></td>
<td><span class="math inline">\(\texttt{etex}\)</span></td>
<td><span class="math inline">\(\texttt{latex}\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="math inline">\(\textrm{PDF}\)</span></td>
<td><span class="math inline">\(\texttt{pdftex}\)</span></td>
<td><span class="math inline">\(\texttt{pdflatex}\)</span></td>
</tr>
<tr>
<td>XeTeX 引擎</td>
<td><span class="math inline">\(\textrm{PDF}\)</span></td>
<td><span class="math inline">\(\texttt{xetex}\)</span></td>
<td><span class="math inline">\(\texttt{xelatex}\)</span></td>
</tr>
<tr>
<td>LuaTeX 引擎</td>
<td><span class="math inline">\(\textrm{PDF}\)</span></td>
<td><span class="math inline">\(\texttt{luatex}\)</span></td>
<td><span class="math inline">\(\texttt{lualatex}\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(\texttt{latex}\)</span> 编译命令和 <span
class="math inline">\(\LaTeX{}\)</span> 格式往往容易混淆，在讨论关于
<span class="math inline">\(\LaTeX{}\)</span> 的时候需要明确。</p>
<p>在此介绍一下几个编译命令的基本特点：</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">编译命令</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{latex}\)</span></td>
<td style="text-align: left;">虽然名为 <span
class="math inline">\(\texttt{latex}\)</span> 命令，底层调用的引擎其实是
pdfTeX。 该命令生成 <span
class="math inline">\(\texttt{dvi}\)</span>格式的文档, 用 <span
class="math inline">\(\texttt{dvipdfmx}\)</span> 命令可以将其转为 <span
class="math inline">\(\texttt{pdf}\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{pdflatex}\)</span></td>
<td style="text-align: left;">底层调用的引擎也是 pdfTeX，可以直接生成
<span class="math inline">\(\texttt{pdf}\)</span> 格式的文档。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{xelatex}\)</span></td>
<td style="text-align: left;">底层调用的引擎是 XeTeX，支持 UTF-8
编码和对 TrueType/OpenType 字体的调用。
当前较为方便的<strong>中文排版</strong>解决方案基于 <span
class="math inline">\(\texttt{xelatex}\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{lualatex}\)</span></td>
<td style="text-align: left;">底层调用的引擎是 LuaTeX。这个引擎在pdfTeX
引擎基础上发展而来，除了支持 UTF-8 编码和对 TrueType/OpenType
字体的调用外，还支持通过 Lua 语言扩展 <span
class="math inline">\(\TeX{}\)</span> 的功能。 <span
class="math inline">\(\texttt{lualatex}\)</span>
编译命令下的中文排版支持需要借助 <code>luatexja</code>宏包。</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><code>https://www.latex-project.org</code><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn2"><p>以单个字符作为命令的参数时，可以不加括号。例如，在数学环境下，<code>\frac12</code>
和 <code>\frac&#123;1\&#125;\&#123;2&#125;</code> 的效果是一样的。<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn3"><p>个别命令在分组内仍然会产生全局作用，例如<code>\setcounter</code>
等命令。<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn4"><p>使用多个宏包时指定选项，相当于给每个宏包指定同样的选项。如果有某个宏包不能识别指定的选项，则会出错。<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><span class="math inline">\(\LaTeX{}\)</span> 2020-10-01
版本之后允许添加扩展名。<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>《斯坦福高效睡眠法》读书笔记</title>
    <url>/life/notes-stanford-efficient-sleep-methods/</url>
    <content><![CDATA[<p>本文记录了《斯坦福高效睡眠法》这本书的一些读书笔记。</p>
<span id="more"></span>
<hr />
<h2 id="什么是最佳睡眠">什么是最佳睡眠？</h2>
<p>睡眠期间，保持大脑和身体都处于最佳的状态，彻底提升睡眠的质量，从而实现<strong>最强的清醒状态</strong>。</p>
<p>入睡后不久出现的<strong>最深度睡眠的90分钟</strong>，是实现最佳睡眠的关键所在。</p>
<hr />
<h2 id="不睡觉的危害">不睡觉的危害</h2>
<blockquote>
<ol type="1">
<li>会导致胰岛素分泌紊乱，血糖值升高，诱发<strong>糖尿病</strong>；</li>
<li>会导致控制饮食过量的瘦素停止分泌，引起<strong>肥胖</strong>；</li>
<li>会导致增加食欲的胃饥饿素分泌，引发<strong>肥胖</strong>；</li>
<li>会导致交感神经长期处于紧张状态，引起<strong>高血压</strong>；</li>
<li>会导致精神方面的疾病的发病率上升。同时，还会导致酒精依赖、药物依赖等情况的产生；</li>
<li>会导致易患<strong>痴呆症</strong>。</li>
</ol>
</blockquote>
<p><strong>睡眠负债偿还需要很长一段时间，绝非补一觉或者利用周末补回来这样简单。</strong></p>
<hr />
<h2 id="睡眠的作用">睡眠的作用</h2>
<blockquote>
<ol type="1">
<li>让大脑和身体得到休息；</li>
<li>整理记忆，并让其根扎于脑中；</li>
<li>调节激素平衡；</li>
<li>提高免疫力，远离疾病；</li>
<li>排除大脑中的废弃物（如果大脑中的废弃物不能有效排出，就有可能成为患<strong>阿尔茨海默症</strong>等疾病的诱因）。</li>
</ol>
</blockquote>
<hr />
<h2 id="提升睡眠质量的方法">提升睡眠质量的方法</h2>
<ol type="1">
<li>入睡前90分钟泡澡</li>
<li>泡脚按摩</li>
<li>调节室温</li>
<li>用荞麦壳枕头来镇静安神</li>
<li>伸展运动</li>
<li><strong>单调法则</strong>
睡前的娱乐也最好是那种无须用脑的、放松享受的活动。无聊的东西是睡眠的好伙伴。因为“无聊”可以将大脑的开关关上，从而实现深度的睡眠。</li>
<li>被动状态，大脑无需主动活跃思考</li>
<li><strong>严格遵守固定的睡眠作息</strong>
可以从固定起床时间开始，连续14至16个小时保持清醒的状态，会让人的睡眠压力剧增，自然会犯困。先形成一种模式化的睡眠，接着才是固定睡觉的时间。</li>
<li>睡前尽量避免去做那些会增加蓝光负面影响的事情（如在漆黑的房间中长时间玩手机等）</li>
<li><strong>周末维持和往常一样的作息</strong></li>
<li><strong>一定不要忽视最初的困意</strong>。明明犯困却坚持不睡，之后就很难再进入到深度睡眠的状态，而且无论睡多久都不会有一个良好的睡眠质量。</li>
</ol>
<hr />
<h2 id="清醒战略">清醒战略</h2>
<ol type="1">
<li>从早晨开始，改变清醒状态下的行为</li>
<li>设置两个闹钟，间隔20分钟，中间为缓冲区，前一个声音小时间短</li>
<li><strong>不要赖床，按时吃早餐</strong></li>
<li>沐浴清晨日光</li>
<li>光脚起床</li>
<li>冷水刷牙洗手，早晨淋浴</li>
<li>咀嚼有助于强化睡眠和记忆</li>
<li>喝咖啡</li>
<li><strong>上午做重要工作</strong></li>
<li>睡前一小时吃好晚饭</li>
<li>午饭不要摄入太多淀粉</li>
</ol>
<hr />
<h2 id="改善口呼吸方法">改善口呼吸方法</h2>
<p>在<strong>起床时有意识地用鼻子呼气、吸气</strong>。白天也要有意识地练习用鼻子呼气吸气的腹式呼吸。</p>
<p>在此基础上，每天<strong>睡前通过深呼吸</strong>让交感神经趋于平静，同时让副交感神经占据主导位置。</p>
<p>当习惯了这种腹式呼吸后，睡眠过程中就不会再出现用嘴呼吸的情况，进而也就解决了打呼噜的问题。</p>
<hr />
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>读书笔记</tag>
        <tag>睡眠</tag>
      </tags>
  </entry>
  <entry>
    <title>用 $&#92;LaTeX{}$ 排版文字（二）</title>
    <url>/lang-latex/notes-lshort/02-typeset-text/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>文字是排版的基础。本章主要介绍如何在 <span
class="math inline">\(\LaTeX{}\)</span>
中输入各种文字符号，包括标点符号、连字符、重音等，以及控制文字断行和断页的方式。本章简要介绍了在
<span class="math inline">\(\LaTeX{}\)</span> 中排版中文的方法。随着
<span class="math inline">\(\LaTeX{}\)</span> 和底层 <span
class="math inline">\(\TeX{}\)</span>引擎的发展，旧方式（<span
class="math inline">\(\texttt{CCT}\)</span>、<span
class="math inline">\(\texttt{CJK}\)</span>等）日渐退出舞台，<span
class="math inline">\(\texttt{xelatex}\)</span> 和 <span
class="math inline">\(\texttt{lualatex}\)</span> 编译命令配合 <span
class="math inline">\(\texttt{ctex}\)</span>
宏包/文档类的方式成为当前的主流中文排版支持方式。</p>
<span id="more"></span>
<hr />
<h2 id="latex中的字符"><span
class="math inline">\(\LaTeX{}\)</span>中的字符</h2>
<h3 id="空格和分段">空格和分段</h3>
<p>空格键和 Tab
键输入的空白字符视为“空格”。连续的若干个空白字符视为一个空格。一行开头的空格忽略不计。行末的换行符视为一个空格；但连续两个换行符，也就是空行，会将文字分段。多个空行被视为一个空行。也可以在行末使用
<code>\par</code>命令分段。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114165512239.png" alt="image-20250114165512239" style="zoom: 50%;" /></p>
<h3 id="注释">注释</h3>
<ul>
<li>用 %
字符作为注释。在这个字符之后直到行末，所有的字符都被忽略，行末的换行符也不引入空格。</li>
<li>texstudio快捷键 <code>Ctrl + T</code>
快速注释/取消注释光标所在行。</li>
<li><code>\iffalse</code> 和 <code>\fi</code>
是一个常用的方法，适合注释大段文字或代码。</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\iffalse</span></span><br><span class="line">这里是被注释掉的内容。</span><br><span class="line">无论是文字、公式还是代码，都会被忽略。</span><br><span class="line"><span class="keyword">\fi</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>comment</code>
宏包提供了方便的注释方式，可以直接注释任意内容。在导言区引入宏包：<code>\usepackage&#123;comment&#125;</code></li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;comment&#125;</span><br><span class="line">这里是大段注释内容。</span><br><span class="line">你可以注释多行文本或代码。</span><br><span class="line"><span class="keyword">\end</span>&#123;comment&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特殊字符">特殊字符</h3>
<p>以下字符有特殊用途，如 % 表示注释， $、^ 、_
等用于排版数学公式，&amp;
用于排版表格，等等。直接输入这些字符得不到对应的符号，还往往会出错：</p>
<p><code># $ % &amp; &#123; &#125; _ ^ ~ \</code></p>
<p>如果想要输入以上符号，需要使用以下带反斜线的形式输入，类似编程语言里的“转义”符号：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114170715995.png" alt="image-20250114170715995" style="zoom: 50%;" /></p>
<p>这些“转义”符号事实上是一些 <span
class="math inline">\(\LaTeX{}\)</span> 命令。其中 <code>\^</code> 和
<code>\~</code>两个命令需要一个参数，加一对花括号的写法相当于提供了空的参数，否则它们可能会将后面的字符作为参数，形成重音效果。<code>\\</code>被直接定义成了手动换行的命令，输入反斜线就需要用
<code>\textbackslash</code>。</p>
<h3 id="连字">连字</h3>
<p>西文排版中经常会出现连字（ligatures），常见的有
ff/fi/fl/ffi/ffl。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114171445216.png" alt="image-20250114171445216" style="zoom:67%;" /></p>
<h3 id="标点符号">标点符号</h3>
<p>中文的标点符号（绝大多数为非 ASCII
字符）使用中文输入法输入即可，一般不需要过多留意。而输入西文标点符号时，有不少地方需要留意。</p>
<h4 id="引号">引号</h4>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114172016408.png" alt="image-20250114172016408" style="zoom:67%;" /></p>
<h4 id="连字号和破折号">连字号和破折号</h4>
<p>有三种长度的“横线”可用：连字号（hyphen）、短破折号（en-dash）和长破折号（em-dash）。
它们分别有不同的用途：连字号 - 用来组成复合词；短破折号 –
用来连接数字表示范围；长破折号 —
用来连接单词，语义上类似中文的破折号。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114172526612.png" alt="image-20250114172526612" style="zoom:67%;" /></p>
<h4 id="省略号">省略号</h4>
<p>提供了 <code>\ldots</code>
命令表示省略号，相对于直接输入三个点的方式更为合理。<code>\dots</code>
与 <code>\ldots</code> 命令等效。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114172739640.png" alt="image-20250114172739640" style="zoom:67%;" /></p>
<h4 id="拉丁文扩展与重音">拉丁文扩展与重音</h4>
<p>支持用命令输入西欧语言中使用的各种拉丁文扩展字符，主要为带重音的字母：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114173207428.png" alt="image-20250114173207428" style="zoom:67%;" /></p>
<p>更多可用的符号和重音见下表。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114173234392.png" alt="image-20250114173234392" style="zoom:67%;" /></p>
<h4 id="latex-标志"><span class="math inline">\(\LaTeX{}\)</span>
标志</h4>
<p>我们见到的所有错落有致的 <span
class="math inline">\(\LaTeX{}\)</span> 标志都是由以下命令输入的：</p>
<figure>
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114173523673.png"
alt="image-20250114173523673" />
<figcaption aria-hidden="true">image-20250114173523673</figcaption>
</figure>
<p>更多的 <span class="math inline">\(\LaTeX{}\)</span> 标志可以使用
<code>hologo</code> 宏包提供的 <code>\hologo</code> 命令输入。</p>
<hr />
<h2 id="断行和断页">断行和断页</h2>
<p><span class="math inline">\(\LaTeX{}\)</span>
将文字段落在合适的位置进行断行，尽可能做到每行的疏密程度匀称，单词间距不会过宽或过窄。文字段落和公式、图表等内容从上到下顺序排布，并在合适的位置断页，分割成匀称的页面。在绝大多数时候，我们无需自己操心断行和断页。但偶尔会遇到需要手工调整的地方。</p>
<h3 id="单词间距">单词间距</h3>
<p>文字在单词间的“空格”处断行时，“空格”生成的间距随之舍去。可以使用字符
<code>~</code> 输入一个<strong>不会断行的空格</strong>（高德纳称之为
tie，“带子”），通常用在<strong>英文人名、图表名称</strong>等上下文环境：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114174307171.png" alt="image-20250114174307171" style="zoom:67%;" /></p>
<h3 id="手动断行和断页">手动断行和断页</h3>
<p>如果我们确实需要手动断行，可使用如下命令：</p>
<p><code>\\[⟨length⟩]</code></p>
<p><code>\\*[⟨length⟩]</code></p>
<p><code>\newline</code></p>
<p>它们有两点区别：一是 <code>\\</code>
可以带可选参数<code>&lt;length&gt;</code>，用于在断行处向下增加垂直间距，而
<code>\newline</code> 不带可选参数；二是 <code>\\</code>
也在表格、公式等地方用于换行，而 <code>\newline</code>
只用于文本段落中。带星号的 <code>\\</code> 表示禁止在断行处分页。</p>
<p>断页的命令有两个：</p>
<p><code>\newpage</code></p>
<p><code>\clearpage</code></p>
<p>通常情况下两个命令都起到另起一页的作用，区别在于：第一，在双栏排版模式中
<code>\newpage</code> 起到另起一栏的作用，<code>\clearpage</code>
则能够另起一页；第二，在涉及浮动体的排版上行为不同。</p>
<p>有时候我们不满足于默认的断行和断页位置，需要进行微调，可以用以下命令告诉
<span class="math inline">\(\LaTeX{}\)</span>
哪些地方适合断行或断页，哪些地方不适合：</p>
<p><code>\linebreak[⟨n⟩]</code> <code>\nolinebreak[⟨n⟩]</code>
<code>\pagebreak[⟨n⟩]</code> <code>\nopagebreak[⟨n⟩]</code></p>
<p>以上命令都带一个可选参数，用数字
<code>n</code>代表适合/不适合的程度，取值范围为
0-4，不带可选参数时，缺省为4。 比如 <code>\linebreak</code> 或者
<code>\linebreak[4]</code>
意味着此处需要强行断行；<code>\nopagebreak</code> 或
<code>\nopagebreak[4]</code>意味着禁止在此处断页。</p>
<p>以上命令适合给出优先考虑断行断页/禁止断行断页的位置，但不适合直接拿来断行或断页，使用
<code>\newline</code> 或 <code>\newpage</code> 等命令是更好的选择。因为
<code>\newline</code> 和 <code>\newpage</code>
会在断行/断页位置填充适当的间距，但 <code>\linebreak</code> 和
<code>\pagebreak</code>
不能，使用这些命令强行断行/断页可能会制造出糟糕的排版效果，并导致 <span
class="math inline">\(\LaTeX{}\)</span> 报 <span
class="math inline">\(\texttt{Underfull \\hbox}\)</span> 等警告。</p>
<h3 id="断词">断词</h3>
<p>如果遇到了很长的英文单词，仅在单词之间的“空格”处断行无法生成疏密程度匀称的段落时，就会考虑从单词中间断开。对于绝大多数单词，<span
class="math inline">\(\LaTeX{}\)</span>
能够找到合适的断词位置，在断开的行尾加上连字符 <code>-</code> 。</p>
<p>如果一些单词没能自动断词，我们可以在单词内手动使用 <code>\-</code>
命令指定断词的位置：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114180103541.png" alt="image-20250114180103541" style="zoom:67%;" /></p>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之常用数据结构</title>
    <url>/lang-c/c-data-structure/</url>
    <content><![CDATA[<p>日常工作开发中常用的数据结构主要包括数组、链表、栈、队列、哈希表和二叉搜索树，本文介绍这些数据结构的设计思路，并且给出了C语言版本的代码实现。</p>
<span id="more"></span>
<hr />
<p>在日常的工作开发中，最常用的数据结构有：数组、链表、栈、队列、哈希表和二叉搜索树。其中：</p>
<ol type="1">
<li><p><strong>数组和链表是线性数据结构的两种典型物理实现。</strong>
它们是最基础的数据结构，是构成其它更复杂数据结构的基石。</p>
<ul>
<li><p>数组采用一段连续的内存空间存储，最大的特点是基于索引的快速随机访问。</p></li>
<li><p>链表则由非连续存储的、基于指针链接的结点组成，提供了灵活的插入和删除操作。</p></li>
</ul></li>
<li><p><strong>栈和队列是数组和链表的经典应用场景。</strong>
它们都可以基于数组或链表实现，不同的是栈遵循先进后出的原则，而队列遵循先进先出的原则。</p></li>
<li><p><strong>哈希表</strong>
通常结合数组与链表来实现，用于提供快速的数据查询能力。</p></li>
<li><p><strong>二叉搜索树</strong>
是一种基于树形的数据结构，它提供了优秀的搜索效率。二叉搜索树在实现时可以借鉴链表的实现思路，所以它和链表也有一定的关联。</p></li>
</ol>
<p><strong>如何学习数据结构？</strong></p>
<p>学习一种数据结构，可以从三个角度入手：</p>
<ol type="1">
<li><strong>理论基础与模型。</strong>
学习一种数据结构，首先要做的就是理解它的概念模型以及知晓其理论基础，包括其特点、用途和适用场景等。</li>
<li><strong>基础操作。</strong>
在掌握了基本理论后，就需要进一步熟悉该数据结构的基础操作以及这些操作的工作原理。这些基础操作一般包括：增、删、查以及遍历。(改操作是查操作的扩展)</li>
<li><strong>实现与应用。</strong>
在了解理论和操作后，就可以编写代码来实现这些数据结构了，这不仅有助于巩固理解数据结构，同时也能提升编程能力。</li>
</ol>
<p><strong>推荐两个学习网站：</strong></p>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly92aXN1YWxnby5uZXQvemgv">Visualgo
可视化数据结构与算法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudXNmY2EuZWR1L35nYWxsZXMvdmlzdWFsaXphdGlvbi9BbGdvcml0aG1zLmh0bWw=">Data
Structure Visualization (usfca.edu)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr />
<h2 id="动态数组">动态数组</h2>
<p>数组是一种基本的、常见的数据结构，它以其快速的访问速度而著称。</p>
<p>然而，在 C
语言中，传统的数组(指在栈上分配内存空间的数组)拥有一个显著的限制：它们的长度一旦确定便无法更改。这在处理动态数据集时显得尤为不便，如在不确定数据量的情况下存储用户输入。</p>
<p>C++通过引入 Vector 这样的动态数组解决了这个问题(Java 中的 ArrayList
也是类似的)，它可以根据需要动态调整大小。遗憾的是，C
语言标准库中并未提供类似的结构。但不要担心，借助于动态内存分配函数如
malloc 和 realloc，我们完全可以在 C 中手动实现类似的功能。</p>
<h3 id="设计思路">设计思路</h3>
<p>在 C 语言中实现一个动态数组，通常使用一个结构体定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用别名来命名元素类型，如果未来需要改变元素类型，只需修改这个别名即可。</span></span><br><span class="line"><span class="comment">// 这么做提升代码的可维护性和扩展性, 这实际上是模拟了 C++的泛型编程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElementType *data;      <span class="comment">// 指向动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">// 当前动态数组中元素的数量</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 动态数组当前分配的最大容量</span></span><br><span class="line">&#125; Vector;</span><br></pre></td></tr></table></figure>
可以用下图来理解一个 Vector 动态数组：
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311131037946.png" alt="Vector动态数组-内存示意图" style="zoom: 33%;" />
</div>
<p>除此之外，为了满足正常的动态数组的功能，我们还需要实现以下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个 Vector 动态数组.这实际上是模拟了 C++的默认构造函数</span></span><br><span class="line">Vector* <span class="title function_">vector_create</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 销毁一个 Vector 动态数组，释放内存。这实际上模拟了 C++的析构函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_destroy</span><span class="params">(Vector* v)</span>;</span><br><span class="line"><span class="comment">// 向动态数组末尾添加一个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_push_back</span><span class="params">(Vector* v, ElementType element)</span>;</span><br><span class="line"><span class="comment">// 在动态数组最前面添加元素，所有元素依次后移</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_push_front</span><span class="params">(Vector* v, ElementType val)</span>;</span><br><span class="line"><span class="comment">// 将元素 val 添加到索引为 idx 的位置，idx 后面的元素依次后移</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_insert</span><span class="params">(Vector* v, <span class="type">int</span> idx, ElementType val)</span>;</span><br><span class="line"><span class="comment">// 遍历打印整个 Vector 动态数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_print</span><span class="params">(Vector* v)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现">代码实现</h3>
<details>
<summary>
<font size="4" color="orange"> vector.h </font>
</summary>
<pre> <code class="language-c"> #pragma once
// 使用别名来命名元素类型，如果未来需要改变元素类型，只需修改这个别名即可。
// 这么做提升代码的可维护性和扩展性, 这实际上是模拟了 C++/Java 等编程语言的泛型编程
typedef int ElementType;
typedef struct &#123;
    ElementType* data;      // 指向动态分配数组的指针
    int size;    // 当前动态数组中元素的数量
    int capacity; // 动态数组当前分配的最大容量
&#125; Vector;
// 初始化一个 Vector 动态数组.这实际上是模拟了 C++的默认构造函数
Vector* vector_create();
// 销毁一个 Vector 动态数组，释放内存。这实际上模拟了 C++的析构函数
void vector_destroy(Vector* v);
// 向动态数组末尾添加一个元素
void vector_push_back(Vector* v, ElementType element);
// 在动态数组最前面添加元素，所有元素依次后移
void vector_push_front(Vector* v, ElementType val);
// 将元素 val 添加到索引为 idx 的位置，idx 后面的元素依次后移
void vector_insert(Vector* v, int idx, ElementType val);
// 遍历打印整个 Vector 动态数组
void vector_print(Vector* v);
  </code> </pre>
</details>
<p>头文件主要用于存放以下结构：</p>
<ol type="1">
<li>函数的声明</li>
<li>结构体的定义</li>
<li>类型别名的定义</li>
<li>宏定义</li>
<li>…</li>
</ol>
<p><strong>头文件允许程序员在多个源文件之间共享函数的声明以及结构体、类型别名和宏的定义，从这个角度讲头文件类似
C++、Java 等编程语言中的接口。</strong></p>
<p>普遍采取的做法是：<strong>在头文件中声明函数，然后在某个源文件中包含头文件实现这些函数，最后在其余源文件中包含头文件，使用这些函数。</strong></p>
<p>使用头文件，促进了 <strong>模块化编程</strong>，提高了
<strong>代码的复用性</strong>，使得代码更加易于维护。</p>
<p><strong>注意：头文件作为接口的目的是对外暴露公共部分，某些不属于公共部分不需要对外暴露的不要放在头文件当中！！！</strong></p>
<p>包含头文件与实现函数</p>
<details>
<summary>
<font size="4" color="orange"> vector.c </font>
</summary>
<pre> <code class="language-c">#include "vector.h"
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#define DEFAULT_CAPACITY 10 // 设置动态数组的默认最小容量
#define THRESHOLD 1024
static void vector_resize(Vector* v) &#123;
    // 只要调用这个函数肯定就是需要扩容的
    int old_capacity = v-> capacity;
    int new_capacity = (old_capacity < THRESHOLD) ?
        (old_capacity << 1) :   // 容量还未超出阈值每次扩容 2 倍
        (old_capacity + (old_capacity >> 1));   // 容量超出阈值每次扩容 1.5 倍
    // 利用 realloc 重新分配动态数组
    ElementType * tmp = realloc(v-> data, new_capacity * sizeof(ElementType));    // realloc 惯用法
    if (tmp == NULL) &#123;
        printf("realloc failed in resize_vector.\n");
        exit(1);    // 扩容失败，退出整个程序。或者也可以做别的处理
    &#125;
    // 扩容成功，重新赋值 Vector 成员
    v-> data = tmp;
    v-> capacity = new_capacity;
&#125;
Vector* vector_create() &#123;
    Vector * v = (Vector*)calloc(1, sizeof(Vector));
    if (! v)
    &#123;
        printf("Error: calloc failed in vector_create!\n");
        return NULL;
    &#125;
    v-> data = (ElementType*)calloc(DEFAULT_CAPACITY, sizeof(ElementType));
    if (! v-> data) &#123;
        printf("Error: calloc failed in vector_create!\n");
        free(v);
        return NULL;
    &#125;
    // 继续初始化 Vector 的其它成员
    v-> capacity = DEFAULT_CAPACITY;
    // size 已自动初始化为 0 值，所以不需要再次赋值了。但如果用 malloc 就不要忘记初始化它
    return v;
&#125;
void vector_destroy(Vector* v) &#123;
    free(v-> data);
    free(v);
&#125;
void vector_push_back(Vector* v, ElementType element) &#123;
    if (v-> size == v-> capacity)
    &#123;
        vector_resize(v);
    &#125;
    v-> data [v-> size] = element;
    v-> size++;
&#125;
void vector_push_front(Vector* v, ElementType val) &#123;
    if (v-> size == v-> capacity)
    &#123;
        vector_resize(v);
    &#125;
    // 扩容完成后或不需要扩容，即从首元素开始将所有元素向后移动
        // 倒着遍历数组方便向后移动元素
    for (int i = v-> size - 1; i >= 0; i--) &#123;
        v-> data [i + 1] = v-> data [i];
    &#125;
    // 新增的元素成为首元素
    v-> data [0] = val;
    v-> size++;
&#125;
void vector_insert(Vector* v, int idx, ElementType val) &#123;
    // 先做参数校验，避免传入非法索引
    if (idx < 0 || idx > v-> size) &#123;     // 做插入操作时索引合法范围是 [0, size]
        printf("Illegal argument: idx = %d, size = %d\n", idx, v-> size);
        exit(1);    // 直接退出进程，也可以用别的方式进行错误处理
    &#125;
    if (v-> size == v-> capacity)
    &#123;
        vector_resize(v);
    &#125;
    for (int i = v-> size - 1; i >= idx; i--) &#123;
        v-> data [i + 1] = v-> data [i];
    &#125;
    v-> data [idx] = val;
    v-> size++;
&#125;
void vector_print(Vector* v) &#123;
    printf("[");
    for (int i = 0; i < v-> size; i++) &#123;
        printf("%d, ", v-> data [i]);
    &#125;
    printf("\b\b]\n");
&#125;</code> </pre>
</details>
<p>完成一系列关于 Vector 的开发实现后，接下来的关键步骤就是测试。</p>
<p><strong>在实际的开发中，当我们完成了某个独立模块、组件的开发后，都需要编写一系列测试用例，进行彻底的单元测试工作，来及时的发现和修复程序中的缺陷和
bug，从而提高整体代码质量。</strong></p>
<p>编写测试用例，完成单元测试开发，也是一个普通程序员的本职工作之一。</p>
<p>在这里，可以创建一个 “test.c”
的源文件，用于运行一系列的测试用例：</p>
<ol type="1">
<li>创建和销毁。验证 Vector 是否可以成功创建和销毁，没有内存泄漏。</li>
<li>添加元素：测试向 Vector
添加元素的功能，确保数组可以正确地扩容。</li>
<li>边界条件检查：检查 Vector
在极端情况下（如恰好超出容量）的行为是否正确。</li>
<li>….</li>
</ol>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include "vector.h"
#define N 100
int main(void) &#123;
    Vector *v = vector_create();
    if (v == NULL) &#123;
        printf("error: vector_create failed in main.\n");
        exit(1);
    &#125;
    // 测试自动扩容机制
    for (int i = 0; i < N; ++i) &#123;
        vector_push_back(v, i + 1);
    &#125;
    vector_print(v);    // 期望打印结果: 1-100
    // 测试头部插入新元素
    vector_push_front(v, 0);
    vector_print(v);    // 期望打印结果: 0, 1-100
    // 测试根据索引插入新元素
    vector_insert(v, 0, -1);
    vector_print(v);    // 期望打印结果: -1, 0, 1-100
    vector_destroy(v);
    return 0;
&#125;</code>
</pre>
</details>
<hr />
<h2 id="链表">链表</h2>
<p>链表：是一种线性数据结构，由一系列结点 <strong>“链接”</strong>
构成。</p>
<p>结点：在 C
语言中，一个结点通常是一个结构体对象。该结构体对象由数据域和指针域两部分组成。数据域用于存储数据，而指针域则用于存放其它结点的指针。</p>
<p>如下图所示(其中 D 代表 <strong>数据域</strong>，P 代表
<strong>指针域</strong>)：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311152035255.png" alt="结点和链表-示意图" style="zoom: 33%;" />
</div>
<p>常见的链表主要可以分为以下几种类型：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311152050220.png" alt="常见链表分类-示意图" style="zoom: 33%;" />
</div>
<h3 id="单向链表">单向链表</h3>
<p>单向链表是由一系列结点单向链接组成的数据结构，简称单链表。</p>
<p>基础概念：</p>
<ol type="1">
<li><p><strong>结点：</strong>
链表中的每一个存储单元被称为结点，每个结点都包含两部分：</p>
<ol type="1">
<li>一部分用于存储结点的数据(数据域)</li>
<li>另一部分用于存储指向下一个结点的指针(指针域)。</li>
</ol>
<p>在 C 程序中一个结点，就是一个结点结构体类型的对象。</p></li>
<li><p><strong>头结点：</strong>
某些单链表的实现中，会在第一个结点前附设一个
<strong>“一般不存储数据或者存储链表长度信息”</strong>
的结点，这个结点就是头结点。</p>
<ol type="1">
<li>头结点也叫做 “哑结点”、“虚拟结点”、“哨兵结点”
等。头结点的指针域指向链表的第一个结点。</li>
<li>在实际应用中，单链表一般不带头结点，但在需要统一链表头部操作的场景中，头结点具有
“奇效”。</li>
</ol></li>
<li><p><strong>尾结点：</strong> 单链表的最后一个结点。它的指针域指向
NULL，表示链表的结束。</p></li>
<li><p><strong>头指针：</strong>
指向链表第一个结点的指针，<strong>头指针非常重要，单链表的任何操作都是以头指针为入口的，单链表一定会有头指针。</strong>
具体而言：</p>
<ol type="1">
<li>如果链表为空，则头指针为 NULL，是一个空指针。</li>
<li>如果单链表没有头结点，那么头指针就指向链表的第一个存储数据的结点。</li>
<li>如果单链表有头结点，那么头指针就指向该头结点。总之，头指针就指向单链表的第一个结点。</li>
</ol></li>
<li><p><strong>尾指针：</strong>
指向链表最后一个结点的指针。对于单链表而言，尾指针不是必须的，但拥有尾指针可以使得链表尾部的操作更加简单高效。</p></li>
</ol>
<p>基本操作：</p>
<ol type="1">
<li><p>创建链表</p></li>
<li><p>销毁链表</p></li>
<li><p>插入结点：对于链表而言，只要在一个确定的结点后面插入结点，都是一个基础的，时间复杂度为
O(1)的操作。</p>
<ol type="1">
<li>在一个存在头指针和尾指针的链表当中，头插和尾插就是基础的插入结点操作。</li>
<li>更复杂的插入操作都是对基础插入操作的扩展，比如根据索引插入一个结点。</li>
</ol></li>
<li><p>搜索结点：链表并不支持随机访问，任何的访问操作都意味着遍历链表。</p>
<ol type="1">
<li>所以不管是有序无序还是搜索的条件是什么，单链表的搜索操作时间复杂度总是
O(n)</li>
<li>比较常见的搜索条件是：根据索引查找或者根据数据查找</li>
</ol></li>
<li><p>删除结点：对于链表而言，只要是删除一个确定结点后面的一个结点，都是一个基础的，时间复杂度为
O(1)的操作。</p>
<ul>
<li><p>在一个存在头指针和尾指针的链表当中，删除第一个结点就是一个基础的
O(1)时间复杂度操作。</p></li>
<li><p>如果需要删除尾结点或中间结点，则通常需要遍历链表，时间复杂度是
O(n)</p></li>
</ul></li>
</ol>
<h4 id="设计思路-1">设计思路</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311161556943.png" alt="单向链表结构-示意图" style="zoom: 33%;" />
</div>
<h4 id="代码实现-1">代码实现</h4>
<details>
<summary>
<font size="4" color="orange"> linked_list.h </font>
</summary>
<pre> <code class="language-c">// 头文件保护语法
#ifndef LINKED_LIST_H
#define LINKED_LIST_H
// 包含 linked_list.h 头文件也会同步包含它包含的其它头文件
// 根据这一特点, 可以选择将一些共用的头文件包含在此头文件中
#include &lt; stdbool.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
#define ERROR_CHECK(ret, error_flag, msg) \
 do &#123; \
     if ((ret) == (error_flag)) &#123; \
         printf("error: %s\n", msg); \
         exit(1); \
     &#125; \
 &#125; while(0)
typedef int DataType;
// 定义链表结点结构
typedef struct node &#123;
    DataType data;      // 数据域
    struct node* next;  // 指针域
&#125; Node;
// 定义链表结构本身
typedef struct &#123;
    Node* head;     // 头指针
    Node* tail;     // 尾结点指针
    int size;       // 用于记录链表的长度
&#125; LinkedList;
// 创建一个空的链表
LinkedList* create_linked_list();
// 销毁链表
void destroy_linked_list(LinkedList* list);
// 头插法
bool add_before_head(LinkedList* list, DataType new_data);
// 尾插法
bool add_behind_tail(LinkedList* list, DataType new_data);
// 根据索引插入一个新结点
bool add_by_idx(LinkedList* list, int idx, DataType new_data);
// 根据索引搜索一个结点
Node * search_by_idx(LinkedList* list, int idx);
// 根据数据搜索一个结点
Node * search_by_data(LinkedList* list, DataType data);
// 根据数据删除一个结点
bool delete_by_data(LinkedList* list, DataType data);
// 扩展: 根据索引删除一个结点
bool delete_by_idx(LinkedList* list, int idx);
// 打印单链表 格式为：1 -> 2 -> 3 ->...
void print_list(LinkedList* list);
#endif // ! LINKED_LIST_H
</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> linked_list.c </font>
</summary>
<pre> <code class="language-c">#include "linked_list.h"
LinkedList* create_linked_list()
&#123;
    LinkedList* list = calloc(1, sizeof(LinkedList));
    ERROR_CHECK(list, NULL, "Error: malloc failed in creat_linked_list.\n");
    return list;
&#125;
void destroy_linked_list(LinkedList* list)
&#123;
    Node* curr = list-> head;
    while (curr) &#123;
        Node* temp = curr-> next;
        free(curr);
        curr = temp;
    &#125;
    free(list);
&#125;
// 头插法
bool add_before_head(LinkedList *list, DataType new_data) &#123;
    // 1.分配一个新结点
    Node *new_node = (Node *)malloc(sizeof(Node));
    if (new_node == NULL) &#123;
        printf("malloc failed in add_before_head.\n");
        return false;
    &#125;
    // 2.初始化这个新结点
    new_node-> data = new_data;
    new_node-> next = list-> head;    // 新结点指向原本的第一个结点
    // 3.更新头指针指向新结点
    list-> head = new_node;  // 新结点成为第一个结点
    // 4.如果尾结点指针是 NULL，说明链表头插前为空，那么新结点同时成为尾结点
    // 需要更新尾结点指针
    if (list-> tail == NULL) &#123;
        list-> tail = new_node;
    &#125;
    list-> size++;
    return true;
&#125;
// 尾插法
bool add_behind_tail(LinkedList *list, DataType new_data) &#123;
    // 1.分配一个新结点
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL) &#123;
        printf("malloc failed in add_behind_tail.\n");
        return false;
    &#125;
    // 2.初始化新结点的指针域和数据域，指针域初始为 NULL
    new_node-> data = new_data;
    new_node-> next = NULL;
    // 3.如果尾结点指针是 NULL，说明链表尾插前为空，那么新结点同时成为第一个结点和尾结点
    if (list-> tail == NULL) &#123;
        // 链表为空
        list-> head = new_node;
        list-> tail = new_node;
        list-> size++;
        return true;
    &#125;
    // 4.如果尾指针不是 NULL，让以前的尾结点指向新结点，然后更新尾指针
    list-> tail-> next = new_node;
    list-> tail = new_node;
    list-> size++;
    return true;
&#125;
bool add_by_idx(LinkedList* list, int idx, DataType new_data)
&#123;
    // 参数校验
    if (idx <0 || idx> list-> size) &#123;
        printf("Index is not valid.\n");
        return false;
    &#125;
    Node* new_node = calloc(1, sizeof(Node));
    if (! new_node)
    &#123;
        printf("Error: calloc failed in add_behind_tail.\n");
        return false;
    &#125;
    if (idx == 0)
    &#123;
        return add_before_head(list, new_data);
    &#125;
    else if (idx == list-> size) &#123;
        return add_behind_tail(list, new_data);
    &#125;
    else
    &#123;
        Node* prev = NULL;
        Node* curr = list-> head;
        for (size_t i = 0; i < idx; i++)
        &#123;
            prev = curr;
            curr = curr-> next;
        &#125;
        new_node-> data = new_data;
        new_node-> next = curr;
        prev-> next = new_node;
        list-> size++;
        return true;
    &#125;
&#125;
Node * search_by_idx(LinkedList* list, int idx)
&#123;
    // 参数校验
    if (idx < 0 || idx > = list-> size) &#123;
        printf("Index is not valid.\n");
        return NULL;
    &#125;
    Node* curr = list-> head;
    if (! curr)
    &#123;
        printf("The list is empty.\n");
        return NULL;
    &#125;
    for (size_t i = 0; i < idx; i++)
    &#123;
        curr = curr-> next;
    &#125;
    return curr;
&#125;
Node * search_by_data(LinkedList* list, DataType data)
&#123;
    Node* curr = list-> head;
    if (! curr)
    &#123;
        printf("The list is empty.\n");
        return NULL;
    &#125;
    while (curr) &#123;
        if (curr-> data == data)
        &#123;
            return curr;
        &#125;
        curr = curr-> next;
    &#125;
    return NULL;
&#125;
bool delete_by_data(LinkedList* list, DataType data)
&#123;
    Node* prev = NULL;
    Node* curr = list-> head;
    ERROR_CHECK(curr, NULL, "The list is empty.\n");
    while (curr) &#123;
        if (curr-> data == data)
        &#123;
            if (curr == list-> head)
            &#123;
                if (curr-> next) &#123; // 删除的第一个节点有后继节点
                    list-> head = curr-> next;
                    free(curr);
                &#125;
                else &#123; // 删除的第一个节点无后继节点
                    list-> head = NULL;
                    list-> tail = NULL;
                    free(curr);
                &#125;
            &#125;
            else
            &#123;
                prev-> next = curr-> next;
                if (curr == list-> tail) &#123;
                    list-> tail = prev;
                &#125;
                free(curr);
            &#125;
            list-> size--;
            return true;
        &#125;
        prev = curr;
        curr = curr-> next;
    &#125;
    return false;
&#125;
bool delete_by_idx(LinkedList* list, int idx)
&#123;
    // 参数校验
    if (idx < 0 || idx > = list-> size) &#123;
        printf("Index is not valid.\n");
        return false;
    &#125;
    Node* prev = NULL;
    Node* curr = list-> head;
    ERROR_CHECK(curr, NULL, "The list is empty.\n");
    if (idx == 0)
    &#123;
        if (curr-> next) &#123; // 删除的第一个节点有后继节点
            list-> head = curr-> next;
        &#125;
        else &#123; // 删除的第一个节点无后继节点
            list-> head = NULL;
            list-> tail = NULL;
        &#125;
    &#125;
    else &#123;
        for (size_t i = 0; i < idx; i++)
        &#123;
            prev = curr;
            curr = curr-> next;
        &#125;
        prev-> next = curr-> next;
        if (curr-> next == NULL) &#123;
            list-> tail = prev;
        &#125;       
    &#125;
    free(curr);
    list-> size--;
    return true;
&#125;
// 打印单链表 格式为：1 -> 2 -> 3 ->...
void print_list(LinkedList *list) &#123;
    Node *curr = list-> head;
    // 遍历此单链表
    while (curr != NULL) &#123;
        printf("%d", curr-> data);
        // 如果不是链表的最后一个结点，就打印箭头
        if (curr-> next != NULL) &#123;
            printf(" -> ");
        &#125;
        curr = curr-> next;
    &#125;
    printf("\n");
&#125;
</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include "linked_list.h"
#define ARR_SIZE(arr) (sizeof(arr)/sizeof(arr [0]))
/*
*/
int main(void) &#123;
    LinkedList* list = create_linked_list();
    add_before_head(list, 4);
    add_before_head(list, 3);
    add_before_head(list, 2);
    add_before_head(list, 1);
    add_behind_tail(list, 5);
    // add_by_idx(list, 0, 0);
    // add_by_idx(list, 3, 111);
    print_list(list);
    //Node* node =  search_by_idx(list, 5);
    //Node* node = search_by_data(list, 7);
    // delete_by_data(list, 4);
    delete_by_idx(list, 4);
    print_list(list);
    destroy_linked_list(list);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<hr />
<h2 id="栈">栈</h2>
<h3 id="概述">概述</h3>
<p>相比较于数组和链表，栈是一种操作受限的线性结构。</p>
<p>这种操作受限体现在：</p>
<ol type="1">
<li>栈只能在 <strong>同一端</strong> 添加、删除以及访问元素（栈顶）</li>
<li>另一端无法执行任何操作（栈底），栈底的元素既不能直接增删，也不能直接访问。</li>
</ol>
<p><strong>可以把栈想象成一个杯子，杯底相当于栈底，无法直接进行任何操作。杯口相当于栈顶，是唯一可以进行添加、删除和访问操作的地方。</strong></p>
<p>在栈中，最先添加到栈中的元素总是最后被删除的，遵循
<strong>后进先出（LIFO, Last In First Out）</strong> 的原则。</p>
<p>如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311210848469.png" alt="栈-示意图" style="zoom: 33%;" />
</div>
<p>栈这种数据结构的基本操作主要包括以下几种：</p>
<ol type="1">
<li>入栈/压栈(push)：在栈顶添加一个元素，成为新的栈顶元素，其余元素则被压入栈底。时间复杂度
O(1)</li>
<li>出栈/弹栈(pop)：删除栈顶元素，下一个元素成为新的栈顶元素。时间复杂度
O(1)</li>
<li>访问栈顶元素(peek)：返回栈顶元素的值。时间复杂度 O(1)</li>
<li>判空(is_empty)：检查栈中是否有任何元素。时间复杂度
O(1)，因为只需要检查一下栈顶元素即可。</li>
</ol>
<p><strong>说白了，栈仍然还是一个线性数据结构(数组或链表都可以)，只不过在实现时，只需要提供栈顶的增删访问操作罢了。</strong></p>
<h3 id="栈的优点">栈的优点</h3>
<p>栈是一种操作受限的线性结构，既然如此，那么为什么非要使用栈呢？直接使用链表或数组不好吗？</p>
<p>使用栈主要有以下好处：</p>
<ol type="1">
<li>高效率。由于栈的操作仅限于顶部，栈的所有基本操作（push、pop、peek）通常都具有
O(1) 的时间复杂度，这使得栈在性能上非常高效。</li>
<li>简化代码、增强代码可读性。由于操作受限，编程时的考虑因素更少，更容易实现。也有助于写出更清晰、更易于维护的代码。</li>
<li>非常适合用于解决特定问题。在实际的某些应用场景中，如函数调用管理、括号匹配问题、表达式求值、浏览器的前进后退功能等，自然而然地符合
“先进后出” 的特点，天然就适合使用栈来解决。</li>
</ol>
<p><strong>在数据结构的选择上，关键在于根据具体的应用需求和场景来决定最合适的结构。</strong></p>
<h3 id="栈的实现方式">栈的实现方式</h3>
<p>栈的实现有两种方式：</p>
<ol type="1">
<li>基于链表实现</li>
<li>基于数组实现</li>
</ol>
<p>这两种实现方式各有优缺点，总得来说：</p>
<ol type="1">
<li>如果以一个固定长度的数组来实现栈，实现方式非常简洁，依赖于数组随机访问效率特别高。也不需要额外的空间来存储指针。但缺点是栈大小固定，无法扩容。</li>
<li>如果用一个动态数组来实现栈，栈具有更灵活的容量，同样随机访问效率高且不需要额外空间存储指针。但缺点是，重分配内存可能是一个较大的性能开销，拖慢整体栈的效率。</li>
<li>如果以链表来实现，灵活性比数组更强，且扩容不涉及内存重分配，栈整体性能稳定。但缺点是空间占用更多，需要存储额外的指针。当然，链表实现肯定会更复杂一些，这也算个小毛病。</li>
</ol>
<p>总的来说：</p>
<ol type="1">
<li>在已知栈大小限制或不需要频繁调整栈大小时，优先考虑使用固定长度的数组来实现栈，这会提供更好的性能以及更简单的实现以及使用方式。</li>
<li>在栈大小未知或需要频繁调整栈大小时，可以考虑使用动态数组或链表来实现栈，它们的区别是：
<ol type="1">
<li>动态数组实现的缺点是如果需要频繁调整大小，那么性能会非常差。所以如果不需要频繁的进行扩容操作，且对性能需求高，则优先选择动态数组实现。而且现代很多高级编程语言（比如
C++、Java 等）都已提供了现成的动态数组实现。</li>
<li>如果栈的大小完全不可预测，使用动态数组实现会导致频繁调整大小的操作，那么可以更多的考虑使用链表实现。</li>
</ol></li>
</ol>
<h3 id="设计思路-2">设计思路</h3>
<h4 id="链式栈模型">链式栈模型</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240920115219055.png" alt="链式栈模型" style="zoom: 67%;" />
</div>
<h4 id="动态数组栈模型">动态数组栈模型</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240921112648213.png" alt="动态数组栈模型" style="zoom: 67%;" />
</div>
<h3 id="代码实现-2">代码实现</h3>
<h4 id="链式栈模型-1">链式栈模型</h4>
<details>
<summary>
<font size="4" color="orange"> linked_stack.h </font>
</summary>
<pre> <code class="language-c">#ifndef LINKED_STACK_H
#define LINKED_STACK_H
#include &lt; stdbool.h&gt;
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
typedef int ElementType;
// 栈的一个结点栈帧, 类型定义
typedef struct node_s &#123;
    ElementType data;
    struct node_s* next;
&#125;StackFrame;
typedef struct &#123;
    StackFrame* top;    // 栈顶指针
&#125;LinkedStack;
// 基本操作
// 创建链式栈
LinkedStack* stack_create();
// 销毁链式栈
void stack_destroy(LinkedStack* stack);
// 判空
bool is_empty(LinkedStack* stack);
// 入栈
void stack_push(LinkedStack* stack, ElementType data);
// 出栈并返回栈顶元素
ElementType stack_pop(LinkedStack* stack);
// 访问栈顶元素
ElementType stack_peek(LinkedStack* stack);
#endif // ! LINKED_STACK_H
</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> linked_stack.c </font>
</summary>
<pre> <code class="language-c">#include "linked_stack.h"
// 新建一个空栈
LinkedStack *stack_create() &#123;
    // callock 可以不用手动初始化空指针
    return calloc(1, sizeof(LinkedStack));
&#125;
// 对于链式栈而言，销毁栈就是销毁链表
void stack_destroy(LinkedStack *stack) &#123;
    // 相当于遍历链表(出栈)然后在遍历中逐个 free 结点
    StackFrame *curr = stack-> top;
    while (curr != NULL) &#123;
        StackFrame *tmp = curr-> next;   // 保存后继结点
        free(curr);
        curr = tmp;
    &#125;
    // 最后 free 栈结构体
    free(stack);
&#125;
bool is_empty(LinkedStack *stack) &#123;
    return stack-> top == NULL;
&#125;
// 相当于链表头插法插入结点，栈顶指针相当于链表的头指针
void stack_push(LinkedStack *stack, ElementType data) &#123;
    // 1.新建一个栈帧结点
    StackFrame *new_frame = malloc(sizeof(StackFrame));
    if (new_frame == NULL) &#123;
        printf("malloc failed in stack_push.\n");
        exit(1);
    &#125;
    // 2.初始化新栈帧
    new_frame-> data = data;
    new_frame-> next = stack-> top;
    // 3.更新栈顶指针
    stack-> top = new_frame;
&#125;
// 相当于链表在头部删除第一个结点, 栈顶指针相当于链表的头指针
ElementType stack_pop(LinkedStack *stack) &#123;
    // 1.栈判空处理
    if (is_empty(stack)) &#123;
        printf("error: stack is empty.\n");
        exit(1);
    &#125;
    // 2.出栈返回栈顶元素, 并 free 结点, 更新栈顶指针
    StackFrame *curr = stack-> top;
    ElementType data = curr-> data;
    stack-> top = curr-> next;
    free(curr);
    return data;
&#125;
ElementType stack_peek(LinkedStack *stack) &#123;
    if (is_empty(stack)) &#123;
        printf("error: stack is empty.\n");
        exit(1);
    &#125;
    return stack-> top-> data;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; string.h&gt;
#include "linked_stack.h"
int main(void) &#123;
    // 创建一个空栈
    LinkedStack *stack = stack_create();
    if (stack == NULL) &#123;
        printf("Failed to create stack.\n");
        return -1;
    &#125;
    // 入栈操作
    stack_push(stack, 1);
    stack_push(stack, 2);
    stack_push(stack, 3);
    // 查看栈顶元素
    printf("当前栈顶元素是: %d\n", stack_peek(stack)); // 应该输出 3
    // 出栈操作，并打印出栈的元素
    printf("依次出栈以下元素:\n");
    while (! is_empty(stack)) &#123;
        printf("%d\n", stack_pop(stack)); // 应该依次输出 3, 2, 1
    &#125;
    // 再次尝试查看栈顶元素，预期会触发错误提示
    printf("栈为空时, 尝试访问栈顶元素:\n");
    stack_peek(stack);  // 应该输出错误信息并退出
    // 销毁栈
    stack_destroy(stack);   return 0;
&#125;</code>
</pre>
</details>
<h4 id="动态数组栈模型-1">动态数组栈模型</h4>
<details>
<summary>
<font size="4" color="orange"> dynamic_stack.h </font>
</summary>
<pre> <code class="language-c">#ifndef DYNAMIC_STACK_H
#define DYNAMIC_STACK_H
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdbool.h&gt;
typedef int ElementType;
typedef struct &#123;
    ElementType* elements;   // 指向动态数组首元素的指针
    int size;   // 元素的个数
    int capacity; // 数组的容量，也就是栈的容量
&#125; DynamicStack;
// 创建动态数组栈
DynamicStack* stack_create();
// 销毁动态数组栈
void stack_destroy(DynamicStack* s);
// 入栈
void stack_push(DynamicStack* s, ElementType val);
// 出栈并返回栈顶元素
ElementType stack_pop(DynamicStack* s);
// 访问栈顶元素
ElementType  stack_peek(DynamicStack* s);
// 判空
bool is_empty(DynamicStack* s);
#endif // ! DYNAMIC_ARR_STACK_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> dynamic_stack.c </font>
</summary>
<pre> <code class="language-c">#include "dynamic_stack.h"
#define DEFAULT_CAPACITY 8  // 动态栈的默认容量
#define THRESHOLD 1024  // 扩容阈值
// 实现扩容机制
static void grow_capacity(DynamicStack* s) &#123;
    // 扩容策略: 超过阈值则 1.5 倍的扩容，否则 2 倍的扩容
    int new_capacity = (s-> capacity > THRESHOLD) ?
        (s-> capacity + (s-> capacity >> 1)) :
        (s-> capacity << 1);
    // 使用 realloc 函数实现扩容，重新分配内存
    ElementType * new_arr = realloc(s-> elements, new_capacity * sizeof(ElementType));
    if (new_arr == NULL) &#123;
        printf("Error: realloc failed in grow_capacity\n");
        exit(1);
    &#125;
    // 更新动态数组栈结构体的信息
    s-> elements = new_arr;
    s-> capacity = new_capacity;
&#125;
// 创建动态数组栈
DynamicStack* stack_create() &#123;
    DynamicStack* stack = calloc(1, sizeof(DynamicStack));
    if (stack == NULL)
    &#123;
        printf("Error: malloc failed in stack_create.\n");
        return NULL;
    &#125;
    stack-> size = 0;
    stack-> capacity = DEFAULT_CAPACITY;
    stack-> elements = malloc(DEFAULT_CAPACITY * sizeof(ElementType));
    if (stack-> elements == NULL)
    &#123;
        free(stack);
        printf("Error: malloc failed in stack_create.\n");
        return NULL;
    &#125;
    return stack;
&#125;
// 销毁动态数组栈
void stack_destroy(DynamicStack* s) &#123;
    // 先释放动态数组
    free(s-> elements);
    // 再释放栈结构体
    free(s);
&#125;
// 入栈
void stack_push(DynamicStack* s, ElementType val) &#123;
    if (s-> size >= s-> capacity)
    &#123;
        grow_capacity(s);
    &#125;
    s-> elements [s-> size] = val;
    s-> size++;
&#125;
// 出栈并返回栈顶元素
ElementType stack_pop(DynamicStack* s) &#123;
    if (is_empty(s)) &#123;
        printf("Error: stack is empty\n");
        exit(1);
    &#125;
    s-> size--;
    return s-> elements [s-> size];
&#125;
// 访问栈顶元素
ElementType  stack_peek(DynamicStack* s) &#123;
    if (is_empty(s)) &#123;
        printf("Error: stack is empty\n");
        exit(1);
    &#125;
    return s-> elements [s-> size - 1];
&#125;
// 判空
bool is_empty(DynamicStack* s) &#123;
    return s-> size == 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include "dynamic_stack.h"
int main(void) &#123;
    DynamicStack* s = stack_create();
    // 入队列 1000 个元素
    for (int i = 0; i < 1000; i++) &#123;
        stack_push(s, i);
    &#125;
    // 出队列直到队列为空
    while (! is_empty(s)) &#123;
        ElementType ele = stack_peek(s);
        printf("%d ", ele); // 预期会将 999-0 倒着输出打印
        stack_pop(s);
    &#125;
    printf("\n");
    // 再次尝试出栈, 此时会打印错误提示信息
    stack_pop(s);
    // 销毁队列
    stack_destroy(s);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="栈的应用场景">栈的应用场景</h3>
<p>栈特别适用那些存在 “后进先出”
逻辑的场景，在实际的开发，栈很常用。栈至少可以应用于以下领域：</p>
<ol type="1">
<li>函数调用机制</li>
<li>括号匹配问题</li>
<li>表达式求值问题</li>
<li>浏览器历史记录前进后退功能</li>
<li>深度优先遍历算法（一般直接用函数调用者递归实现）</li>
<li>…</li>
</ol>
<hr />
<h2 id="队列">队列</h2>
<h3 id="概述-1">概述</h3>
<p>队列是另一种操作受限的线性结构。但它的受限和栈是不同的：</p>
<ol type="1">
<li>队列只能在一端添加元素（队尾）</li>
<li>在另一端访问、删除元素（队头）</li>
</ol>
<p>队列就不用想象了，它就是我们生活中排队的场景，你只能在队尾插入一个元素，在队头删除一个元素。</p>
<p>在队列中，最先添加到队尾的元素总是最先在队头删除，遵循
<strong>先进先出（FIFO，First In First Out）</strong> 的原则。</p>
<p>如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311211052492.png" alt="队列-概念模型" style="zoom: 80%;" />
</div>
<p>队列这种数据结构的基本操作主要包括以下几种：</p>
<ol type="1">
<li>入队：在队尾添加一个元素，新元素成为新的队尾元素。</li>
<li>出队：在队头删除一个元素，第二个元素称为新的队头元素。</li>
<li>访问队头元素</li>
<li>判空</li>
<li>判满</li>
</ol>
<h3 id="设计思路-3">设计思路</h3>
<h4 id="数组队列模型">数组队列模型</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311231053386.png" alt="数组队列-方案三" style="zoom: 33%;" />
</div>
<p>这种方案，最核心的问题就是：如何移动两个索引，使得它们能够在数组内部循环移动呢？</p>
<p>使用取余运算符 “%” 即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rear = (rear + <span class="number">1</span>) % N</span><br><span class="line">front = (front + <span class="number">1</span>) % N</span><br></pre></td></tr></table></figure>
<p>解释： 对于数组的下标运算，几乎都是要涉及对数组长度 N
的取余运算，现在希望往后移动索引，而且希望从最后一个索引向后移动是第一个索引，所以就这样计算。</p>
<p>这样设计就实现了对数组前面空间的利用，避免了空间浪费，同时出入队的效率也很高。下面思考一个问题：</p>
<p>这种设计方案，如何进行队列判空和判满呢？</p>
<p>实际上如果就单纯按照上述方案设计循环队列，那么它们的判空和判满条件是一样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rear == front</span><br></pre></td></tr></table></figure>
<p>所以对于这两个操作我们还需要进行一点小优化，有两个选择：</p>
<p>（1）牺牲一个存储单元不存储元素，<strong>只要 rear 指向 front
的前一个位置就表示队列满了。</strong> 如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311231058261.png" alt="" style="zoom: 50%;" />
</div>
<p>在这种情况下：</p>
<ul>
<li><strong>队列满了的条件是：(rear + 1) % N == front</strong></li>
<li>队列为空的条件是：rear == front</li>
</ul>
<p>这种办法是教科书中讲数据结构经常使用的方案，在实际开发中可以用一个更简单粗暴，更易于实现和使用的方式——<strong>计数器</strong>。</p>
<p>（2）使用一个额外的计数器变量来统计数组中元素的个数，这样判空和判满都十分简洁了。具体而言可以参考下图的实现：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240415202036317.png" alt="数组队列-方案三改进图2" style="zoom: 50%;" />
</div>
<p>基于上述图中的模型，实现一个
<strong>固定长度的数组队列</strong>，需要注意的是：</p>
<ul>
<li><p><strong>front
用于记录队头元素，出队时就将该元素出队。</strong></p></li>
<li><p><strong>rear
用于指示下一个元素入队的索引，也就是说入队操作时直接将元素插入 rear
索引位置就可以了。</strong></p></li>
<li><p><strong>规定 front(包含)和
rear(不包含)索引之间的元素就是队列元素，出队操作时，直接向后移动索引
front 就可以了，不需要任何赋值操作。</strong></p></li>
<li><p><strong>front 向后移动的方式是：(front + 1) % N</strong></p></li>
<li><p><strong>rear 向后移动的方式是：(rear + 1) % N</strong></p></li>
</ul>
<h4 id="链表队列模型">链表队列模型</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240921154854107.png" alt="链表队列模型" style="zoom: 67%;" />
</div>
<h3 id="代码实现-3">代码实现</h3>
<h4 id="动态数组队列模型">动态数组队列模型</h4>
<details>
<summary>
<font size="4" color="orange"> dynamic_queue.h </font>
</summary>
<pre> <code class="language-c">#ifndef DYNAMIC_QUEUE_H
#define DYNAMIC_QUEUE_H
#include &lt; stdbool.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
typedef int ElementType;    // 该队列当前存储 int 元素
#define DEFAULT_CAPACITY 10 // 数组队列的初始长度是 10
#define THRESHOLD 1000  // 超过阈值每次扩容 1.5 倍扩，否则 2 倍的扩
// 定义队列结构体
typedef struct &#123;
    ElementType* data;   // 动态数组存储队列元素
    int front;           // 标记队头元素的索引
    int rear;            // 标记队尾元素下一个位置的索引
    int size;            // 当前队列中元素数量
    int capacity;        // 队列容量
&#125; DynamicQueue;
// 队列基本操作函数声明
// 创建动态数组队列
DynamicQueue* create_queue();
// 销毁动态数组队列
void destroy_queue(DynamicQueue* q);
// 判空
bool is_empty(DynamicQueue* q);
// 判满
bool is_full(DynamicQueue* q);
// 入队列
bool enqueue(DynamicQueue* q, ElementType data);
// 出队列并且返回队头元素
ElementType dequeue(DynamicQueue* q);
#endif // ! DYNAMIC_QUEUE_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> dynamic_queue.c </font>
</summary>
<pre> <code class="language-c">#include "dynamic_queue.h"
// 创建并初始化队列
DynamicQueue *create_queue() &#123;
    DynamicQueue *q = calloc(1, sizeof(DynamicQueue));
    if (q == NULL) &#123;
        printf("error: calloc failed in create_queue.\n");
        return NULL;
    &#125;
    // front、rear、size 自动初始化 0 值，无需再手动初始化了
    q-> data = calloc(DEFAULT_CAPACITY, sizeof(ElementType));    // 使用 calloc 避免随机值
    if (q-> data == NULL) &#123;
        printf("error: calloc failed in create_queue.\n");
        free(q);
        return NULL;
    &#125;
    q-> capacity = DEFAULT_CAPACITY;
    return q;
&#125;
// 销毁队列
void destroy_queue(DynamicQueue *q) &#123;
    free(q-> data);
    free(q);
&#125;
// 检查队列是否为空
bool is_empty(DynamicQueue *q) &#123;
    return q-> size == 0;
&#125;
// 检查队列是否已满
bool is_full(DynamicQueue *q) &#123;
    return q-> size == q-> capacity;
&#125;
/*
    这里采用一种简单粗暴的扩容手段:
    直接分配新容量的内存块
    然后遍历旧内存块中的队列元素, 将这些元素全部从头开始复制到新内存块中
    这样的操作在完成后, 需要更新 front 索引和 rear 索引
*/
static bool resize_queue(DynamicQueue *q) &#123;
    int old_capacity = q-> capacity;
    int new_capacity = (old_capacity < THRESHOLD) ?
        (old_capacity << 1) :
    (old_capacity + (old_capacity >> 1));
    // 重新分配一个新的, 更长的动态数组
    ElementType *new_data = malloc(new_capacity * sizeof(ElementType));
    if (new_data == NULL) &#123;
        printf("error: realloc failed in resize_queue.\n");
        return false;
    &#125;
    int curr = q-> front;    // curr 索引用于遍历整个队列中的元素
    int index = 0;
    while (index < q-> size) &#123;
        new_data [index] = q-> data [curr];
        curr = (curr + 1) % q-> capacity;
        index++;
    &#125; // while 循环结束时, new_data 就从头开始包含了队列的所有元素
    free(q-> data);
    q-> data = new_data;
    q-> front = 0;
    q-> rear = q-> size;
    q-> capacity = new_capacity;
    return true;
&#125;
// 入队操作
bool enqueue(DynamicQueue *q, ElementType data) &#123;
    if (is_full(q)) &#123;
        if (! resize_queue(q)) &#123;
            printf("error: 扩容失败.\n");
            return false; // 队列扩容失败, 入队也同步失败
        &#125;
    &#125;
    q-> data [q-> rear] = data;
    q-> rear = (q-> rear + 1) % q-> capacity;  // 循环队列
    q-> size++;
    return true;
&#125;
// 出队操作
ElementType dequeue(DynamicQueue *q) &#123;
    if (is_empty(q)) &#123;
        printf("error: 队列为空，无法出队。\n");
        exit(1);
    &#125;
    ElementType item = q-> data [q-> front];
    q-> front = (q-> front + 1) % q-> capacity; // 循环队列
    q-> size--;
    return item;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include "dynamic_queue.h"
int main(void) &#123;
    // 创建队列
    DynamicQueue* queue = create_queue();
    if (queue == NULL) &#123;
        printf("创建队列失败。\n");
        return 1;
    &#125;
    // 入队测试
    for (int i = 0; i < 15; i++) &#123;
        if (enqueue(queue, i)) &#123;
            printf("已入队: %d\n", i);
        &#125;
        else &#123;
            printf("入队失败: %d\n", i);
        &#125;
    &#125;
    // 打印队列容量和大小
    printf("队列容量: %d, 队列大小: %d\n", queue-> capacity, queue-> size);
    // 出队测试
    printf("正在出队...\n");
    while (! is_empty(queue)) &#123;
        printf("已出队: %d\n", dequeue(queue));
    &#125;
    // 销毁队列
    destroy_queue(queue);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h4 id="链表队列模型-1">链表队列模型</h4>
<details>
<summary>
<font size="4" color="orange"> list_queue.h </font>
</summary>
<pre> <code class="language-c">#ifndef LIST_QUEUE_H
#define LIST_QUEUE_H
#include &lt; stdbool.h&gt;
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
// 定义队列中的元素类型
typedef int ElementType;
// 队列节点的结构
typedef struct node_s &#123;
    ElementType data;
    struct node_s* next;
&#125; QueueNode;
// 队列的结构
typedef struct &#123;
    QueueNode* front;  // 队头结点指针
    QueueNode* rear;   // 队尾结点指针
&#125; LinkedListQueue;
// 函数声明
// 创建链式队列
LinkedListQueue* create_queue();
// 销毁链式队列
void destroy_queue(LinkedListQueue* q);
// 入队列
bool enqueue(LinkedListQueue* q, ElementType element);
// 出队列并返回队头元素
ElementType dequeue(LinkedListQueue* q);
// 访问队头元素
ElementType peek_queue(LinkedListQueue* q);
// 判空
bool is_empty(LinkedListQueue* q);
#endif // ! LIST_QUEUE_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> list_queue.c </font>
</summary>
<pre> <code class="language-c">#include "list_queue.h"
// 创建链式队列
LinkedListQueue* create_queue() &#123;
    return calloc(1, sizeof(LinkedListQueue));
&#125;
// 销毁链式队列
void destroy_queue(LinkedListQueue* q)
&#123;
    QueueNode* curr = q-> front;
    while (curr != NULL) &#123;
        QueueNode* temp = curr-> next;
        free(curr);
        curr = temp;
    &#125;
    free(q);
&#125;
// 入队列
bool enqueue(LinkedListQueue* q, ElementType element)
&#123;
    QueueNode* new_node = calloc(1, sizeof(QueueNode));
    if (new_node == NULL)
    &#123;
        printf("Error: malloc failed in enqueue.\n");
        return false;
    &#125;
    new_node-> data = element;
    new_node-> next = NULL;
    if (q-> front == NULL)
    &#123;
        q-> front = new_node;
        q-> rear = new_node;
    &#125;
    else
    &#123;
        q-> rear-> next = new_node;
        q-> rear = new_node;
    &#125;
    return true;
&#125;
// 出队列并返回队头元素
ElementType dequeue(LinkedListQueue* q)
&#123;
    if (is_empty(q))
    &#123;
        printf("The queue is empty.\n");
        exit(1);
    &#125;
    ElementType item = q-> front-> data;
    QueueNode* temp = q-> front;
    q-> front = temp-> next;
    if (q-> front == NULL)
    &#123;
        q-> rear == NULL;
    &#125;
    free(temp);
    return item;
&#125;
// 访问队头元素
ElementType peek_queue(LinkedListQueue* q)
&#123;
    if (is_empty(q))
    &#123;
        printf("The queue is empty.\n");
        exit(1);
    &#125;
    return q-> front-> data;
&#125;
// 判空
bool is_empty(LinkedListQueue* q)
&#123;
    return q-> front == NULL;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include "list_queue.h"
int main(void) &#123;
    LinkedListQueue* q = create_queue();
    // 逐一入队列
    enqueue(q, 1);
    enqueue(q, 2);
    enqueue(q, 3);
    enqueue(q, 4);
    enqueue(q, 5);
    enqueue(q, 6);
    // 先进先出，出队列全部元素直到队列为空
    while (! is_empty(q)) &#123;
        int val = peek_queue(q);
        printf("%d ", val); // 预期出队列顺序: 1 2 3 4 5 6
        dequeue(q);
    &#125;
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="队列的应用场景">队列的应用场景</h3>
<p>队列是一种非常实用的数据结构，由于其先进先出的特性，队列特别适用于那些需要按顺序处理元素的场景。比如：</p>
<ol type="1">
<li>操作系统的任务调度，进程/线程按照到达顺序来排队等待 CPU
执行权。</li>
<li>各种数据处理系统中的缓冲区/缓存机制。比如 stdin/stdout
缓冲区，先输入缓冲区的数据，总是先从缓冲区输出。</li>
<li>打印机的任务管理，当多个打印任务同时到达时，它们在队列中排队，按照提交的顺序进行打印。</li>
<li>后端应用系统中的消息队列。</li>
<li>广度优先搜索(比如二叉搜索树的层次遍历)</li>
<li>…</li>
</ol>
<hr />
<h2 id="哈希表">哈希表</h2>
<h3 id="哈希相关概念">哈希相关概念</h3>
<p>哈希（Hash）是一种将 <strong>任意长度大小</strong> 的输入转换处理成
<strong>固定长度大小</strong> 输出的过程：</p>
<ol type="1">
<li>输入可以是一个任意数字或字符串、也可以是一个任意文件等等。<strong>（一般来说同一个哈希过程，输入的类型应该是一致的，但长度大小不限制）</strong></li>
<li>普遍来说，<strong>哈希过程的输出会是一个固定长度的整数</strong>，这个整数就是常说的
<strong>哈希值</strong>。</li>
<li>实现哈希的过程中，代表转换处理规则的就是
<strong>哈希函数</strong>。</li>
</ol>
<p>哈希函数（Hash Function）是实现哈希过程的关键，负责将输入的任意数据
<strong>映射</strong> 到一个哈希值（一般是一个固定长度的整数）上。</p>
<p>哈希函数具有以下特点：</p>
<ol type="1">
<li><strong>同一个输入多次调用哈希函数，必须映射到同一输出上。映射不允许出现一对多。</strong></li>
<li>不同输入多次调用哈希函数，不要求映射到不同输出上。<strong>映射不要求完全一一对应，允许出现多对一，这就是哈希冲突。</strong></li>
</ol>
<p><strong>有关哈希的概念，总结如下：</strong></p>
<p>哈希(过程)：</p>
<ol type="1">
<li>哈希是一种可以接受各种类型、大小的输入，输出一个固定长度整数的过程。</li>
<li><strong>可以将哈希理解成一种特殊的映射，哈希映射，将一个理论无限的集合
A 映射到有限整数集合 B 上。</strong></li>
</ol>
<p><strong>哈希函数</strong>：哈希函数是哈希过程的核心，它决定了哈希映射过程的规则。</p>
<p><strong>哈希冲突</strong>：哈希是一种化无限为有限的映射，允许出现多对一，但绝不允许出现一对多。若映射中出现多对一，就是哈希冲突。哈希冲突可以减少，但绝不可能没有。</p>
<h3 id="哈希表相关概念">哈希表相关概念</h3>
<p>哈希表是一种基于 <strong>“键值对”</strong>
的存储方式的数据结构，能够提供快速的数据查找、插入和删除操作。</p>
<p>哈希表是能够存储键值对元素的数据结构，具体到存储的机制是：</p>
<ol type="1">
<li>先利用哈希函数计算键值对元素中 key <strong>(哈希表的 key
是唯一的)</strong> 对应的哈希值</li>
<li>然后根据哈希值的不同决定这个元素在哈希表中的存储位置。</li>
</ol>
<p>由于哈希冲突的存在，所以哈希表在具体存储元素时，不得不把多个元素存储在同一个位置上，这样就出现了
<strong>哈希桶</strong> 的概念：</p>
<ol type="1">
<li><strong>哈希桶是哈希表存储数据的基本单位，一个哈希表由多个哈希桶组成。</strong></li>
<li><strong>当一个新的键值对需要加入哈希表时，会使用哈希函数计算该键的哈希值，然后根据这个哈希值决定将键值对存储在哪个哈希桶中。</strong></li>
<li><strong>一般而言，每个哈希桶都可以存储一个或多个元素。</strong></li>
</ol>
<p>总之，一个哈希表的概念模型可以用下图描述(不涉及实现)：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311281546792.png" alt="哈希表的概念模型图" style="zoom: 33%;" />
</div>
<p>根据这个理论模型，我们不难发现：</p>
<p>假设在完美情况下，哈希冲突不出现，任何一个哈希桶都只用存储一个元素，那么这个哈希表就是一个数组。</p>
<p>也就是说在理想、完美的情况下，哈希表就是一个数组。当然这种情况，在现实里并不存在，哈希冲突是必然存在的。</p>
<h3 id="哈希函数">哈希函数</h3>
<p>哈希函数是整个哈希过程的核心，那么应该如何设计一个哈希函数呢？什么样的哈希函数是一个优秀的哈希函数呢？</p>
<p>在编程领域，哈希函数的最常见应用就是实现哈希表。为了哈希表的性能考虑，此哈希函数应该：</p>
<ol type="1">
<li>能够快速计算。在实现哈希表时，对安全性没有非常高的要求，但如果哈希函数的效率很差势必影响哈希表的性能。</li>
<li>均匀映射，尽量减少哈希冲突。哈希函数应该将输入均匀地映射到输出当中。这减少了哈希冲突的概率，意味着不同的输入值更有可能得到不同的哈希值。</li>
</ol>
<p>但如果将哈希函数运用到其他领域，比如文件校验，密码存储等(密码学场景)，对哈希函数的要求就会更高：</p>
<ol type="1">
<li>几乎没有哈希冲突。使得哈希值能够像指纹一样，可以作为输入的唯一标识。</li>
<li>通过哈希值逆向破解输入几乎不可能。</li>
<li>对输入的任何一点修改，都最好得到一个完全不同的哈希值。</li>
</ol>
<p>在非密码学场景(追求高效计算、不追求极致减少哈希冲突)，比较常用的哈希算法有：<strong>MurmurHash</strong>，该算法以高运行效率和分布均匀性著称，在实现哈希表时选择它非常合适。</p>
<p>在密码学场景中(追求极致减少哈希冲突，追求安全性)，比较常用的算法有：MD5，SHA1，SHA-256，SHA-3
等。MD5 和 SHA1 由于存在明显的安全漏洞，已基本被淘汰。SHA-256
是目前最常见、最推荐的密码学哈希算法。</p>
<p>在后续实现哈希表时，这里给出一个 MurmurHash 哈希算法在 C
语言中的实现函数：</p>
<details>
<summary>
<font size="4" color="orange"> Show Code </font>
</summary>
<pre> <code class="language-c">/* murmur_hash2 */
static uint32_t hash(const void* key, int len, uint32_t seed) &#123;
    const uint32_t m = 0x5bd1e995;
    const int r = 24;
    uint32_t h = seed ^ len;
    const unsigned char * data = (const unsigned char*)key;
    while (len >= 4) &#123;
        uint32_t k = *(uint32_t*)data;
        k *= m;
        k ^= k >> r;
        k *= m;
        h *= m;
        h ^= k;
        data += 4;
        len -= 4;
    &#125;
    switch (len) &#123;
        case 3: h ^= data [2] << 16;
        case 2: h ^= data [1] << 8;
        case 1: h ^= data [0];
            h *= m;
    &#125;;
    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;
    return h;
&#125;</code>
</pre>
</details>
<p>MurmurHash
是一种非加密哈希函数，适用于一般的哈希检索操作。它以高运行速度和分布均匀性而闻名。其中
uint32_t 表示无符号 32 位整型，要想使用它需要包含 <strong>头文件
&lt;stdint.h&gt;</strong>。</p>
<p>该函数调用需要三个参数：</p>
<ol type="1">
<li><p><strong>void* key，也就是需要计算哈希值的 key 元素。</strong>
此形参的类型是
void*，这意味着它可以传入任何类型的数据，提高了函数的通用性。</p>
<ul>
<li><p>如果 key 是基本数据类型，那就传入指向基本数据类型的指针</p></li>
<li><p>如果 key
本身就是一个指针类型，比如字符串，那么就直接传入这个指针就可以了。</p></li>
</ul></li>
<li><p>int len，表示哈希函数要处理的 key 的大小长度。key
若是字符串可以使用函数 strlen 计算，若是其它类型可以使用 sizeof
计算。</p></li>
<li><p>uint32_t seed，种子值。</p>
<ul>
<li><p>此哈希函数会根据 key 和 seed 共同生成一个哈希值</p></li>
<li><p>不同的种子值会导致相同的数据产生不同的哈希值。<strong>需要注意的是，在程序一次运行中，同一个哈希表应该具有相同的种子值！</strong></p></li>
<li><p>最常见的设置种子值的方式就是用时间戳，也就是
<code>time(NULL);</code> 函数调用。</p></li>
</ul></li>
</ol>
<h3 id="哈希表的核心操作">哈希表的核心操作</h3>
<p>对于一个哈希表而言，最核心的操作是三个：</p>
<ol type="1">
<li><p>插入一个新的键值对。<strong>(哈希表中的 key
是唯一的)</strong></p>
<ul>
<li><p>如果 key 已存在重复，更新对应 value</p></li>
<li><p>如果 key 不存在，将新的键值对添加到哈希表中。</p></li>
</ul></li>
<li><p>根据 key 查找目标 value。</p></li>
<li><p>根据 key 删除目标键值对元素。</p></li>
</ol>
<p>一般来说，不管采用何种方式实现哈希表，都要尽量保证这三个基本操作的时间复杂度接近
O(1)</p>
<p>除此之外，遍历哈希表也是一个常见操作。</p>
<h3 id="如何实现一个哈希表">如何实现一个哈希表？</h3>
<p>在实现一个哈希表的过程中，最需要关注的是两个问题：</p>
<ol type="1">
<li>选择哪一个哈希函数？这一点我们在上面已经给出了答案。</li>
<li>如何设计哈希桶呢？由于哈希冲突一定存在，哈希桶的设计要保证能够处理这种冲突导致的多个元素要存储在一个哈希桶中。所以换句话说，这个问题就是——如何处理哈希冲突呢？</li>
</ol>
<p>关于这个话题，这里给出两种常见办法。</p>
<h4 id="开放寻址法">开放寻址法</h4>
<p>哈希表是一种增查频繁的数据结构，这让我们想起了数组，因为数组根据索引增查效率很高，于是直接将一个数组当成哈希表。那怎么处理冲突问题呢？</p>
<p>一旦出现哈希冲突，就采取下列办法找到一个空位置：</p>
<ol type="1">
<li>线性探测法，逐一探测下一个位置是否为空位置，直到找到。</li>
<li>平方探测法，每次探测都会检查当前位置索引加上探测次数的平方（1, 4, 9,
16, …）的位置。</li>
<li>再哈希法。使用多个哈希函数共同实现哈希表，当插入一个元素时，首先使用第一个哈希函数计算其位置，若冲突，则继续调用后续函数，直到不冲突为止。</li>
<li>…</li>
</ol>
<p>这种解决哈希冲突的方式，就是常说到的
<strong>“开放寻址法”</strong>。</p>
<p>开放寻址法听起来实现简单，利用数组的随机访问，内存连续效率高，但实际上：</p>
<ol type="1">
<li><p>删除操作实现非常困难，复杂。</p>
<ul>
<li><p>删除操作如果只是简单修改数据，那么后续查找可能出现误访问，于是可能需要特殊标记以表示元素被删除。这样实现很麻烦，而且会拖累查询的效率。</p></li>
<li><p>如果通过整体挪动数组元素来表示删除，那删除效率就太差了，也不太可取。</p></li>
</ul></li>
<li><p>数据量较大时哈希冲突难以解决。</p></li>
<li><p>开放寻址法必然意味着，需要经常进行数组扩容。</p>
<ul>
<li><p>这个过程，往往需要重分配内存</p></li>
<li><p>然后将原数组中所有的元素再哈希，拷贝到新数组中。</p></li>
<li><p>这样的一套操作下来，成功过于高昂。</p></li>
</ul></li>
</ol>
<p>但也不是说这种方式完全一无是处，当你有以下场景时：</p>
<ol type="1">
<li>数据量比较少，不需要频繁扩容数组。</li>
<li>删除操作几乎不做，只做增查操作。</li>
</ol>
<p>这时倒也不妨可以使用 “开放寻址法” 来实现哈希表。</p>
<p>但对于大多一般开发场景而言，哈希表的实现基本不会采用开放寻址法。</p>
<h4 id="拉链法常用">拉链法(常用)</h4>
<p>解决哈希冲突，设计实现哈希桶，在开发中最常见的方式还是拉链法，也就是采用
“数组 + 链表” 的方式来实现哈希桶。具体而言：以一个
<strong>键值对结点指针数组</strong>
为哈希表的基本结构，此数组的每一个存储单元都指向一个键值对结点链表。</p>
<p>这种设计下哈希表的基本操作思路如下(大致)：</p>
<ol type="1">
<li><p>进行插入操作时，计算 key
的哈希值以确定存储的哈希桶位置，接下来：</p>
<ul>
<li><p>若哈希桶为空，则此结点成为哈希桶的第一个元素。</p></li>
<li><p>若哈希桶不为空，则需要遍历哈希桶，如果 “Key” 已存在，则更新
Value。若 “Key”
不存在，则再向哈希桶中添加一个元素。此时哈希桶中的多个元素，是以链表的形式挂起来的。</p></li>
</ul></li>
<li><p>进行查找操作时：同样先计算 key
的哈希值，然后在对应索引的链表中遍历查找这个键。</p></li>
<li><p>进行删除操作时：也是先计算 key
的哈希值，然后在对应链表中找到并移除这个键值对。</p></li>
</ol>
<p>拉链法实现的哈希表，实际上就是数组的高访问效率和链表的灵活性的综合应用，是最常见的哈希表实现方式。如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311262031612.png" alt="拉链法-实现哈希表" style="zoom: 33%;" />
</div>
<p>下面，基于 C
语言，以拉链法来实现一个固定容量的哈希表。（若以动态数组实现哈希表，就可实现扩容）</p>
<h3 id="代码实现-4">代码实现</h3>
<details>
<summary>
<font size="4" color="orange"> hash_map.h </font>
</summary>
<pre> <code class="language-c">#ifndef HASH_MAP_H
#define HASH_MAP_H
#include &lt; stdint.h&gt; // 包含它是为了使用别名 uint32_t
#include &lt; stdbool.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
#include &lt; string.h&gt;
#define HASHMAP_CAPACITY 10 // 哈希表中数组的长度固定是 10
// 此时哈希表用于存储字符串类型的键值对
typedef char* KeyType;
typedef char* ValueType;
// 键值对结点
typedef struct node_s &#123;
    KeyType key;
    ValueType val;
    struct node_s* next;
&#125; KeyValueNode;
typedef struct &#123;
    // 哈希桶
    KeyValueNode* buckets [HASHMAP_CAPACITY];    // 直接给定哈希桶的数量是 10 个
    // 哈希函数需要的种子值
    uint32_t hash_seed;
&#125; HashMap;
// 创建一个固定容量的哈希表
HashMap* hashmap_create();
// 销毁一个哈希表
void hashmap_destroy(HashMap* map);
// 插入一个键值对
ValueType hashmap_put(HashMap* map, KeyType key, ValueType val);
// 查询一个键值对
ValueType hashmap_get(HashMap* map, KeyType key);
// 删除某个键值对
bool hashmap_remove(HashMap* map, KeyType key);
#endif // ! HASH_MAP_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> hash_map.c </font>
</summary>
<pre> <code class="language-c">#include "hash_map.h"
/* murmur_hash2 */
static uint32_t hash(const void* key, int len, uint32_t seed) &#123;
    const uint32_t m = 0x5bd1e995;
    const int r = 24;
    uint32_t h = seed ^ len;
    const unsigned char * data = (const unsigned char*)key;
    while (len >= 4) &#123;
        uint32_t k = *(uint32_t*)data;
        k *= m;
        k ^= k >> r;
        k *= m;
        h *= m;
        h ^= k;
        data += 4;
        len -= 4;
    &#125;
    switch (len) &#123;
    case 3: h ^= data [2] << 16;
    case 2: h ^= data [1] << 8;
    case 1: h ^= data [0];
        h *= m;
    &#125;;
    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;
    return h;
&#125;
// 创建一个固定容量的哈希表
HashMap* hashmap_create() &#123;
    HashMap* map = calloc(1, sizeof(HashMap));
    if (map == NULL) &#123;
        printf("error: calloc failed in hashmap_create.\n");
        exit(-1);
    &#125;
    map-> hash_seed = time(NULL);
    return map;
&#125;
// 销毁一个哈希表
void hashmap_destroy(HashMap* map) &#123;
    // 遍历数组, 然后销毁哈希桶中的链表, 最后销毁 HashMap 结构体
    for (size_t i = 0; i < HASHMAP_CAPACITY; i++) &#123;
        KeyValueNode* curr = map-> buckets [i];
        while (curr != NULL) &#123;
            KeyValueNode* tmp = curr-> next;
            free(curr);
            curr = tmp;
        &#125;
    &#125;
    free(map);
&#125;
// 插入一个键值对
ValueType hashmap_put(HashMap* map, KeyType key, ValueType val) &#123;
    // 1.计算哈希值确定哈希桶的位置
    int idx = hash(key, strlen(key), map-> hash_seed) % HASHMAP_CAPACITY;
    // 2.遍历哈希桶，查找 Key 是否重复
    KeyValueNode* curr = map-> buckets [idx];
    while (curr != NULL) &#123;
        // 比较字符串
        if (strcmp(key, curr-> key) == 0) &#123;
            // key 已存在, 更新 value, 并返回旧 value
            ValueType old_val = curr-> val;
            curr-> val = val;
            return old_val;
        &#125;
        curr = curr-> next;
    &#125;
    // 3.只要 Key 不重复肯定都要插入，于是无脑使用链表头插法插入结点
    KeyValueNode* new_node = malloc(sizeof(KeyValueNode));
    if (new_node == NULL) &#123;
        printf("Error: malloc failed in hashmap_put.\n");
        exit(1);
    &#125;
    new_node-> key = key;    // key 和 val 都是指针类型，可以直接 "=" 赋值
    new_node-> val = val;
    // 链表头插法
    new_node-> next = map-> buckets [idx]; // 新结点指向原本的第一个结点
    map-> buckets [idx] = new_node;   // 更新头指针
    // 没有更新键值对返回空指针
    return NULL;
&#125;
// 查询一个键值对
ValueType hashmap_get(HashMap* map, KeyType key) &#123;
    // 1.计算哈希值确定哈希桶的位置
    int idx = hash(key, strlen(key), map-> hash_seed) % HASHMAP_CAPACITY;
    // 2.遍历哈希桶，查找 Key 是否存在
    KeyValueNode* curr = map-> buckets [idx];
    while (curr != NULL) &#123;
        // 比较字符串
        if (strcmp(key, curr-> key) == 0) &#123;
            // 已找到目标键值对
            return curr-> val;
        &#125;
        curr = curr-> next;
    &#125;
    // 目标键值对不存在
    return NULL;
&#125;
// 删除某个键值对
bool hashmap_remove(HashMap* map, KeyType key) &#123;
    // 1.计算哈希值确定哈希桶的位置
    int idx = hash(key, strlen(key), map-> hash_seed) % HASHMAP_CAPACITY;
    // 2.初始化两个指针, 用于删除结点
    KeyValueNode* curr = map-> buckets [idx];
    KeyValueNode* prev = NULL;
    // 3.遍历链表查找目标 Key
    while (curr != NULL) &#123;
        // 比较字符串
        if (strcmp(key, curr-> key) == 0) &#123;
            // 已找到目标键值对
            if (prev == NULL) &#123;
                // 删除的是第一个结点
                map-> buckets [idx] = curr-> next;
            &#125;
            else
            &#123;
                // 删除的不是第一个结点
                prev-> next = curr-> next;
            &#125;
            // free 结点
            free(curr);
            return true;    // 删除成功
        &#125;
        prev = curr;        // 更新 prev 为当前节点
        curr = curr-> next;  // 当前结点向后移动
    &#125;
    // 没找到目标键值对, 删除失败
    return false;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#include "hash_map.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(void) &#123;
    // 创建哈希表
    HashMap* map = hashmap_create();
    if (map == NULL) &#123;
        printf("哈希表创建失败。\n");
        return 1;
    &#125;
    // 插入键值对
    hashmap_put(map, "key1", "value1");  // 首次插入，应成功
    hashmap_put(map, "key2", "value2");  // 再插一个新键值对，应成功
    char* old_value = hashmap_put(map, "key1", "value3");  // 更新已存在的键值对，应返回旧值 "value1"
    printf("更新键值对时返回的旧值应为 value1，实际返回：%s\n", old_value);
    // 查询键值对
    char* value = hashmap_get(map, "key1");
    printf("期待得到 value3，实际得到：%s\n", value);  // 预期输出 value3
    value = hashmap_get(map, "key2");
    printf("期待得到 value2，实际得到：%s\n", value);  // 预期输出 value2
    value = hashmap_get(map, "key3");
    if (value == NULL) &#123;
        printf("如预期，key3 未找到\n");  // 预期找不到 key3
    &#125;
    // 删除键值对
    bool deleted = hashmap_remove(map, "key1");  // 删除 key1, 预期删除成功
    if (deleted) &#123;
        printf("key1 成功删除。\n");
    &#125;
    deleted = hashmap_remove(map, "key3");  // 尝试删除不存在的 key3, 预期删除失败
    if (! deleted) &#123;
        printf("key3 未找到且未删除，符合预期。\n");
    &#125;
    // 销毁哈希表
    hashmap_destroy(map);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析">性能分析</h3>
<p>拉链法解决哈希冲突实现的哈希表，在选择合适的哈希算法，键值对较为平均分布的前提下，其性能取决于哈希表中链表的
<strong>平均长度 L</strong>：</p>
<ol type="1">
<li>在 <strong>最佳情况</strong>
下，即哈希函数均匀分布且冲突较少时，哈希表的插入、查询和删除操作的效率非常高，接近
O(1)。</li>
<li>在 <strong>最坏情况</strong>
下，特别是哈希冲突很多导致链表过长时，这些操作的效率会降低，接近
O(L)，因为此时的哈希表访问几乎相当于链表的访问。</li>
</ol>
<p>为了保证哈希表的性能，就需要控制链表的长度不能太长，也就是要
<strong>控制哈希表不能太满</strong>，要始终留出一定的空位，这样才不会出现过多的元素用链表存储的情况。</p>
<p>为了衡量一个哈希表满的程度，我们提出了 <strong>“负载因子(Load Factor
)”</strong> 的概念： <span class="math display">\[
负载因子 = \frac{哈希表中的键值对总数}{哈希表底层数组的长度}
\]</span> 一般来说，负载因子在 0.7/0.75
以下时，哈希表处在健康、性能优秀的状态。但一旦超出这个阈值，就意味着哈希冲突会增多，链表平均长度变长，从而导致性能下降。</p>
<p>此时，为了维持哈希表的高效性能，通常采取的措施是“扩容”和“重新哈希”。在拉链法的哈希表中也就是
<strong>对数组进行扩容，然后将所有元素重新哈希再映射到新哈希表中</strong>。</p>
<p>既然要扩容，那就需要使用动态数组实现哈希桶的底层，涉及到内存重分配、以及全部元素重新哈希确定存储的哈希桶，显然是一个非常耗费性能的操作。因此，这个过程应该尽量避免频繁发生。</p>
<h3 id="实现动态哈希表">实现动态哈希表</h3>
<h4 id="设计思路-4">设计思路</h4>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202403011402087.png" alt="动态哈希表-概念模型图" style="zoom: 33%;" />
</div>
<h4 id="代码实现-5"><strong>代码实现</strong></h4>
<details>
<summary>
<font size="4" color="orange"> dynamic_hashmap.h </font>
</summary>
<pre> <code class="language-c">#ifndef DYNAMIC_HASHMAP_H
#define DYNAMIC_HASHMAP_H
#include &lt; stdint.h&gt;
#include &lt; stdbool.h&gt;
#include &lt; string.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
typedef char* KeyType;
typedef char* ValueType;
typedef struct node_s &#123;
    KeyType key;
    ValueType val;
    struct node_s* next;
&#125; KeyValueNode;
typedef struct &#123;
    KeyValueNode** buckets;     // 此时哈希桶是一个动态数组，指向 char*元素的指针，所以是一个二级指针
    int size;               // 键值对的个数
    int capacity;           // 数组的长度
    uint32_t hash_seed;     // 哈希函数需要的种子值
&#125; DynamicHashMap;
// 创建一个固定容量的哈希表
DynamicHashMap* hashmap_create();
// 销毁一个哈希表
void hashmap_destroy(DynamicHashMap* map);
// 插入一个键值对
ValueType hashmap_put(DynamicHashMap* map, KeyType key, ValueType val);
// 查询一个键值对
ValueType hashmap_get(DynamicHashMap* map, KeyType key);
// 删除某个键值对
bool hashmap_remove(DynamicHashMap* map, KeyType key);
#endif // ! DYNAMIC_HASHMAP_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> dynamic_hashmap.c </font>
</summary>
<pre> <code class="language-c">#include "dynamic_hashmap.h"
#define DEFAULT_CAPACITY 8  // 哈希表的初始默认容量是 8
#define LOAD_FACTOR_THRESHOLD  0.75     // 负载因子的阈值
#define CAPACITY_THRESHOLE 1024     // 数组容量的阈值
/* murmur_hash2 */
static uint32_t hash(const void* key, int len, uint32_t seed) &#123;
    const uint32_t m = 0x5bd1e995;
    const int r = 24;
    uint32_t h = seed ^ len;
    const unsigned char * data = (const unsigned char*)key;
    while (len >= 4) &#123;
        uint32_t k = *(uint32_t*)data;
        k *= m;
        k ^= k >> r;
        k *= m;
        h *= m;
        h ^= k;
        data += 4;
        len -= 4;
    &#125;
    switch (len) &#123;
    case 3: h ^= data [2] << 16;
    case 2: h ^= data [1] << 8;
    case 1: h ^= data [0];
        h *= m;
    &#125;;
    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;
    return h;
&#125;
// 创建一个固定容量的哈希表
DynamicHashMap* hashmap_create() &#123;
    DynamicHashMap* map = calloc(1, sizeof(DynamicHashMap));
    if (map == NULL)
    &#123;
        printf("Error: malloc failed in hashmap_create.\n");
        exit(1);
    &#125;
    map-> buckets = calloc(DEFAULT_CAPACITY, sizeof(KeyValueNode*));
    if (map-> buckets == NULL)
    &#123;
        printf("Error: malloc failed in hashmap_create.\n");
        free(map);
        exit(1);
    &#125;
    map-> capacity = DEFAULT_CAPACITY;
    map-> hash_seed = time(NULL);
    return map;
&#125;
// 销毁一个哈希表
void hashmap_destroy(DynamicHashMap* map) &#123;
    // 1.先遍历动态数组销毁链表的每一个结点
    for (int i = 0; i < map-> capacity; i++) &#123;
        KeyValueNode* curr = map-> buckets [i];
        while (curr != NULL) &#123;
            KeyValueNode* tmp = curr-> next;
            free(curr);
            curr = tmp;
        &#125;
    &#125;
    // 2.再销毁动态数组
    free(map-> buckets);
    // 3.最后销毁哈希表结构体
    free(map);
&#125;
static void rehash(KeyValueNode * curr, KeyValueNode** new_table, int new_capacity, uint32_t seed) &#123;
    int len = strlen(curr-> key);
    int idx = hash(curr-> key, len, seed) % new_capacity;
    curr-> next = new_table [idx];
    new_table [idx] = curr;
&#125;
// 对哈希表进行扩容操作
static void grow_capacity(DynamicHashMap* map) &#123;
    /*
    * 扩容策略：
    * 1.如果容量没有达到阈值，那就每次将长度扩大为原先的 2 倍
    * 2.如果容量达到阈值，此时哈希表已经很长了，为了避免扩容过程性能损耗过大
    *   所以扩容保守一些，每次只扩容阈值长度的容量
    *
    * 扩容的过程：
    * 1.每个键值对结点都要重新计算哈希值，重新映射到新哈希桶中(新数组)
    * 2.原先的动态数组的链表很复杂，难以进行重哈希操作，建议直接丢弃它
    * 重新创建一个新动态数组
    */
    int new_capacity = (map-> capacity <= CAPACITY_THRESHOLE)
        ? (map-> capacity << 1) : (map-> capacity + CAPACITY_THRESHOLE);
    KeyValueNode** new_buckets = calloc(new_capacity, sizeof(KeyValueNode*));
    if (new_buckets == NULL) &#123;
        printf("Error: calloc failed in grow_capacity\n");
        exit(1);
    &#125;
    uint32_t seed = time(NULL);
    for (size_t i = 0; i < map-> capacity; i++)
    &#123;
        KeyValueNode* curr = map-> buckets [i];
        while (curr != NULL) &#123;
            KeyValueNode* next = curr-> next;
            rehash(curr, new_buckets, new_capacity, seed);
            curr = next;
        &#125;
    &#125;
    // 将旧动态数组 free，但是注意不要 free 键值对结点，结点已经被链接到新数组中了。
    free(map-> buckets);
    // 更新 HashMap 的信息
    map-> buckets = new_buckets;
    map-> capacity = new_capacity;
    map-> hash_seed = seed;
    &#125;
    // 插入一个键值对
    // 1. 如果 key 不存在，则添加键值对结点
    // 2. 如果 key 存在，则更新 val，将旧的 val 返回
    ValueType hashmap_put(DynamicHashMap* map, KeyType key, ValueType val) &#123;
    // 计算 key 的哈希值确定存储位置
    int idx = hash(key, strlen(key), map-> hash_seed) % (map-> capacity);
    // 遍历链表
    KeyValueNode* curr = map-> buckets [idx];
    while (curr != NULL) &#123;
        if (strcmp(key, curr-> key) == 0) &#123;
            // 更新 key 关联的 val, 并将旧的 value 返回
            ValueType old_val = curr-> val;
            curr-> val = val;
            return old_val;
        &#125;
        curr = curr-> next;
    &#125; // while 循环结束时, curr 是一个 NULL
    // 键值对不存在，即需要将键值对插入
    // 插入操作前需要计算当前哈希表的负载因子
    double load_factor = 1.0 * map-> size / map-> capacity;
    if (load_factor >= LOAD_FACTOR_THRESHOLD)
    &#123;
        // 当前哈希表负载因子已达到阈值，将动态数组进行扩容
        grow_capacity(map);
        // 数组长度已变，需要再哈希确定当前键值对的存储位置
        idx = hash(key, strlen(key), map-> hash_seed) % (map-> capacity);
    &#125;
    // 开始插入新键值对
    KeyValueNode* new_node = calloc(1, sizeof(KeyValueNode));
    if (new_node == NULL)
    &#123;
        printf("Error: calloc failed in grow_capacity\n");
        exit(1);
    &#125;
    // 初始化结点
    new_node-> key = key;
    new_node-> val = val;
    // 链表的头插法
    new_node-> next = map-> buckets [idx];
    map-> buckets [idx] = new_node;
    // 不要忘记更新 size
    map-> size++;
    return NULL;
    &#125;
    // 查询一个键值对
    ValueType hashmap_get(DynamicHashMap* map, KeyType key) &#123;
    // 计算 key 的哈希值确定位置
    int idx = hash(key, strlen(key), map-> hash_seed) % (map-> capacity);
    // 遍历链表
    KeyValueNode* curr = map-> buckets [idx];
    while (curr != NULL) &#123;
        if (strcmp(key, curr-> key) == 0) &#123;
            return curr-> val;
        &#125;
        curr = curr-> next;
    &#125;
    return NULL;
    &#125;
    // 删除某个键值对
    bool hashmap_remove(DynamicHashMap* map, KeyType key) &#123;
    // 计算 key 的哈希值确定位置
    int idx = hash(key, strlen(key), map-> hash_seed) % (map-> capacity);
    // 遍历链表
    KeyValueNode* curr = map-> buckets [idx];
    KeyValueNode* prev = NULL;
    while (curr != NULL) &#123;
        if (strcmp(key, curr-> key) == 0) &#123;
            if (prev == NULL)
            &#123;
                map-> buckets [idx] = curr-> next;
            &#125;
            else
            &#123;
                prev-> next = curr-> next;
            &#125;
            free(curr);
            map-> size--;
            return true;
        &#125;
        prev = curr;
        curr = curr-> next;
    &#125;
    return false;
    &#125;</code>
    </pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include "dynamic_hashmap.h"
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; string.h&gt;
#define N 100 // 初始容量是 8，设置为 10 足以触发一次扩容
int main() &#123;
    // 创建哈希表
    DynamicHashMap* map = hashmap_create();
    if (map == NULL) &#123;
        printf("哈希表创建失败。\n");
        return 1;
    &#125;
    // 插入多个键值对以触发扩容
    char tmp_key [1024], tmp_val [1024];
    for (int i = 0; i < N; i++) &#123;
        /*
            sprintf 是一个将格式化的数据输出到一个字符数组中，并最终保存为字符串的标准库函数
            第一个参数是输出的目的地字符串
            后面的参数则和 printf 使用方式一样
        */
        sprintf(tmp_key, "key%d", i);
        sprintf(tmp_val, "value%d", i);
        // 使用 calloc 分配和复制键值对
        char* key = calloc(strlen(tmp_key) + 1, sizeof(char));
        char* val = calloc(strlen(tmp_val) + 1, sizeof(char));
        strcpy(key, tmp_key);
        strcpy(val, tmp_val);
        hashmap_put(map, key, val);
        printf("插入 %s: %s\n", key, val);
    &#125;
    // 检查扩容前后的数据一致性
    bool flag = true;
    for (int i = 0; i < N; i++) &#123;
        sprintf(tmp_key, "key%d", i);
        ValueType ret_val = hashmap_get(map, tmp_key);
        sprintf(tmp_val, "value%d", i);
        if (ret_val == NULL || strcmp(ret_val, tmp_val) != 0) &#123;
            printf("错误：数据不一致，键 %s 应有的值为 %s，检索得到的值为 %s\n",
                tmp_key, tmp_val,
                ((ret_val != NULL) ? ret_val : "null"));
            flag = false;   // 若数据插入有问题，则修改标志为 false
        &#125;
    &#125;
    if (flag) &#123;
        printf("所有数据在扩容后仍正确无误。\n");
    &#125;
    // free 所有堆上分配的字符串
    for (int i = 0; i < map-> capacity; i++) &#123;
        KeyValueNode* curr = map-> buckets [i];
        while (curr != NULL) &#123;
            free(curr-> key);   // 释放键字符串
            free(curr-> val);   // 释放值字符串
            curr = curr-> next;
        &#125;
    &#125;
    // 销毁哈希表
    hashmap_destroy(map);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="哈希表的应用场景">哈希表的应用场景</h3>
<p>哈希表的应用十分广泛，任何编程语言的程序在日常开发中，哈希表都是必须要使用的数据结构。它大致有以下常见的用途：</p>
<ol type="1">
<li>用作容器，存储键值对元素。用作容器是哈希表最常见的使用场景之一，毕竟键值对数据在开发中出现的频率很高，比如
“用户名-密码”
等。常见的高级编程语言，往往都会提供现成的哈希表库实现，比如：
<ol type="1">
<li>C++ 中的 <code>unordered_map</code> 和 <code>unordered_set</code>。
<ul>
<li>map
是是一种存储键值对的哈希表容器，提供了高效的插入，查询，删除等操作。</li>
<li>set
是一种基于哈希表的集合容器，它存储唯一元素，并提供高效的成员插入、查找和删除操作。</li>
</ul></li>
<li>Java 中的 <code>HashMap</code> 和 <code>HashSet</code> 以及
<code>HashTable</code>，它们都是基于哈希表实现的集合容器。</li>
</ol></li>
<li>在算法领域，哈希表还经常用于以下场景中：
<ol type="1">
<li><strong>查找重复或唯一元素</strong>：哈希表提供了快速查询和插入的功能，且
Key 唯一使得它在查重或查找唯一元素时特别好用。</li>
<li><strong>计数器应用</strong>：统计频率次数，也是哈希表经常应用的场景。</li>
</ol></li>
<li>哈希表可以用于实现数据库的索引，提高数据库的访问效率。</li>
<li>哈希表还常用于实现缓存，利用其快速查询的特点，用于快速查询缓存的消息。比如目前业界最流行的高速缓存中间件——Redis，它有个别名叫：键值对内存数据库，哈希表是
Redis 最常用的类型之一。</li>
</ol>
<hr />
<h2 id="二叉搜索树">二叉搜索树</h2>
<h3 id="二叉树">二叉树</h3>
<p>树是一种层次化的数据结构，它在现实生活和计算机科学中广泛存在并发挥重要作用。比如：</p>
<ol type="1">
<li>族谱(Family Tree)</li>
<li>组织架构</li>
<li>计算机文件系统的目录结构</li>
<li>…</li>
</ol>
<p>树这种数据结构的特点，是从一个单一的根结点开始，分支出多个结点，每个结点又可能有自己的子结点，形成一个分层次的树状结构。</p>
<p>不过在众多的树形结构中，我们只学习二叉树，原因很简单，它很重要！</p>
<p>它有多重要呢？</p>
<p>单就面试而言，在 LeetCode 中二叉树相关的题目共有 300
多道，占据总题目的近三分之一。同时，二叉树在整个算法板块中还起到承上启下的作用：它不但是数组和链表的延伸，又可以作为图的基础。总之，非常重要！</p>
<p>那什么是 <strong>二叉树(BinaryTree)</strong> 呢？</p>
<p><strong>二叉树的定义：二叉树是一棵树，并且二叉树的每个结点最多有两棵子树。二叉树的子树又分为左子树和右子树。</strong></p>
<p>从根结点开始，每个结点最多有两棵子树，这就是一棵
“二叉树”。二叉树有两种比较独特的形态：完全二叉树和满二叉树。</p>
<p>完全二叉树，若二叉树的深度为 h，除第 h
层外，其它各层(1～h-1)的结点数目都达到最大值，第 h
层的结点都连续排列在最左边，这样的二叉树就是完全二叉树。</p>
<p>满二叉树，每一层的结点数目都达到最大值(包括最下面一层)。</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202311300942801.png" alt="完全二叉树和满二叉树-示意图" style="zoom: 67%;" />
</div>
<h3 id="二叉搜索树-1">二叉搜索树</h3>
<p><strong>二叉搜索树是一种特殊的二叉树，其中每个结点的左子树只包含小于当前结点的值，右子树只包含大于当前结点的值。</strong></p>
<p>当然二叉搜索树的定义非常适合使用递归：</p>
<p>二叉搜索树是一种特殊的二叉树，从根结点开始，其每个结点都满足：</p>
<ol type="1">
<li>左子树中的每个结点的值都小于该结点的值，并且左子树本身也是二叉搜索树</li>
<li>右子树中的每个结点的值都大于该结点的值，并且右子树本身也是二叉搜索树</li>
</ol>
<p>所以二叉搜索树在定义时就已经和递归绑定了，我们在下面处理二叉搜索树时，递归是常用的手段。</p>
<p>如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312011624046.png" alt="二叉搜索树-示意图" style="zoom: 33%;" />
</div>
<p><strong>需要注意的是，二叉搜索树只是在二叉树的基础上规定了结点取值的大小关系，二叉搜索树并不一定就是完全二叉树、满二叉树。</strong></p>
<h3 id="设计思路-5">设计思路</h3>
<p>可以用一个结构体描述二叉搜索树的某个结点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="comment">// 二叉搜索树的结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"> KeyType key;       <span class="comment">// 结点 key 值, 具有唯一性</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span> <span class="comment">// 左子树</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span>    <span class="comment">// 右子树</span></span><br><span class="line">&#125; TreeNode;</span><br></pre></td></tr></table></figure>
<p>其中 key
决定了结点在树中的存储位置，也是搜索的凭证。所以出于简化操作的目的，大多二叉搜索树都会规定
<strong>key 是唯一的</strong>。</p>
<p>二叉搜索树最重要、基础的操作有以下：</p>
<ol type="1">
<li>插入。向树中添加一个新的结点。这个操作需要保持二叉搜索树的性质，即插入的结点必须放置在保持左子结点小于父结点，且右子结点大于父结点的正确位置上。</li>
<li>搜索。根据 key
查找目标结点。在二叉搜索树中，搜索操作可以高效进行，通过比较目标值与结点值来决定向左子树或右子树移动。搜索操作的实现是比较简单的。</li>
<li><strong>删除。根据 key
从树中删除某个结点。这是二叉搜索树中最复杂的操作。</strong></li>
<li>遍历。遍历树中的所有结点。常见的遍历方式有前序遍历、中序遍历、后序遍历以及层次遍历。其中，中序遍历二叉搜索树会得到一个有序的结点序列。</li>
</ol>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202401112321181.png" alt="二叉搜索树实现-概念模型" style="zoom: 50%;" />
</div>
<h3 id="代码实现-6">代码实现</h3>
<details>
<summary>
<font size="4" color="orange"> bst.h </font>
</summary>
<pre> <code class="language-c">#ifndef BST_H
#define BST_H
#include &lt; stdbool.h&gt;
#include &lt; stdlib.h&gt;
#include &lt; stdio.h&gt;
typedef int KeyType;
typedef struct node &#123;
    KeyType key;        // 结点 key 值, 具有唯一性
    struct node* left;  // 左子树
    struct node* right; // 右子树
&#125; TreeNode;
// 推荐定义一个二叉搜索树的结构体, 这样更便于扩展
typedef struct &#123;
    TreeNode* root; // 根结点指针
&#125;BST;
// 基础操作
// 创建一棵空的 BST
BST* bst_create();
// 销毁一棵 BST
void bst_destroy(BST* tree);
// 根据 key 插入一个新结点
bool bst_insert(BST* tree, KeyType key);
// 根据 key 搜索某个结点并返回
TreeNode * bst_search(BST* tree, KeyType key);
// 根据 key 删除一个结点
bool bst_delete(BST* tree, KeyType key);
// 深度优先-先序遍历
void bst_preorder(BST* tree);
// 深度优先-中序遍历
void bst_inorder(BST* tree);
// 深度优先-后序遍历
void bst_postorder(BST* tree);
// 广度优先-层次遍历
void bst_levelorder(BST* tree);
#endif // ! BST_H
</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> bst.c </font>
</summary>
<pre> <code class="language-c">#include "bst.h"
#include "list_queue.h"
BST* bst_create()
&#123;
    return  calloc(1, sizeof(BST));
&#125;
/*
* 向二叉搜索树中新增一个结点
* 1.若 key 已存在，则不新增，插入失败
* 2.若 key 不存在，则进行新增，插入成功
*/
bool bst_insert(BST* tree, KeyType key) &#123;
    // 1.遍历找到插入的位置
    // 初始化两个指针, 一个用于找到插入位置, 一个用于指向它的父结点
    TreeNode* parent = NULL;
    TreeNode* curr = tree-> root;
    int diff;   // while 循环一定执行, 不用担心 diff 未初始化
    while (curr != NULL) &#123;  // 此遍历就是为了查找 NULL, curr 最终等于 NULL 说明查找到了插入位置
        diff = key - curr-> key;
        if (diff > 0) &#123;
            // 待插入结点的 key 大于当前结点 key
            // 向右遍历查找
            parent = curr;
            curr = curr-> right;
        &#125;
        else if (diff < 0)
        &#123;
            // 待插入结点的 key 小于当前结点 key
            // 向左遍历查找
            parent = curr;
            curr = curr-> left;
        &#125;
        else
        &#123;
            // 待插入结点的 key 等于当前结点 key
            // key 重复, 插入失败
            return false;
        &#125;
    &#125;   // 循环结束, 说明 curr 是 NULL, 即 key 不重复, 找到了插入的位置, parent 指针指向待插入位置的父结点
    // 2.新建一个结点, 初始化结点
    // 重要建议: 在二叉搜索树中新建结点, 请一律使用 calloc, 安全第一!
    TreeNode* new_node = calloc(1, sizeof(TreeNode));
    if (new_node == NULL) &#123;
        printf("calloc failed in bst_insert.\n");
        exit(1);
    &#125;
    new_node-> key = key;
    // 3.将新结点链接到二叉树上(链表的尾插)
    if (parent == NULL) &#123;
        // 说明此时树是一个空树
        tree-> root = new_node;  // 新结点成为根结点
        return true;    // 插入成功
    &#125;
    // 插入的结点不是第一个结点
    if (diff < 0) &#123;
        // 插入左子树
        parent-> left = new_node;
    &#125;
    else &#123;
        // 插入右子树
        parent-> right = new_node;
    &#125;
    return true;
&#125;
TreeNode * bst_search(BST* tree, KeyType key)
&#123;
    TreeNode* curr = tree-> root;
    while (curr != NULL) &#123;
        if (curr-> key == key)
        &#123;
            return curr;
        &#125;
        else  if (curr-> key > key)
        &#123;
            curr = curr-> left;
        &#125;
        else
        &#123;
            curr = curr-> right;
        &#125;
    &#125;
    return NULL;
&#125;
// 根据 key 删除一个结点
bool bst_delete(BST* tree, KeyType key) &#123;
    // 1.利用 curr 和 parent 两个指针找到待删除结点以及它的父节点
    TreeNode* curr = tree-> root;
    TreeNode* parent = NULL;
    // 2.根据 key 值的大小关系, 来遍历这棵树的结点
    while (curr != NULL) &#123;  // 这一点模拟了单链表的遍历, 因为搜索路径就是一条单链表
        int diff = key - curr-> key;
        if (diff > 0) &#123;
            // 待删除 key 值比当前结点 key 值要大, 于是去右子树中遍历查找
            parent = curr;
            curr = curr-> right;
        &#125;
        else if (diff < 0) &#123;
            // 待删除 key 值比当前结点 key 值要小, 于是去左子树中遍历查找
            parent = curr;
            curr = curr-> left;
        &#125;
        else &#123;
            // 找到待删除结点, 下面就开始删除该结点的操作
            break;
        &#125;
    &#125;
    /*
        while 循环结束, 有两种可能性:
        1.找到了目标 key 结点, 依赖 break 结束循环
            此时 curr 指针指向待删除结点, parent 指向它的父结点
        2.没找到目标 key 结点, 依赖 curr 变成 NULL 结束循环
            此时 curr 指针是 NULL 相当于找到了这个不存在 key 结点的插入位置
            而 parent 就指向插入位置的父结点
        以上两种情况, 如果是第一种情况, 我们就继续删除
        但如果是第二种情况, 目标结点不存在, 删除就失败了
    */
    if (curr == NULL) &#123;
        return false;
    &#125;
    // 2.根据度不同来进行不同的处理, 使得待删除结点从树结构中断开
    // 2.1 判断结点的度是否为 2, 如果度为 2, 进行降级处理
    if (curr-> left != NULL && curr-> right != NULL) &#123;
        // 删除的结点是度为 2 的, 于是将它降低为删除度为 0 或 1
        TreeNode* min_node = curr-> right;   // 寻找待删除结点的右子树最小结点, 从 curr 的右子树结点开始
        TreeNode* min_parent = curr;    // 寻找待删除结点的右子树最小结点的父结点
        while (min_node-> left != NULL) &#123;
            min_parent = min_node;
            min_node = min_node-> left;
        &#125;   // while 循环结束时, min_node 指向右子树最小结点, min_parent 指向 min_node 结点的父结点
        // 将右子树最小结点的值替换给 curr 结点, 并且后续将删除右子树最小结点
        curr-> key = min_node-> key;
        // 后续的删除操作都是基于 curr 指针和 parent 指针的, 所以这里要进行一步赋值操作
        curr = min_node;
        parent = min_parent;
    &#125;
    // 接下来待删除的结点就是 curr 结点, 它的父结点就是 parent, 而且这个结点的度一定是 0 或 1
    // 2.2 统一处理度为 0 或 1 结点的删除操作
    // 核心操作: parent -> left/right = curr -> left/right
    // 先确定 parent 指向待删除结点的左子树还是右子树
    TreeNode* child = (curr-> left != NULL) ? curr-> left : curr-> right;
    /*
        考虑特殊情况:
        删除的结点是度为 0 或 1 的根结点
        此时需要更新根结点指针
    */
    if (parent == NULL) &#123;
        // 删除的结点是根结点, 此根结点度为 0 或 1
        tree-> root = child;
    &#125;
    else &#123;
        // 删除的结点不是根结点
        // 执行核心操作: parent -> left/right = child;
        if (parent-> left == curr) &#123;
            // 待删除结点是父结点的左子树, 那么就让父结点的左子树指向 child
            parent-> left = child;
        &#125;
        else &#123;
            // 待删除结点是父结点的右子树, 那么就让父结点的右子树指向 child
            parent-> right = child;
        &#125;
    &#125;
    // 3.free 这个结点
    free(curr); // 删除成功
    return true;
&#125;
/*
  利用递归实现 BST 的先序遍历
  root 参数表示此一轮递归调用中的根结点
  先序遍历是: DLR
  分解的思路是:
  对于任何一棵树 root 来说:
  1.总是先输出根结点的值
  2.然后递归遍历它的左子树
  3.最后递归遍历它的右子树
  preoder(root) = D + preorder(root-> left) + preorder(root-> right)
  这就是递归体
  这样的分解不会无休止进行, 如果分解成一棵空树, 也就是 root 是空指针时, 返回函数
  这就是递归的出口
*/
static void preorder(TreeNode* root) &#123;
    if (root == NULL)
    &#123;
        return;
    &#125;
    printf("%d ", root-> key);
    preorder(root-> left);
    preorder(root-> right);
&#125;
// 深度优先-先序遍历
void bst_preorder(BST* tree)
&#123;
    if (tree == NULL) &#123;
        // 树为空直接返回
        return;
    &#125;
    // 利用辅助函数递归实现 BST 的先序遍历
    preorder(tree-> root);
    printf("\n");
&#125;
/*
  利用递归实现 BST 的中序遍历
  root 参数表示此一轮递归调用中的根结点
  中序遍历是: LDR
  分解的思路是:
  对于任何一棵树 root 来说:
  1.总是先递归遍历它的左子树
  1.然后再输出根结点的值
  3.最后递归遍历它的右子树
  inorder(root) = inorder(root-> left) + D + inorder(root-> right)
  这就是递归体
  这样的分解不会无休止进行, 如果分解成一棵空树, 也就是 root 是空指针时, 返回函数
  这就是递归的出口
*/
static void inorder(TreeNode* root) &#123;
    if (root == NULL)
    &#123;
        return;
    &#125;
    inorder(root-> left);
    printf("%d ", root-> key);
    inorder(root-> right);
&#125;
// 深度优先-中序遍历
void bst_inorder(BST* tree)
&#123;
    if (tree == NULL) &#123;
        // 树为空直接返回
        return;
    &#125;
    // 利用辅助函数递归实现 BST 的中序遍历
    inorder(tree-> root);
    printf("\n");
&#125;
/*
  利用递归实现 BST 的后序遍历
  root 参数表示此一轮递归调用中的根结点
  中序遍历是: LRD
  分解的思路是:
  对于任何一棵树 root 来说:
  1.总是先递归遍历它的左子树
  3.然后递归遍历它的右子树
  3.最后再输出根结点的值
  postorder(root) = postorder(root-> left) + postorder(root-> right) + D
  这就是递归体
  这样的分解不会无休止进行, 如果分解成一棵空树, 也就是 root 是空指针时, 返回函数
  这就是递归的出口
*/
static void postorder(TreeNode* root) &#123;
    // 1.递归的出口
    if (root == NULL) &#123;
        return;
    &#125;
    // 2.递归体
    postorder(root-> left);
    postorder(root-> right);
    printf("%d ", root-> key);
&#125;
void bst_postorder(BST* tree) &#123;
    if (tree == NULL) &#123;
        // 树为空直接返回
        return;
    &#125;
    // 利用辅助函数递归实现 BST 的后序遍历
    postorder(tree-> root);
    printf("\n");
&#125;
static void destroy(TreeNode* root) &#123;
    // 1.递归的出口
    if (root == NULL) &#123;
        return;
    &#125;
    // 2.递归体
    destroy(root-> left);
    destroy(root-> right);
    free(root);
&#125;
void bst_destroy(BST* tree)
&#123;
    if (tree == NULL) &#123;
        // 树为空直接返回
        return;
    &#125;
    // 利用辅助函数递归实现 BST 的销毁
    destroy(tree-> root);
    free(tree);
&#125;
void bst_levelorder(BST* tree) &#123;
    LinkedListQueue* q = create_queue();
    enqueue(q, tree-> root);
    while (! is_empty(q)) &#123;
        int level_size = q-> size;
        for (int i = 0; i < level_size; i++)
        &#123;
            TreeNode* node = dequeue(q);
            printf("%d ", node-> key);
            if (node-> left != NULL)
            &#123;
                enqueue(q, node-> left);
            &#125;
            if (node-> right != NULL)
            &#123;
                enqueue(q, node-> right);
            &#125;
        &#125;
        printf("\n");
    &#125;
    destroy_queue(q); // 完成遍历后，销毁队列释放资源
    printf("\n");
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> list_queue.h </font>
</summary>
<pre> <code class="language-c">#ifndef LIST_QUEUE_H
#define LIST_QUEUE_H
#include &lt; stdbool.h&gt;
#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;
#include "bst.h"
// 定义队列中的元素类型
typedef TreeNode* ElementType;
// 队列节点的结构
typedef struct node_s &#123;
    ElementType data;
    struct node_s* next;
&#125; QueueNode;
// 队列的结构
typedef struct &#123;
    QueueNode* front;  // 队头结点指针
    QueueNode* rear;   // 队尾结点指针
    int size;   // 队列中元素的个数
&#125; LinkedListQueue;
// 函数声明
// 创建链式队列
LinkedListQueue* create_queue();
// 销毁链式队列
void destroy_queue(LinkedListQueue* q);
// 入队列
bool enqueue(LinkedListQueue* q, ElementType element);
// 出队列并返回队头元素
ElementType dequeue(LinkedListQueue* q);
// 访问队头元素
ElementType peek_queue(LinkedListQueue* q);
// 判空
bool is_empty(LinkedListQueue* q);
#endif // ! LIST_QUEUE_H </code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> list_queue.c </font>
</summary>
<pre> <code class="language-c">#include "list_queue.h"
// 函数声明
LinkedListQueue* create_queue() &#123;
    return calloc(1, sizeof(LinkedListQueue));
&#125;
void destroy_queue(LinkedListQueue* q) &#123;
    // 从队头开始遍历链表，销毁每一个结点
    QueueNode* current = q-> front;
    while (current != NULL) &#123;
        QueueNode* temp = current-> next;
        free(current);
        current = temp;
    &#125;
    // 销毁队列结构体
    free(q);
&#125;
bool is_empty(LinkedListQueue* q) &#123;
    // 队头指针是空指针，即表示空队列
    return q-> front == NULL;
&#125;
// 入队操作: 只能在队尾插入一个结点
// 由于已存在尾指针，所以这里的操作就是链表尾插
bool enqueue(LinkedListQueue* q, ElementType element) &#123;
    QueueNode* new_node = malloc(sizeof(QueueNode));
    if (new_node == NULL) &#123;
        printf("Error: malloc failed in enqueue.\n");
        return false;
    &#125;
    // 初始化新结点
    new_node-> data = element;
    new_node-> next = NULL;
    // 开始进行尾插法插入一个结点
    // 分两种情况：如果尾插插入的是第一个结点需要同步更新头指针，否则仅需要更新尾指针
    if (q-> front == NULL) &#123;
        // 插入的是第一个结点
        q-> front = new_node;
        q-> rear = new_node;
    &#125;
    else &#123;
        // 插入的不是第一个结点
        q-> rear-> next = new_node;
        q-> rear = new_node;
    &#125;
    q-> size++;
    return true;
&#125;
// 出队，在队头删除一个结点。也就是在删除链表的第一个结点
ElementType dequeue(LinkedListQueue* q) &#123;
    if (is_empty(q)) &#123;
        printf("Error: queue is empty.\n");
        exit(1);
    &#125;
    QueueNode* tmp = q-> front;
    // 将出队的结点数据保存
    ElementType remove_data = tmp-> data;
    // 更新队头指针
    q-> front = tmp-> next;
    if (q-> front == NULL) &#123;
        // 如果队头更新后, 队列为空, 说明出队的就是最后一个元素
        // 于是同步更新队尾指针
        q-> rear = NULL;
    &#125;
    free(tmp);
    q-> size--;
    return remove_data;
&#125;
// 访问队头元素但不出队
ElementType peek_queue(LinkedListQueue* q) &#123;
    if (is_empty(q)) &#123;
        printf("Error: queue is empty.\n");
        exit(1);
    &#125;
    return q-> front-> data;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange"> test.c </font>
</summary>
<pre> <code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt; stdio.h&gt;
#include "bst.h"
int main(void) &#123;
    // 创建二叉搜索树
    BST* tree = bst_create();
    if (! tree) &#123;
        printf("二叉搜索树创建失败。\n");
        return 1;
    &#125;
    // 插入元素
    int elements [] = &#123; 50, 30, 70, 20, 40, 60, 80, 30 &#125;; // 包含重复元素 30
    printf("正在插入元素: ");
    int arr_len = sizeof(elements) / sizeof(elements [0]);
    for (int i = 0; i < arr_len; i++) &#123;
        if (bst_insert(tree, elements [i])) &#123;
            printf("%d ", elements [i]); // 打印成功插入的元素
        &#125;
        else &#123;
            printf("(重复 %d) ", elements [i]); // 打印重复元素的信息
        &#125;
    &#125;
    printf("\n");
    // 预期结果：重复的元素不应该被插入到树中。
    // 中序遍历，应该输出有序序列
    printf("中序遍历输出(预期有序): ");
    bst_inorder(tree);
    printf("\n");
    // 预期结果：20, 30, 40, 50, 60, 70, 80
    // 先序遍历输出 预期结果：50 30 20 40 70 60 80
    printf("先序遍历输出: ");
    bst_preorder(tree);
    printf("\n");
    // 后序遍历输出 预期结果：20 40 30 60 80 70 50
    printf("后序遍历输出: ");
    bst_postorder(tree);
    printf("\n");
    // 层次遍历输出 预期结果：50 30 70 20 40 60 80
    printf("层次遍历输出: ");
    bst_levelorder(tree);
    printf("\n");
    // 测试搜索存在和不存在的情况 预期结果：找到了
    int searchKey = 40;
    printf("搜索键 %d 的结果: %s\n", searchKey, bst_search(tree, searchKey) ? "找到了" : "未找到");
    // 预期结果：未找到
    searchKey = 100;
    printf("搜索键 %d 的结果: %s\n", searchKey, bst_search(tree, searchKey) ? "找到了" : "未找到");
    // 测试删除操作
    printf("删除元素 70 和 20\n");
    bst_delete(tree, 70);
    bst_delete(tree, 20);
    // 再次进行中序遍历验证删除操作 // 预期结果：30, 40, 50, 60, 80
    printf("删除元素后中序遍历输出: ");
    bst_inorder(tree);
    printf("\n");
    // 销毁二叉搜索树
    bst_destroy(tree);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<hr />
<h2 id="总结">总结</h2>
<p>以下是关于动态数组、链表、栈、队列、哈希表和二叉搜索树的特点和使用场景的总结：</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 22%" />
<col style="width: 25%" />
<col style="width: 16%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>数据结构</th>
<th>特点</th>
<th>时间复杂度（平均情况）</th>
<th>时间复杂度（最坏情况）</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>动态数组</td>
<td>连续内存、支持随机访问、可扩容</td>
<td>访问：O(1)，插入末尾：O(1)<em>，删除末尾：O(1)</em></td>
<td>插入：O(n)，删除：O(n)</td>
<td>适用于元素个数动态变化、频繁随机访问的场景（如
ArrayList、Vector）</td>
</tr>
<tr>
<td>链表（单/双）</td>
<td>非连续内存、插入删除快、访问慢（需遍历）</td>
<td>插入：O(1)，删除：O(1)，访问：O(n)</td>
<td>插入/删除：O(n)（需查找位置）</td>
<td>多用于频繁插入/删除的场景，如实现栈、队列、LRU 缓存</td>
</tr>
<tr>
<td>栈</td>
<td>后进先出（LIFO），一般基于数组或链表实现</td>
<td>插入（push）：O(1)，删除（pop）：O(1)，访问栈顶：O(1)</td>
<td>O(1)</td>
<td>用于函数调用、表达式求值、括号匹配、撤销操作等场景</td>
</tr>
<tr>
<td>队列</td>
<td>先进先出（FIFO），一般基于数组或链表实现</td>
<td>入队：O(1)，出队：O(1)，访问队首/尾：O(1)</td>
<td>O(1)</td>
<td>用于任务调度、异步数据处理、消息队列等场景</td>
</tr>
<tr>
<td>哈希表</td>
<td>快速查找和插入，基于哈希函数实现，可能有哈希冲突</td>
<td>查找/插入/删除：O(1)</td>
<td>查找/插入/删除：O(n)（大量冲突时）</td>
<td>用于快速查找，如字典、缓存、数据去重等</td>
</tr>
<tr>
<td>二叉搜索树（BST）</td>
<td>左小右大，有序结构，支持范围查找</td>
<td>查找/插入/删除：O(log n)（平衡时）</td>
<td>查找/插入/删除：O(n)（退化为链表）</td>
<td>适用于需要有序数据结构，支持范围查询、排序等（如
TreeMap、TreeSet）</td>
</tr>
</tbody>
</table>
<p>*说明：动态数组在扩容时，插入末尾的操作可能引起整体复制，因此最坏情况为
O(n)，但摊还复杂度为 O(1)。</p>
]]></content>
      <categories>
        <category>C语言</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之数学公式（四）</title>
    <url>/lang-latex/notes-lshort/04-math-equation/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>本章将见识到 <span class="math inline">\(\LaTeX{}\)</span>
闻名的强项——排版数学公式。</p>
<span id="more"></span>
<hr />
<h2 id="textrmams-宏集"><span
class="math inline">\(\textrm{AMS}\)</span> 宏集</h2>
<p>在介绍数学公式排版之前，简单介绍一下 <span
class="math inline">\(\textrm{AMS}\)</span> 宏集。<span
class="math inline">\(\textrm{AMS}\)</span>
宏集合是美国数学学会(American Mathematical Society)提供的对<span
class="math inline">\(\LaTeX{}\)</span>
原生的数学公式排版的扩展，其核心是 <code>amsmath</code>
宏包，对多行公式的排版提供了有力的支持。此外，<code>amsfonts</code>
宏包以及基于它的 <code>amssymb</code>
宏包提供了丰富的数学符号；<code>amsthm</code> 宏包扩展了 <span
class="math inline">\(\LaTeX{}\)</span> 定理证明格式。</p>
<p>以下示例都假定了导言区中写有 <code>\usepackage&#123;amsmath&#125;</code> 。</p>
<hr />
<h2 id="公式排版基础">公式排版基础</h2>
<h3 id="行内和行间公式">行内和行间公式</h3>
<p>数学公式有两种排版方式：其一是与文字混排，称为<strong>行内公式</strong>；其二是单独列为一行排版，称为<strong>行间公式</strong>。</p>
<p>行内公式由一对 <span class="math inline">\(\texttt\$\)</span>
符号包裹：The Pythagorean theorem is <span class="math inline">\(a^2 +
b^2 = c^2\)</span> (<code>$a^2 + b^2 = c^2$</code>)。</p>
<p>单独成行的<strong>行间公式</strong>由 <span
class="math inline">\(\texttt{equation}\)</span> 环境包裹。 <span
class="math inline">\(\texttt{equation}\)</span>
环境为公式自动生成一个编号，这个编号可以用<code>\label</code> 和
<code>\ref</code> 生成交叉引用，<code>amsmath</code> 的
<code>\eqref</code>
命令甚至为引用<strong>自动加上圆括号</strong>；还可以用<code>\tag</code>
命令手动修改公式的编号，或者用<code>\notag</code>
命令取消为公式编号（与之基本等效的命令是 <code>\nonumber</code>）。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250116220746833.png" alt="image-20250116220746833" style="zoom:67%;" /></p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250116220821758.png" alt="image-20250116220821758" style="zoom:67%;" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">1 + 1 = 3 <span class="keyword">\tag</span>&#123;dumb&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">1 + 1 = 4 <span class="keyword">\notag</span></span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{equation}
1 + 1 = 3 \tag{dumb}
\end{equation}
\]</span></p>
<p><span class="math display">\[
\begin{equation}
1 + 1 = 4 \notag
\end{equation}
\]</span></p>
<p>如果需要直接使用不带编号的行间公式，则将公式用命令 <code>\[</code> 和
<code>\]</code> 包裹，与之等效的是 <span
class="math inline">\(\texttt{displaymath}\)</span> 环境。有的人更喜欢
<span class="math inline">\(\texttt{equation*}\)</span>
环境，体现了带星号和不带星号的环境之间的区别。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250116221231100.png" alt="image-20250116221231100" style="zoom:67%;" /></p>
<p>通过一个例子展示行内公式和行间公式的对比。为了与文字相适应，行内公式在排版大的公式元素（分式、巨算符等）时显得很“局促”：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250116221343609.png" alt="image-20250116221343609" style="zoom:67%;" /></p>
<p>行间公式的对齐、编号位置等性质由文档类选项控制，文档类的 <span
class="math inline">\(\texttt{fleqn}\)</span>
选项令行间公式左对齐；<span
class="math inline">\(\texttt{leqno}\)</span>
选项令编号放在公式左边。</p>
<h3 id="数学模式">数学模式</h3>
<p>当用户使用 <span class="math inline">\(\texttt\$\)</span>
开启行内公式输入，或是使用 <code>\[</code> 命令、<span
class="math inline">\(\texttt{equation}\)</span> 环境时，<span
class="math inline">\(\LaTeX{}\)</span>
就进入了<strong>数学模式</strong>。</p>
<p>数学模式相比于文本模式有以下特点：</p>
<blockquote>
<ol type="1">
<li>数学模式中输入的空格被忽略。数学符号的间距默认由符号的性质（关系符号、运算符等）决定。需要人为引入间距时，<code>\quad</code>
和 <code>\qquad</code> 等命令。</li>
<li><strong>不允许有空行（分段）</strong>。行间公式中也无法用
<code>\\</code>命令手动换行。</li>
<li>所有的字母被当作数学公式中的变量处理，字母间距与文本模式不一致，也无法生成单词之间的空格。如果想在数学公式中<strong>输入正体</strong>的文本，简单情况下可用
<code>\mathrm</code> 命令。或者用 <code>\amsmath</code> 提供的
<code>\text</code> 命令。</li>
</ol>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>x<span class="built_in">^</span>&#123;2&#125;  <span class="keyword">\geq</span> 0 <span class="keyword">\qquad</span></span><br><span class="line"><span class="keyword">\text</span>&#123;for <span class="keyword">\textbf</span>&#123;all&#125; &#125;</span><br><span class="line">x<span class="keyword">\in</span> <span class="keyword">\mathbb</span>&#123;R&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
x^{2}  \geq 0 \qquad
\text{for \textbf{all} }
x\in \mathbb{R}
\end{gather*}
\]</span></p>
<hr />
<h2 id="数学符号">数学符号</h2>
<p><span class="math inline">\(\LaTeX{}\)</span>​
默认提供了常用的数学符号，<code>amssymb</code>
宏包提供了一些次常用的符号。大多数常用的数学符号都能在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vSW52aW5jLVovcC8xODY4MjUyMA==">这里<i class="fa fa-external-link-alt"></i></span>
查到。更多符号可在命令行输入<code>texdoc symbols-a4</code> <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL0NUQU4vaW5mby9zeW1ib2xzL2NvbXByZWhlbnNpdmUvc3ltYm9scy1hNC5wZGY=">查阅<i class="fa fa-external-link-alt"></i></span>
。</p>
<h3 id="一般符号">一般符号</h3>
<p>希腊字母符号的名称就是其英文名称，如 <span
class="math inline">\(\alpha\)</span> (<code>\alpha</code>)、<span
class="math inline">\(\beta\)</span>
(<code>\beta</code>)等等。大写的希腊字母为首字母大写的命令 <span
class="math inline">\(\Gamma\)</span> (<code>\Gamma</code>) <span
class="math inline">\(\Delta\)</span>
(<code>\Delta</code>)。无穷大符号为 <span
class="math inline">\(\infty\)</span> (<code>\infty</code>)。</p>
<p>省略号有 <span class="math inline">\(\dots\)</span>
(<code>\dots</code>) 和 <span class="math inline">\(\cdots\)</span>
(<code>\cdots</code>) 两种形式。它们有各自合适的用途：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>a<span class="built_in">_</span>1, a<span class="built_in">_</span>2, <span class="keyword">\dots</span>, a<span class="built_in">_</span>n<span class="built_in">$</span> <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">$</span>a<span class="built_in">_</span>1 + a<span class="built_in">_</span>2 + <span class="keyword">\cdots</span> + a<span class="built_in">_</span>n<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
a_1, a_2, \dots, a_n \\
a_1 + a_2 + \cdots + a_n
\end{gather*}
\]</span></p>
<p><code>\ldots</code> 和 <code>\dots</code>
是完全等效的，它们既能用在公式中，也用来在文本里作为省略号。
除此之外，在矩阵中可能会用到竖排的 <span
class="math inline">\(\vdots\)</span> (<code>\votes</code>)和斜排的
<span class="math inline">\(\ddots\)</span> (<code>\ddots</code>)。</p>
<h3 id="指数上下标和导数">指数、上下标和导数</h3>
<p>用<code>^</code> 和
<code>_</code>标明上下标。注意上下标的内容（子公式）一般需要<strong>用花括号包裹</strong>，否则上下标只对后面的一个符号起作用。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>p<span class="built_in">^</span>3<span class="built_in">_</span>&#123;ij&#125; <span class="keyword">\qquad</span></span><br><span class="line">m<span class="built_in">_</span><span class="keyword">\mathrm</span>&#123;Knuth&#125;<span class="keyword">\qquad</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;k=1&#125;<span class="built_in">^</span>3 k <span class="built_in">$</span><span class="keyword">\\</span>[5pt]</span><br><span class="line"><span class="built_in">$</span>a<span class="built_in">^</span>x+y <span class="keyword">\neq</span> a<span class="built_in">^</span>&#123;x+y&#125;<span class="keyword">\qquad</span></span><br><span class="line">e<span class="built_in">^</span>&#123;x<span class="built_in">^</span>2&#125; <span class="keyword">\neq</span> &#123;e<span class="built_in">^</span>x&#125;<span class="built_in">^</span>2<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
p^3_{ij} \qquad
m_\mathrm{Knuth}\qquad
\sum_{k=1}^3 k \\[5pt]
a^x+y \neq a^{x+y}\qquad
e^{x^2} \neq {e^x}^2
\end{gather*}
\]</span></p>
<p>导数符号<code>'</code>(<span
class="math inline">\({}&#39;\)</span>)是一类特殊的上标，可连续使用，但只能在<strong>其后</strong>添加其他上标：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>f(x) = x<span class="built_in">^</span>2 <span class="keyword">\quad</span> f&#x27;(x) = 2x <span class="keyword">\quad</span> f&#x27;&#x27;<span class="built_in">^</span>&#123;2&#125;(x) = 4<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
f(x) = x^2 \quad f&#39;(x) = 2x \quad f&#39;&#39;^{2}(x) = 4
\]</span></p>
<h3 id="分式和根式">分式和根式</h3>
<p>分式使用 <code>\frac&#123;分子&#125;&#123;分母&#125;</code>
来书写。分式的大小在行间公式中是正常大小，而在行内被极度压缩。
<code>amsmath</code> 提供了方便的命令 <code>\dfrac</code> 和
<code>\tfrac</code>，令用户能够在行内使用正常大小的分式，或是反过来。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">In display style:</span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line">3/8 <span class="keyword">\qquad</span> <span class="keyword">\frac</span>&#123;3&#125;&#123;8&#125;</span><br><span class="line"><span class="keyword">\qquad</span> <span class="keyword">\tfrac</span>&#123;3&#125;&#123;8&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line">In text style:</span><br><span class="line"><span class="built_in">$</span>1<span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="built_in">$</span>~hours <span class="keyword">\qquad</span></span><br><span class="line"><span class="built_in">$</span>1<span class="keyword">\dfrac</span>&#123;1&#125;&#123;2&#125;<span class="built_in">$</span>~hours</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250118195233817.png" alt="image-20250118195233817" style="zoom:67%;" /></p>
<p>一般的根式使用 <code>\sqrt&#123;...&#125;</code>；表示 <span
class="math inline">\(n\)</span> 次方根时写成
<code>\sqrt[n]&#123;...&#125;</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;x&#125; <span class="keyword">\Leftrightarrow</span> x<span class="built_in">^</span>&#123;1/2&#125;</span><br><span class="line"><span class="keyword">\quad</span> <span class="keyword">\sqrt</span>[3]&#123;2&#125;</span><br><span class="line"><span class="keyword">\quad</span> <span class="keyword">\sqrt</span>&#123;x<span class="built_in">^</span>&#123;2&#125; + <span class="keyword">\sqrt</span>&#123;y&#125;&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sqrt{x} \Leftrightarrow x^{1/2}
\quad \sqrt[3]{2}
\quad \sqrt{x^{2} + \sqrt{y}}
\]</span></p>
<p>特殊的分式形式，如二项式结构，由 <code>amsmath</code> 宏包的
<code>\binom</code> 命令生成：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span></span><br><span class="line"><span class="keyword">\binom</span>&#123;n&#125;&#123;k&#125; =<span class="keyword">\binom</span>&#123;n-1&#125;&#123;k&#125;</span><br><span class="line">+ <span class="keyword">\binom</span>&#123;n-1&#125;&#123;k-1&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\binom{n}{k} =\binom{n-1}{k} + \binom{n-1}{k-1}
\]</span></p>
<h3 id="关系符">关系符</h3>
<p>常见的关系符号除了可以直接输入的 <span
class="math inline">\(=\)</span>，<span
class="math inline">\(&gt;\)</span>，<span
class="math inline">\(&lt;\)</span>，其它符号用命令输入，常用的有 <span
class="math inline">\(\ne\)</span> (<code>\ne</code>)、<span
class="math inline">\(\ge\)</span> (<code>\ge</code>)、<span
class="math inline">\(\le\)</span> (<code>\le</code>)、<span
class="math inline">\(\approx\)</span> （<code>\approx</code>）、 等价
<span class="math inline">\(\equiv\)</span> (<code>\equiv</code>)、正比
<span class="math inline">\(\propto\)</span>
(<code>\propto</code>)、相似 <span
class="math inline">\(\sim\)</span><code>\sim</code> 等等。</p>
<p><span class="math inline">\(\LaTeX{}\)</span>
还提供了自定义二元关系符的命令
<code>\stackrel</code>，用于将一个符号叠加在原有的二元关系符之上：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>f<span class="built_in">_</span>n(x) <span class="keyword">\stackrel</span>&#123;*&#125;&#123;<span class="keyword">\approx</span>&#125; 1<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
f_n(x) \stackrel{*}{\approx} 1
\]</span></p>
<h3 id="运算符">运算符</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
中的算符大多数是二元算符，除了直接用键盘可以输入的 <span
class="math inline">\(+\)</span>、<span
class="math inline">\(-\)</span>、<span
class="math inline">\(*\)</span>、<span
class="math inline">\(/\)</span>，其它符号用命令输入，常用的有乘号 <span
class="math inline">\(\times\)</span> (<code>\times</code>)、 除号 <span
class="math inline">\(÷\)</span>（<code>\div</code>）、点乘 <span
class="math inline">\(\cdot\)</span> (<code>\cdot</code>)、加减号<span
class="math inline">\(\pm\)</span> (<code>\pm</code>) / <span
class="math inline">\(\mp\)</span> (<code>\mp</code>)等等。</p>
<p><span class="math inline">\(\nabla\)</span> (<code>\nabla</code>) 和
<span class="math inline">\(\partial\)</span> (<code>\partial</code>)
也是常用的算符，虽然它们不属于二元算符。</p>
<p><span class="math inline">\(\LaTeX{}\)</span>
将数学函数的名称作为一个算符排版，字体为直立字体。其中有一部分符号在上下位置可以书写一些内容作为条件，
类似于后文所叙述的巨算符。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250118202405498.png" alt="image-20250118202405498" style="zoom:67%;" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\rightarrow</span> 0&#125; <span class="keyword">\frac</span>&#123;<span class="keyword">\sin</span> x&#125;&#123;x&#125; = 1<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\lim_{x \rightarrow 0} \frac{\sin x}{x} = 1
\]</span></p>
<p>对于求模表达式，<span class="math inline">\(\LaTeX{}\)</span> 提供了
<code>\bmod</code>和 <code>\pmod</code>
命令，前者相当于一个二元运算符，后者作为同余表达式的后缀：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>a<span class="keyword">\bmod</span> b <span class="keyword">\\</span></span><br><span class="line"> x<span class="keyword">\equiv</span> a <span class="keyword">\pmod</span>&#123;b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
a\bmod b \\
x\equiv a \pmod{b}
\end{gather*}
\]</span></p>
<p>如果上表中的算符不够用的话，<code>amsmath</code> 允许用户在导言区用
<code>\DeclareMathOperator</code>定义自己的算符，其中带星号的命令定义带上下限的算符：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\DeclareMathOperator</span>&#123;<span class="keyword">\argh</span>&#125;&#123;argh&#125;</span><br><span class="line"><span class="keyword">\DeclareMathOperator</span>*&#123;<span class="keyword">\nut</span>&#125;&#123;Nut&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\argh</span> 3 = <span class="keyword">\nut</span><span class="built_in">_</span>&#123;x=1&#125; 4x<span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\DeclareMathOperator{\argh}{argh}
\DeclareMathOperator*{\nut}{Nut}
\argh 3 = \nut_{x=1} 4x
\]</span></p>
<h3 id="巨算符">巨算符</h3>
<p>积分号 <span class="math inline">\(\int\)</span>
(<code>\int</code>)、求和号 <span class="math inline">\(\sum\)</span>
(<code>\sum</code>)
等符号称为<strong>巨算符</strong>。巨算符在行内公式和行间公式的大小和形状有区别。行内:<span
class="math inline">\(\sum_{i=1}^n \quad
\int_0^{\frac{\pi}{2}} \quad
\oint_0^{\frac{\pi}{2}} \quad
\prod_\epsilon\)</span> ，行间：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n <span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>0<span class="built_in">^</span>&#123;<span class="keyword">\frac</span>&#123;<span class="keyword">\pi</span>&#125;&#123;2&#125;&#125; <span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\oint</span><span class="built_in">_</span>0<span class="built_in">^</span>&#123;<span class="keyword">\frac</span>&#123;<span class="keyword">\pi</span>&#125;&#123;2&#125;&#125; <span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\prod</span><span class="built_in">_</span><span class="keyword">\epsilon</span> <span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sum_{i=1}^n \quad
\int_0^{\frac{\pi}{2}} \quad
\oint_0^{\frac{\pi}{2}} \quad
\prod_\epsilon
\]</span></p>
<p>巨算符的上下标位置可由 <code>\limits</code> 和
<code>\nolimits</code>调整，前者令巨算符类似 <span
class="math inline">\(\lim\)</span> 或求和算符 <span
class="math inline">\(\sum\)</span>，上下标位于上下方；后者令巨算符类似积分号，上下标位于右上方和右下方。行内:<span
class="math inline">\(\sum\limits_{i=1}^n \quad
\int\limits_0^{\frac{\pi}{2}} \quad
\prod\limits_\epsilon\)</span> ; 行间:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span><span class="keyword">\sum</span><span class="keyword">\nolimits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n <span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\int</span><span class="keyword">\limits</span><span class="built_in">_</span>0<span class="built_in">^</span>&#123;<span class="keyword">\frac</span>&#123;<span class="keyword">\pi</span>&#125;&#123;2&#125;&#125; <span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\prod</span><span class="keyword">\nolimits</span><span class="built_in">_</span><span class="keyword">\epsilon</span> <span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sum\nolimits_{i=1}^n \quad
\int\limits_0^{\frac{\pi}{2}} \quad
\prod\nolimits_\epsilon
\]</span></p>
<p><code>amsmath</code> 宏包还提供了
<code>\substack</code>，能够在下限位置书写多行表达式；<span
class="math inline">\(\texttt{subarray}\)</span>
环境更进一步，令多行表达式可选择居中 (c) 或左对齐 (l)：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;amssymb&#125;</span></span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;<span class="keyword">\substack</span>&#123;0<span class="keyword">\le</span> i<span class="keyword">\le</span> n <span class="keyword">\\</span></span><br><span class="line">  j<span class="keyword">\in</span> <span class="keyword">\mathbb</span>&#123;R&#125;&#125;&#125;</span><br><span class="line">P(i,j) = Q(n)</span><br><span class="line"> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;<span class="keyword">\begin</span>&#123;subarray&#125;&#123;l&#125;</span><br><span class="line">  0<span class="keyword">\le</span> i<span class="keyword">\le</span> n <span class="keyword">\\</span></span><br><span class="line">  j<span class="keyword">\in</span> <span class="keyword">\mathbb</span>&#123;R&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;subarray&#125;&#125;</span><br><span class="line">P(i,j) = Q(n)</span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
\sum_{\substack{0\le i\le n \\
  j\in \mathbb{R}}}
P(i,j) = Q(n)
\\
\sum_{\begin{subarray}{l}
  0\le i\le n \\
  j\in \mathbb{R}
\end{subarray}}
P(i,j) = Q(n)
\end{gather*}
\]</span></p>
<h3 id="数学重音和上下括号">数学重音和上下括号</h3>
<p>数学符号可以像文字一样加重音，比如求导符号 <span
class="math inline">\(\dot{r}\)</span> （<code>\dot&#123;r&#125;</code>）、 <span
class="math inline">\(\ddot{r}\)</span>
(<code>\ddot&#123;r&#125;</code>)、表示向量的箭头 <span
class="math inline">\(\vec{r}\)</span> (<code>\vec&#123;r&#125;</code>)
、表示单位向量的符号 <span
class="math inline">\(\hat{\mathbf{e}}\)</span>
(<code>\hat&#123;mathbf&#123;e&#125;&#125;</code>)等。使用时要注意重音符号的作用区域，一般应当对<strong>某个符号</strong>而不是“符号加下标”使用重音：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bar</span>&#123;x<span class="built_in">_</span>0&#125; <span class="keyword">\quad</span> <span class="keyword">\bar</span>&#123;x&#125;<span class="built_in">_</span>0<span class="built_in">$</span><span class="keyword">\\</span>[5pt]</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\vec</span>&#123;x<span class="built_in">_</span>0&#125; <span class="keyword">\quad</span> <span class="keyword">\vec</span>&#123;x&#125;<span class="built_in">_</span>0<span class="built_in">$</span><span class="keyword">\\</span>[5pt]</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\hat</span>&#123;<span class="keyword">\mathbf</span>&#123;e&#125;<span class="built_in">_</span>x&#125; <span class="keyword">\quad</span></span><br><span class="line"> <span class="keyword">\hat</span>&#123;<span class="keyword">\mathbf</span>&#123;e&#125;&#125;<span class="built_in">_</span>x<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
\bar{x_0} \quad \bar{x}_0\\[5pt]
\vec{x_0} \quad \vec{x}_0\\[5pt]
\hat{\mathbf{e}_x} \quad
\hat{\mathbf{e}}_x
\end{gather*}
\]</span></p>
<p>也能为多个字符加重音，包括直接画线的 <code>\overline</code> 和
<code>\underline</code> 命令（可叠加使用）、宽重音符号
<code>\widehat</code>、表示向量的箭头 <code>\overrightarrow</code>
等。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>0.<span class="keyword">\overline</span>&#123;3&#125; = <span class="keyword">\underline</span>&#123;<span class="keyword">\underline</span>&#123;1/3&#125;&#125;<span class="built_in">$</span> <span class="keyword">\\</span>[5pt]</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\hat</span>&#123;XY&#125; <span class="keyword">\qquad</span> <span class="keyword">\widehat</span>&#123;XY&#125;<span class="built_in">$</span><span class="keyword">\\</span>[5pt]</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\vec</span>&#123;AB&#125; <span class="keyword">\qquad</span> <span class="keyword">\overrightarrow</span>&#123;AB&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
0.\overline{3} = \underline{\underline{1/3}} \\[5pt]
\hat{XY} \qquad \widehat{XY}\\[5pt]
\vec{AB} \qquad \overrightarrow{AB}
\end{gather*}
\]</span></p>
<p><code>\overbrace</code> 和 <code>\underbrace</code>
命令用来生成上/下括号，各自可带一个上/下标公式。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underbrace</span>&#123;<span class="keyword">\overbrace</span>&#123;(a+b+c)&#125;<span class="built_in">^</span>6</span><br><span class="line"><span class="keyword">\cdot</span> <span class="keyword">\overbrace</span>&#123;(d+e+f)&#125;<span class="built_in">^</span>7&#125;</span><br><span class="line"><span class="built_in">_</span><span class="keyword">\text</span>&#123;meaning of life&#125; = 42<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\underbrace{\overbrace{(a+b+c)}^6
\cdot \overbrace{(d+e+f)}^7}
_\text{meaning of life} = 42
\]</span></p>
<h3 id="箭头">箭头</h3>
<p>常用的箭头包括 <code>\rightarrow</code>(<span
class="math inline">\(\rightarrow\)</span>，或
<code>\to</code>)、<code>\leftarrow</code>（<span
class="math inline">\(\leftarrow\)</span>，或<code>\gets</code>）等。</p>
<p><code>amsmath</code> 的 <code>xleftarrow</code> 和
<code>xrightarrow</code>
命令提供了长度可以伸展的箭头，并且可以为箭头增加上下标：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span> a<span class="keyword">\xleftarrow</span>&#123;x+y+z&#125; b <span class="keyword">\]</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\[</span> c<span class="keyword">\xrightarrow</span>[x&lt;y]&#123;a*b*c&#125;d <span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
a\xleftarrow{x+y+z} b \\
c\xrightarrow[x&lt;y]{a*b*c}d
\end{gather*}
\]</span></p>
<h3 id="括号和定界符">括号和定界符</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
提供了多种括号和定界符表示公式块的边界，如小括号 <span
class="math inline">\(()\)</span>、中括号 <span
class="math inline">\([]\)</span>、大括号 <span
class="math inline">\(\{\}\)</span> (<code>\&#123; \&#125;</code>)、尖括号 <span
class="math inline">\(\langle \rangle\)</span>（<code>\langle</code>
<code>\rangle</code>）等。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>&#123;a,b,c&#125; <span class="keyword">\neq</span> <span class="keyword">\&#123;</span>a,b,c<span class="keyword">\&#125;</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
{a,b,c} \neq \{a,b,c\}
\]</span></p>
<p>使用 <code>\left</code> 和 <code>\right</code>
命令可令括号（定界符）的大小可变，在行间公式中常用。会自动根据括号内的公式大小决定定界符大小。
<code>\left</code> 和 <code>\right</code>
必须成对使用。需要使用单个定界符时，另一个定界符写成 <code>\left.</code>
或<code>\right.</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span>1 + <span class="keyword">\left</span>(<span class="keyword">\frac</span>&#123;1&#125;&#123;1-x<span class="built_in">^</span>&#123;2&#125;&#125;</span><br><span class="line"><span class="keyword">\right</span>)<span class="built_in">^</span>3 <span class="keyword">\qquad</span></span><br><span class="line"><span class="keyword">\left</span>.<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> f&#125;&#123;<span class="keyword">\partial</span> t&#125;</span><br><span class="line"><span class="keyword">\right</span>|<span class="built_in">_</span>&#123;t=0&#125;<span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
1 + \left(\frac{1}{1-x^{2}}
\right)^3 \qquad
\left.\frac{\partial f}{\partial t}
\right|_{t=0}
\]</span></p>
<p>有时我们不满意于 <span class="math inline">\(\LaTeX{}\)</span>
自动调节的定界符大小。这时还可以用 <code>\big</code>、<code>bigg</code>
等命令生成固定大小的定界符。 更常用的形式是类似 <code>\left</code> 的
<code>\bigl</code>、<code>\biggl</code> 等，以及类似 <code>\right</code>
的 <code>\bigr</code>、<code>\biggr</code> 等（<code>\bigl</code> 和
<code>\bigr</code> 不必成对出现）。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Bigl</span>((x+1)(x-1)<span class="keyword">\Bigr</span>)<span class="built_in">^</span>&#123;2&#125;<span class="built_in">$</span><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\bigl</span>( <span class="keyword">\Bigl</span>( <span class="keyword">\biggl</span>( <span class="keyword">\Biggl</span>( <span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\bigr</span><span class="keyword">\&#125;</span> <span class="keyword">\Bigr</span><span class="keyword">\&#125;</span> <span class="keyword">\biggr</span><span class="keyword">\&#125;</span> <span class="keyword">\Biggr</span><span class="keyword">\&#125;</span> <span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\big</span><span class="keyword">\|</span> <span class="keyword">\Big</span><span class="keyword">\|</span> <span class="keyword">\bigg</span><span class="keyword">\|</span> <span class="keyword">\Bigg</span><span class="keyword">\|</span> <span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\big</span><span class="keyword">\Downarrow</span> <span class="keyword">\Big</span><span class="keyword">\Downarrow</span></span><br><span class="line"><span class="keyword">\bigg</span><span class="keyword">\Downarrow</span> <span class="keyword">\Bigg</span><span class="keyword">\Downarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
\Bigl((x+1)(x-1)\Bigr)^{2}\\
\bigl( \Bigl( \biggl( \Biggl( \quad
\bigr\} \Bigr\} \biggr\} \Biggr\} \quad
\big\| \Big\| \bigg\| \Bigg\| \quad
\big\Downarrow \Big\Downarrow
\bigg\Downarrow \Bigg\Downarrow
\end{gather*}
\]</span></p>
<p>使用 <code>\big</code> 和 <code>\bigg</code>
等命令的另外一个好处是：用<code>\left</code> 和 <code>\right</code>
分界符包裹的公式块是不允许断行的（下文提到的 <span
class="math inline">\(\texttt{array}\)</span> 或者 <span
class="math inline">\(\texttt{aligned}\)</span>
等环境视为一个公式块），所以也不允许在多行公式里跨行使用，而
<code>\big</code> 和 <code>\bigg</code> 等命令不受限制。</p>
<hr />
<h2 id="多行公式">多行公式</h2>
<h3 id="长公式折行">长公式折行</h3>
<p>通常来讲应当避免写出超过一行而需要折行的长公式。如果一定要折行的话，习惯上优先在等号之前折行，其次在加号、减号之前，再次在乘号、除号之前。
其它位置应当避免折行。</p>
<p><code>amsmath</code> 宏包的 <span
class="math inline">\(\texttt{multline}\)</span>
环境提供了书写折行长公式的方便环境。它允许用 <code>\\</code>
折行，将公式编号放在最后一行。多行公式的首行左对齐，末行右对齐，其余行居中。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;multline&#125;</span><br><span class="line">a + b + c + d + e + f</span><br><span class="line">+ g + h + i <span class="keyword">\\</span></span><br><span class="line">= j + k + l + m + n<span class="keyword">\\</span></span><br><span class="line">= o + p + q + r + s<span class="keyword">\\</span></span><br><span class="line">= t + u + v + x + z</span><br><span class="line"><span class="keyword">\end</span>&#123;multline&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120103429233.png" alt="image-20250120103429233" style="zoom:67%;" /></p>
<p>与表格不同的是，<strong>公式的最后一行不写
<code>\\</code>，如果写了，反倒会产生一个多余的空行</strong>。</p>
<p>类似 <span class="math inline">\(\texttt{equation*}\)</span>，<span
class="math inline">\(\texttt{multline*}\)</span>
环境排版不带编号的折行长公式。</p>
<h3 id="多行公式-1">多行公式</h3>
<p>更多的情况是，需要罗列一系列公式，并令其按照等号对齐。 目前最常用的是
<span class="math inline">\(\texttt{align}\)</span> 环境，它将公式用
<span class="math inline">\(\texttt\&amp;\)</span>
隔为两部分并对齐。分隔符通常放在等号左边：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> = b + c <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> = d + e</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{align}
a &amp; = b + c \\
&amp; = d + e
\end{align}
\]</span></p>
<p><span class="math inline">\(\texttt{align}\)</span>
环境会给每行公式都编号。仍然可以用 <code>\notag</code> 去掉某行的编号。
在以下的例子，为了对齐等号，将分隔符放在右侧，并且此时需要在等号后添加一对括号
<span class="math inline">\(\texttt\{\texttt\}\)</span>
以产生正常的间距：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">a =&#123;&#125; <span class="built_in">&amp;</span> b + c <span class="keyword">\\</span></span><br><span class="line">  =&#123;&#125; <span class="built_in">&amp;</span> d + e + f + g + h + i + j + k + l <span class="keyword">\notag</span> <span class="keyword">\\</span></span><br><span class="line">            <span class="built_in">&amp;</span> + m + n + o <span class="keyword">\\</span></span><br><span class="line">    =&#123;&#125; <span class="built_in">&amp;</span> p + q + r + s</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{align}
a ={} &amp; b + c \\
  ={} &amp; d + e + f + g + h + i + j + k + l \notag \\
      &amp; + m + n + o \\
  ={} &amp; p + q + r + s
\end{align}
\]</span></p>
<p><span class="math inline">\(\texttt{align}\)</span>
还能够对齐多组公式，除等号前的 <code>&amp;</code> 之外, 公式之间也用
<code>&amp;</code> 分隔：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">a <span class="built_in">&amp;</span>=1  <span class="built_in">&amp;</span>  b <span class="built_in">&amp;</span>=2   <span class="built_in">&amp;</span> c <span class="built_in">&amp;</span>=3   <span class="keyword">\\</span></span><br><span class="line">d <span class="built_in">&amp;</span>=-1 <span class="built_in">&amp;</span>  e <span class="built_in">&amp;</span>=-2  <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span>=-5</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{align}
a &amp;=1  &amp;  b &amp;=2   &amp; c &amp;=3   \\
d &amp;=-1 &amp;  e &amp;=-2  &amp; f &amp;=-5
\end{align}
\]</span></p>
<p>如果不需要按等号对齐，只需罗列数个公式，<span
class="math inline">\(\texttt{gather}\)</span>
将是一个很好用的环境：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather&#125;</span><br><span class="line">a = b + c <span class="keyword">\\</span></span><br><span class="line">d = e + f + g <span class="keyword">\\</span></span><br><span class="line">h + i = j + k <span class="keyword">\notag</span> <span class="keyword">\\</span></span><br><span class="line">l + m = n</span><br><span class="line"><span class="keyword">\end</span>&#123;gather&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather}
a = b + c \\
d = e + f + g \\
h + i = j + k \notag \\
l + m = n
\end{gather}
\]</span></p>
<p>有对应的不带编号的版本 <span
class="math inline">\(\texttt{align*}\)</span>和 <span
class="math inline">\(\texttt{gather*}\)</span>。</p>
<h3 id="公用编号的多行公式">公用编号的多行公式</h3>
<p>另一个常见的需求是将多个公式组在一起公用一个编号，编号位于公式的居中位置。为此，<code>amsmath</code>
宏包提供了诸如 <span
class="math inline">\(\texttt{aligned}\)</span>、<span
class="math inline">\(\texttt{gathered}\)</span> 等环境，与 <span
class="math inline">\(\texttt{equation}\)</span> 环境套用。以 <span
class="math inline">\(\texttt{-ed}\)</span> 结尾的环境用法与前一节不以
<span class="math inline">\(\texttt{-ed}\)</span>
结尾的环境用法一一对应。仅以 <span
class="math inline">\(\texttt{aligned}\)</span> 举例：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">a <span class="built_in">&amp;</span>= b + c <span class="keyword">\\</span></span><br><span class="line">d <span class="built_in">&amp;</span>= e + f + g <span class="keyword">\\</span></span><br><span class="line">h + i <span class="built_in">&amp;</span>= j + k <span class="keyword">\\</span></span><br><span class="line">l + m <span class="built_in">&amp;</span>= n</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
a &amp;= b + c \\
d &amp;= e + f + g \\
h + i &amp;= j + k \\
l + m &amp;= n
\end{aligned}
\end{equation}
\]</span></p>
<p><span class="math inline">\(\texttt{split}\)</span> 环境和 <span
class="math inline">\(\texttt{aligned}\)</span> 环境用法类似，也用于和
<span class="math inline">\(\texttt{equation}\)</span> 环境套用，区别是
<span class="math inline">\(\texttt{split}\)</span>
只能将每行的一个公式分两栏，<span
class="math inline">\(\texttt{aligned}\)</span>
允许每行多个公式多栏。</p>
<hr />
<h2 id="数组和矩阵">数组和矩阵</h2>
<p>为了排版二维数组，<span class="math inline">\(\LaTeX{}\)</span>
提供了 <span class="math inline">\(\texttt{array}\)</span> 环境，用法与
<span class="math inline">\(\texttt{tabular}\)</span>
环境极为类似，也需要定义列格式，并用 <code>\\</code>
换行。数组可作为一个公式块，在外套用
<code>\left</code>、<code>\right</code> 等定界符：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span> <span class="keyword">\mathbf</span>&#123;X&#125; = <span class="keyword">\left</span>(</span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;cccc&#125;</span><br><span class="line">x<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> <span class="keyword">\ldots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;1n&#125;<span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\ldots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;2n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">_</span>&#123;n1&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;n2&#125; <span class="built_in">&amp;</span> <span class="keyword">\ldots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;nn&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125; <span class="keyword">\right</span>) <span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mathbf{X} = \left(
\begin{array}{cccc}
x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1n}\\
x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2n}\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
x_{n1} &amp; x_{n2} &amp; \ldots &amp; x_{nn}\\
\end{array} \right)
\]</span></p>
<p>值得注意的是，上一节末尾介绍的 <span
class="math inline">\(\texttt{aligned}\)</span>
等环境也可以用定界符包裹。</p>
<p>还可以利用空的定界符排版出这样的效果：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span> |x| = <span class="keyword">\left</span><span class="keyword">\&#123;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;rl&#125;</span><br><span class="line">-x <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;if &#125; x &lt; 0,<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;if &#125; x = 0,<span class="keyword">\\</span></span><br><span class="line">x <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;if &#125; x &gt; 0.</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125; <span class="keyword">\right</span>. <span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
|x| = \left\{
\begin{array}{rl}
-x &amp; \text{if } x &lt; 0,\\
0 &amp; \text{if } x = 0,\\
x &amp; \text{if } x &gt; 0.
\end{array} \right.
\]</span></p>
<p>不过上述例子可以用 <code>amsmath</code> 提供的 <span
class="math inline">\(\texttt{cases}\)</span> 环境更轻松地完成：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span> |x| =</span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">-x <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;if &#125; x &lt; 0,<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;if &#125; x = 0,<span class="keyword">\\</span></span><br><span class="line">x <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;if &#125; x &gt; 0.</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125; <span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
|x| =
\begin{cases}
-x &amp; \text{if } x &lt; 0,\\
0 &amp; \text{if } x = 0,\\
x &amp; \text{if } x &gt; 0.
\end{cases}
\]</span></p>
<p><code>amsmath</code>
宏包还直接提供多种排版矩阵的环境，包括不带定界符的 <span
class="math inline">\(\texttt{matrix}\)</span>，以及带各种定界符的矩阵
<span class="math inline">\(\texttt{pmatrix}\)</span>（<span
class="math inline">\(\bigl(\)</span>）、<span
class="math inline">\(\texttt{bmatrix}\)</span>（<span
class="math inline">\(\bigl[\)</span>）、<span
class="math inline">\(\texttt{Bmatrix}\)</span>（<span
class="math inline">\(\bigl\{\)</span>）、<span
class="math inline">\(\texttt{vmatrix}\)</span>（<span
class="math inline">\(\bigl\vert\)</span>）、<span
class="math inline">\(\texttt{Vmatrix}\)</span>（<span
class="math inline">\(\bigl\Vert\)</span>）。使用这些环境时，无需给定列格式（事实上这些矩阵内部也是用
<span class="math inline">\(\texttt{array}\)</span> 环境生成的。）</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="keyword">\\</span> 3 <span class="built_in">&amp;</span> 4</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125; <span class="keyword">\qquad</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">x<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> <span class="keyword">\ldots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;1n&#125;<span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\ldots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;2n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">_</span>&#123;n1&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;n2&#125; <span class="built_in">&amp;</span> <span class="keyword">\ldots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;nn&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{matrix}
1 &amp; 2 \\ 3 &amp; 4
\end{matrix} \qquad
\begin{bmatrix}
x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1n}\\
x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2n}\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
x_{n1} &amp; x_{n2} &amp; \ldots &amp; x_{nn}\\
\end{bmatrix}
\]</span></p>
<p>在矩阵中的元素里排版分式时，要用到<code>\dfrac</code> 等命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span></span><br><span class="line"><span class="keyword">\mathbf</span>&#123;H&#125;=</span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\dfrac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 f&#125;&#123;<span class="keyword">\partial</span> x<span class="built_in">^</span>2&#125; <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\dfrac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 f&#125;</span><br><span class="line">      &#123;<span class="keyword">\partial</span> x <span class="keyword">\partial</span> y&#125; <span class="keyword">\\</span>[8pt]</span><br><span class="line"><span class="keyword">\dfrac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 f&#125;</span><br><span class="line">      &#123;<span class="keyword">\partial</span> x <span class="keyword">\partial</span> y&#125; <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\dfrac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 f&#125;&#123;<span class="keyword">\partial</span> y<span class="built_in">^</span>2&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mathbf{H}=
\begin{bmatrix}
\dfrac{\partial^2 f}{\partial x^2} &amp;
\dfrac{\partial^2 f}
      {\partial x \partial y} \\[8pt]
\dfrac{\partial^2 f}
      {\partial x \partial y} &amp;
\dfrac{\partial^2 f}{\partial y^2}
\end{bmatrix}
\]</span></p>
<hr />
<h2 id="公式中的间距">公式中的间距</h2>
<p>绝大部分时候，数学公式中各元素的间距是根据符号类型自动生成的，需要手动调整的情况极少。已经认识了两个生成间距的命令
<code>\quad</code> 和
<code>\qquad</code>。在公式中可能用到的间距还包括<code>\,</code>、<code>\:</code>、<code>\;</code>
以及负间距 <code>\!</code>。文本中的 <code>\␣</code>
也能使用在数学公式中。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120153652472.png" alt="image-20250120153652472" style="zoom:67%;" /></p>
<p>一个常见的用途是修正积分的被积函数 <span
class="math inline">\(f(x)\)</span> 和微元 <span
class="math inline">\(\mathrm{d}x\)</span> 之间的距离。注意微元里的
<span class="math inline">\(\mathrm{d}\)</span> 用的是直立体：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span></span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>a<span class="built_in">^</span>b f(x)<span class="keyword">\mathrm</span>&#123;d&#125;x</span><br><span class="line"><span class="keyword">\qquad</span></span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>a<span class="built_in">^</span>b f(x)<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;x</span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\int_a^b f(x)\mathrm{d}x
\qquad
\int_a^b f(x)\,\mathrm{d}x
\]</span></p>
<p>另一个用途是生成多重积分号。如果直接连写两个
<code>\int</code>，之间的间距将会过宽，此时可以使用负间距
<code>\!</code> 修正之。不过 <code>amsmath</code>
提供了更方便的多重积分号，如二重积分
<code>\iint</code>、三重积分<code>\iiint</code> 等。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newcommand</span><span class="keyword">\diff</span>&#123;<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line"><span class="keyword">\int</span><span class="keyword">\int</span> f(x)g(y) <span class="keyword">\diff</span> x <span class="keyword">\diff</span> y <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\int</span><span class="keyword">\!</span><span class="keyword">\!</span><span class="keyword">\!</span><span class="keyword">\int</span> f(x)g(y) <span class="keyword">\diff</span> x <span class="keyword">\diff</span> y <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\iint</span> f(x)g(y) <span class="keyword">\diff</span> x <span class="keyword">\diff</span> y <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\iint</span><span class="keyword">\quad</span> <span class="keyword">\iiint</span><span class="keyword">\quad</span> <span class="keyword">\idotsint</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\newcommand\diff{\,\mathrm{d}}
\begin{gather*}
\int\int f(x)g(y)
\diff x \diff y \\
\int\!\!\!\int
f(x)g(y) \diff x \diff y \\
\iint f(x)g(y) \diff x \diff y \\
\iint\quad \iiint\quad \idotsint
\end{gather*}
\]</span></p>
<hr />
<h2 id="数学符号的字体控制">数学符号的字体控制</h2>
<h3 id="数学字母字体">数学字母字体</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
允许一部分数学符号切换字体，主要是拉丁字母、数字、大写希腊字母以及重音符号等。下表给出了切换字体的命令。某些命令需要字体宏包支持。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;amssymb&#125;</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\mathcal</span>&#123;R&#125; <span class="keyword">\quad</span> <span class="keyword">\mathfrak</span>&#123;R&#125; <span class="keyword">\quad</span> <span class="keyword">\mathbb</span>&#123;R&#125;<span class="built_in">$</span></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\mathcal</span>&#123;L&#125; = -<span class="keyword">\frac</span>&#123;1&#125;&#123;4&#125;F<span class="built_in">_</span>&#123;<span class="keyword">\mu</span><span class="keyword">\nu</span>&#125;F<span class="built_in">^</span>&#123;<span class="keyword">\mu</span><span class="keyword">\nu</span>&#125;<span class="keyword">\]</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\mathfrak</span>&#123;su&#125;(2)<span class="built_in">$</span> and <span class="built_in">$</span><span class="keyword">\mathfrak</span>&#123;so&#125;(3)<span class="built_in">$</span> Lie algebra</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
% \usepackage{amssymb}
\begin{gather*}
\mathcal{R} \quad \mathfrak{R} \quad \mathbb{R} \\
\mathcal{L} = -\frac{1}{4}F_{\mu\nu}F^{\mu\nu} \\
\mathfrak{su}(2) \  and \  \mathfrak{so}(3) \  Lie \  algebra
\end{gather*}
\]</span></p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120160607188.png" alt="image-20250120160607188" style="zoom:67%;" /></p>
<p>一般来说，不同的数学字体往往带有不同的语义，如矩阵、向量等常会使用粗体或粗斜体，而数集常会使用
<code>\mathbb</code>
表示。出于内容与格式分离以及方便书写的考虑，可以为它们定义新的命令。</p>
<h3 id="加粗的数学符号">加粗的数学符号</h3>
<p>上表中的 <code>\mathbf</code>
命令只能获得直立、加粗的字母。如果想得到粗斜体（国内使用粗斜体符号表示矢量，见
GB/T 3102.11—1993）。可以使用 <code>amsmath</code> 宏包提供的
<code>\boldsymbol</code> 命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\mu</span>, M <span class="keyword">\qquad</span> <span class="keyword">\boldsymbol</span>&#123;<span class="keyword">\mu</span>&#125;, <span class="keyword">\boldsymbol</span>&#123;M&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mu, M \qquad \boldsymbol{\mu}, \boldsymbol{M}
\]</span></p>
<p>也可以使用 <code>bm</code> 宏包提供的 <code>\bm</code> 命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;bm&#125;</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\mu</span>, M <span class="keyword">\qquad</span> <span class="keyword">\bm</span>&#123;<span class="keyword">\mu</span>&#125;, <span class="keyword">\bm</span>&#123;M&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>在 <span class="math inline">\(\LaTeX{}\)</span>
默认的数学字体中，一些符号本身并没有粗体版本，使用
<code>\boldsymbol</code> 也得不到粗体。此时 <code>\bm</code>
命令会生成“伪粗体”，尽管效果比较粗糙，但在某些时候也不失为一种解决方案。</p>
<h3 id="数学符号的尺寸">数学符号的尺寸</h3>
<p>数学符号按照符号排版的位置规定尺寸，从大到小包括行间公式尺寸、行内公式尺寸、上下标尺寸、次级上下标尺寸。除了字号有别之外，行间和行内公式尺寸下的巨算符也使用不一样的大小。
为每个数学尺寸指定了一个切换的命令，见 下表。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">命令</th>
<th style="text-align: left;">尺寸</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>\displaystyle</code></td>
<td style="text-align: left;">行间公式尺寸</td>
<td style="text-align: left;"><span
class="math inline">\(\displaystyle\sum a\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>\textstyle</code></td>
<td style="text-align: left;">行内公式尺寸</td>
<td style="text-align: left;"><span class="math inline">\(\textstyle\sum
a\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>\scriptstyle</code></td>
<td style="text-align: left;">上下标尺寸</td>
<td style="text-align: left;"><span class="math inline">\(\scriptstyle
a\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>\scriptscriptstyle</code></td>
<td style="text-align: left;">次级上下标尺寸</td>
<td style="text-align: left;"><span
class="math inline">\(\scriptscriptstyle a\)</span></td>
</tr>
</tbody>
</table>
<p>通过以下示例对比行间公式和行内公式的区别。在分式中，<strong>分子分母默认为行内公式尺寸</strong>，示例中将分母切换到行间公式尺寸：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\[</span></span><br><span class="line">r = <span class="keyword">\frac</span></span><br><span class="line">  &#123;<span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n (x<span class="built_in">_</span>i- x)(y<span class="built_in">_</span>i- y)&#125;</span><br><span class="line">  &#123;<span class="keyword">\displaystyle</span> <span class="keyword">\left</span>[</span><br><span class="line">    <span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n (x<span class="built_in">_</span>i-x)<span class="built_in">^</span>2</span><br><span class="line">    <span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n (y<span class="built_in">_</span>i-y)<span class="built_in">^</span>2</span><br><span class="line">  <span class="keyword">\right</span>]<span class="built_in">^</span>&#123;1/2&#125; &#125;</span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
r = \frac
  {\sum_{i=1}^n (x_i- x)(y_i- y)}
  {\displaystyle \left[
    \sum_{i=1}^n (x_i-x)^2
    \sum_{i=1}^n (y_i-y)^2
  \right]^{1/2} }
\]</span></p>
<hr />
<h2 id="定理环境">定理环境</h2>
<h3 id="latex-原始的定理环境"><span
class="math inline">\(\LaTeX{}\)</span> 原始的定理环境</h3>
<p>使用 <span class="math inline">\(\LaTeX{}\)</span>
排版数学和其他科技文档时，会接触到大量的定理、证明等内容。<span
class="math inline">\(\LaTeX{}\)</span> 提供了一个基本的命令
<code>\newtheorem</code> 提供定理环境的定义：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newtheorem</span>&#123;theorem environment&#125;&#123;title&#125;[section-level] <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\newtheorem</span>&#123;theorem environment&#125;[counter]&#123;title&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(\textrm{theorem environment}\)</span>
为定理环境的名称。原始的 <span class="math inline">\(\LaTeX{}\)</span>
里<strong>没有现成的定理环境</strong>，不加定义而直接使用很可能会出错。<span
class="math inline">\(\textrm{title}\)</span>
是定理环境的标题（“定理”，“公理”等）。</p>
<p>定理的序号由两个可选参数之一决定，它们<strong>不能同时使用</strong>：</p>
<ul>
<li><span class="math inline">\(\textrm{section-level}\)</span>
为章节级别，如 <span
class="math inline">\(\texttt{chapter}\)</span>、<span
class="math inline">\(\texttt{section}\)</span>
等，定理序号成为章节的下一级序号；</li>
<li><span class="math inline">\(\textrm{counter}\)</span> 为用
<code>\newcounter</code>
自定义的计数器名称，定理序号由这个计数器管理。</li>
</ul>
<p>如果两个可选参数都不用的话，则使用默认的与定理环境同名的计数器。</p>
<p>在以下示例代码中，定义了一个 <span
class="math inline">\(\texttt{mythm}\)</span> 环境，其序号设为 <span
class="math inline">\(\texttt{section}\)</span> 的下一级序号。注意 <span
class="math inline">\(\texttt{mythm}\)</span> 环境的可选参数以及
<code>\label</code> 的用法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newtheorem</span>&#123;mythm&#125;&#123;My Theorem&#125;[section]</span><br><span class="line"><span class="keyword">\begin</span>&#123;mythm&#125;<span class="keyword">\label</span>&#123;thm:light&#125;</span><br><span class="line">The light speed in vacuum</span><br><span class="line">is <span class="built_in">$</span>299,792,458<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;m/s&#125;<span class="built_in">$</span>.</span><br><span class="line"><span class="keyword">\end</span>&#123;mythm&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;mythm&#125;[Energy-momentum relation]</span><br><span class="line">The relationship of energy,</span><br><span class="line">momentum and mass is</span><br><span class="line"><span class="keyword">\[</span>E<span class="built_in">^</span>2 = m<span class="built_in">_</span>0<span class="built_in">^</span>2 c<span class="built_in">^</span>4 + p<span class="built_in">^</span>2 c<span class="built_in">^</span>2<span class="keyword">\]</span></span><br><span class="line">where <span class="built_in">$</span>c<span class="built_in">$</span> is the light speed</span><br><span class="line">described in theorem <span class="keyword">\ref</span>&#123;thm:light&#125;.</span><br><span class="line"><span class="keyword">\end</span>&#123;mythm&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120165121095.png" alt="image-20250120165121095" style="zoom:67%;" /></p>
<h3 id="amsthm-宏包"><code>amsthm</code> 宏包</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
默认的定理环境格式为粗体标签、斜体内容、定理名用小括号包裹。如果需要修改格式，则要依赖其它的宏包，如
<code>amsthm</code>、<code>ntheorem</code> 等等。本小节简单介绍一下
<code>amsthm</code> 的用法。</p>
<p><code>amsthm</code> 提供了 <code>\theoremstyle</code>
命令支持定理格式的切换，在用 <code>\newtheorem</code>
命令定义定理环境之前使用。<code>amsthm</code>
预定义了三种格式用于<code>\theoremstyle</code>：<span
class="math inline">\(\texttt{plain}\)</span> 和 <span
class="math inline">\(\LaTeX{}\)</span> 原始的格式一致；<span
class="math inline">\(\texttt{definition}\)</span>
使用粗体标签、正体内容；<span
class="math inline">\(\texttt{remark}\)</span>
使用斜体标签、正体内容。</p>
<p>另外 <code>amsthm</code> 还支持用带星号的 <code>\newtheorem*</code>
定义不带序号的定理环境：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\theoremstyle</span>&#123;definition&#125; <span class="keyword">\newtheorem</span>&#123;law&#125;&#123;Law&#125;</span><br><span class="line"><span class="keyword">\theoremstyle</span>&#123;plain&#125; <span class="keyword">\newtheorem</span>&#123;jury&#125;[law]&#123;Jury&#125;</span><br><span class="line"><span class="keyword">\theoremstyle</span>&#123;remark&#125; <span class="keyword">\newtheorem</span>*&#123;mar&#125;&#123;Margaret&#125;</span><br></pre></td></tr></table></figure>
<p>以上例子定义的 <span class="math inline">\(\texttt{jury}\)</span>
环境与 <span class="math inline">\(\texttt{law}\)</span>
环境共用编号，<span class="math inline">\(\texttt{mar}\)</span>
环境不编号：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\theoremstyle</span>&#123;definition&#125; <span class="keyword">\newtheorem</span>&#123;law&#125;&#123;Law&#125;</span><br><span class="line"><span class="keyword">\theoremstyle</span>&#123;plain&#125; <span class="keyword">\newtheorem</span>&#123;jury&#125;[law]&#123;Jury&#125;</span><br><span class="line"><span class="keyword">\theoremstyle</span>&#123;remark&#125; <span class="keyword">\newtheorem</span>*&#123;mar&#125;&#123;Margaret&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;law&#125;<span class="keyword">\label</span>&#123;law:box&#125;</span><br><span class="line">Don&#x27;t hide in the witness box.</span><br><span class="line"><span class="keyword">\end</span>&#123;law&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;jury&#125;[The Twelve]</span><br><span class="line">It could be you! So beware and</span><br><span class="line">see law~<span class="keyword">\ref</span>&#123;law:box&#125;.<span class="keyword">\end</span>&#123;jury&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;jury&#125;</span><br><span class="line">You will disregard the last</span><br><span class="line">statement.<span class="keyword">\end</span>&#123;jury&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;mar&#125;No, No, No<span class="keyword">\end</span>&#123;mar&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;mar&#125;Denis!<span class="keyword">\end</span>&#123;mar&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120171711806.png" alt="image-20250120171711806" style="zoom:67%;" /></p>
<p><code>amsthm</code> 还支持使用 <code>\newtheoremstyle</code>
命令自定义定理格式，更为方便使用的是 <code>ntheorem</code>
宏包。感兴趣的读者可参阅它们的帮助文档。</p>
<h3 id="证明环境和证毕符号">证明环境和证毕符号</h3>
<p><code>amsthm</code> 还提供了一个 <span
class="math inline">\(\texttt{proof}\)</span>
环境用于排版定理的证明过程。环境末尾自动加上一个 □ 证毕符号：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;proof&#125;</span><br><span class="line">For simplicity, we use</span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line">E=mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line">That&#x27;s it.</span><br><span class="line"><span class="keyword">\end</span>&#123;proof&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120173549574.png" alt="image-20250120173549574" style="zoom:67%;" /></p>
<p>如果行末是一个不带编号的公式，□ 符号会另起一行，这时可使用
<code>\qedhere</code> 命令将 □ 符号放在公式末尾：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120173828551.png" alt="image-20250120173828551" style="zoom:67%;" /></p>
<p><code>\qedhere</code> 对于 <span
class="math inline">\(\texttt{align*}\)</span> 等环境也有效：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;proof&#125;</span><br><span class="line">Assuming <span class="built_in">$</span><span class="keyword">\gamma</span></span><br><span class="line">= 1/<span class="keyword">\sqrt</span>&#123;1-v<span class="built_in">^</span>2/c<span class="built_in">^</span>2&#125;<span class="built_in">$</span>, then</span><br><span class="line"><span class="keyword">\begin</span>&#123;align*&#125;</span><br><span class="line">E <span class="built_in">&amp;</span>= <span class="keyword">\gamma</span> m<span class="built_in">_</span>0 c<span class="built_in">^</span>2  <span class="keyword">\\</span></span><br><span class="line">p <span class="built_in">&amp;</span>= <span class="keyword">\gamma</span> m<span class="built_in">_</span>0v <span class="keyword">\qedhere</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align*&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;proof&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120174116569.png" alt="image-20250120174116569" style="zoom:67%;" /></p>
<p>在使用带编号的公式时，最好<strong>不要在公式末尾使用</strong>
<code>\qedhere</code> 命令。对带编号的公式使用<code>\qedhere</code>
命令会使 □ 符号放在一个难看的位置，紧贴着公式：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120174348875.png" alt="image-20250120174348875" style="zoom:67%;" /></p>
<p>在 <span class="math inline">\(\texttt{align}\)</span> 等环境中使用
<code>\qedhere</code> 命令会使 □ 盖掉公式的编号；使用 <span
class="math inline">\(\texttt{equation}\)</span> 嵌套 <span
class="math inline">\(\texttt{aligned}\)</span>
等环境时，<code>\qedhere</code> 命令会将 □
直接放在公式后。这些位置都不太正常。</p>
<p>证毕符号 □ 本身被定义在命令 <code>\qedsymbol</code>
中，如果有使用实心符号作为证毕符号的需求，需要自行用
<code>\renewcommand&#125;</code>命令修改。可以利用标尺盒子来生成一个适当大小的“实心矩形”：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\qedsymbol</span>&#125;<span class="comment">%</span></span><br><span class="line">  &#123;<span class="keyword">\rule</span>&#123;1ex&#125;&#123;1.5ex&#125;&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;proof&#125;</span><br><span class="line">For simplicity, we use</span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line">E=mc<span class="built_in">^</span>2 <span class="keyword">\qedhere</span></span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"><span class="keyword">\end</span>&#123;proof&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120174901879.png" alt="image-20250120174901879" style="zoom:67%;" /></p>
<hr />
<h2 id="符号表">符号表</h2>
<p><a
href="https://invinc-z.com/notes_lshort/symbol_table/">在这里</a>。</p>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之文档元素（三）</title>
    <url>/lang-latex/notes-lshort/03-document-elements/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>在知道了如何输入文字后，本章介绍一个结构化的文档所依赖的各种元素——章节、目录、列表、图表、交叉引用、脚注等等。</p>
<span id="more"></span>
<hr />
<h2 id="章节和目录">章节和目录</h2>
<h3 id="章节标题">章节标题</h3>
<p>一篇结构化的、条理清晰文档一定是层次分明的，通过不同的命令分割为章、节、小节。三个标准文档类
<code>article</code>、<code>report</code> 和 <code>book</code>
提供了划分章节的命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\chapter</span>&#123;⟨title⟩&#125; <span class="keyword">\section</span>&#123;⟨title⟩&#125; <span class="keyword">\subsection</span>&#123;⟨title⟩&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;⟨title⟩&#125; <span class="keyword">\paragraph</span>&#123;⟨title⟩&#125; <span class="keyword">\subparagraph</span>&#123;⟨title⟩&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>\chapter</code> <strong>只在 <code>report</code> 和
<code>book</code>
文档类有定义</strong>。这些命令生成章节标题，并能够自动编号。除此之外
<span class="math inline">\(\LaTeX{}\)</span> 还提供了
<code>\part</code> 命令，用来将整个文档分割为大的分块，但不影响
<code>\chapter</code> 或 <code>\section</code> 等的编号。</p>
<p>上述命令除了生成带编号的标题之外，还向目录中添加条目，并影响页眉页脚的内容。每个命令有两种变体：</p>
<ul>
<li><p>带可选参数的变体：<code>\section[&lt;short title&gt;]&#123;&lt;title&gt;&#125;</code>
，标题使用 <code>&lt;title&gt;</code> 参数，在目录和页眉页脚中使用
<code>&lt;short title&gt;</code>参数；</p></li>
<li><p>带星号的变体：<code>\section*&#123;&lt;title&gt;&#125;</code>
，标题不带编号，也不生成目录项和页眉页脚。</p></li>
</ul>
<p>较低层次如 <code>\paragraph</code> 和 <code>\subparagraph</code>
即使不用带星号的变体，生成的标题默认也不带编号，事实上，除
<code>\part</code> 外：</p>
<ul>
<li><code>article</code> 文档类带编号的层级为
<code>\section</code>、<code>\subsection</code>、<code>\subsubsection</code>
三级；</li>
<li><code>report</code> 和 <code>book</code> 文档类带编号的层级为
<code>\chapter</code>、<code>\section</code>、<code>\subsection</code>
三级。</li>
</ul>
<h3 id="目录">目录</h3>
<p>生成目录非常容易，只需在合适的地方使用命令：<code>\tableofcontents</code></p>
<p>这个命令会生成单独的一章（<code>report</code>/<code>book</code>）或一节（<code>article</code>），标题默认为“Contents”，可定制标题。这种生成的章节默认不写入目录（<code>\section*</code>
或 <code>\chapter*</code>），可使用 <code>tocbibind</code>
等宏包修改设置。</p>
<p>正确生成目录项，一般需要 <strong>编译两次源代码</strong>。</p>
<p>有时使用了 <code>\chapter*</code> 或 <code>\section*</code>
这样不生成章节编号和目录项的章节标题命令，而又想手动生成该章节的目录项，可以在标题命令后面使用：</p>
<p><code>\addcontentsline&#123;toc&#125;&#123;&lt;level&gt;&#125;&#123;&lt;title&gt;&#125;</code></p>
<p>其中 <code>&lt;level&gt;</code> 为章节层次 <span
class="math inline">\(\texttt{chapter}\)</span> 或 <span
class="math inline">\(\texttt{section}\)</span>
等，<code>&lt;title&gt;</code> 为出现于目录项的章节标题。</p>
<p><code>titletoc</code>、<code>tocloft</code>
等宏包提供了具体定制目录项格式的功能，详情请参考宏包的帮助文档。</p>
<h3 id="文档结构的划分">文档结构的划分</h3>
<p>所有标准文档类都提供了一个 <code>\appendix</code>
命令将正文和附录分开，使用 <code>\appendix</code>
后，最高一级章节改为使用拉丁字母编号，从 A 开始。</p>
<p><code>book</code> 文档类还提供了前言、正文、后记结构的划分命令：</p>
<ul>
<li><code>\frontmatter</code> 前言部分，页码使用小写罗马数字；其后的
<code>\chapter</code> 不编号。</li>
<li><code>\mainmatter</code> 正文部分，页码使用阿拉伯数字，从 1
开始计数；其后的章节编号正常。</li>
<li><code>\backmatter</code>
后记部分，页码格式不变，继续正常计数；其后的 <code>\chapter</code>
不编号。</li>
</ul>
<p>以上三个命令还可和 <code>\appendix</code>
命令结合，生成有前言、正文、附录、后记四部分的文档。</p>
<p>下面的源代码是一份完整的文档结构。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;book&#125;</span><br><span class="line"><span class="comment">% 导言区，加载宏包和各项设置，包括参考文献、索引等</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;makeidx&#125;        <span class="comment">% 调用 makeidx 宏包，用来处理索引</span></span><br><span class="line"><span class="keyword">\makeindex</span>                  <span class="comment">% 开启索引的收集</span></span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;plain&#125;   <span class="comment">% 指定参考文献样式为 plain</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;Languages&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;someone&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\frontmatter</span>         <span class="comment">% 前言部分</span></span><br><span class="line"><span class="keyword">\maketitle</span>           <span class="comment">% 标题页</span></span><br><span class="line"><span class="keyword">\include</span>&#123;preface&#125;    <span class="comment">% 前言章节 preface.tex</span></span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\mainmatter</span>          <span class="comment">% 正文部分</span></span><br><span class="line"><span class="keyword">\include</span>&#123;chapter1&#125;   <span class="comment">% 第一章 chapter1.tex</span></span><br><span class="line"><span class="keyword">\include</span>&#123;chapter2&#125;   <span class="comment">% 第二章 chapter2.tex</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">\appendix</span>            <span class="comment">% 附录</span></span><br><span class="line"><span class="keyword">\include</span>&#123;appendixA&#125;  <span class="comment">% 附录 A appendixA.tex</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">\backmatter</span>          <span class="comment">% 后记部分</span></span><br><span class="line"><span class="keyword">\include</span>&#123;epilogue&#125;   <span class="comment">% 后记 epilogue.tex</span></span><br><span class="line"><span class="keyword">\bibliography</span>&#123;books&#125; <span class="comment">% 利用 BibTeX 工具从数据库文件 books.bib 生成参考文献</span></span><br><span class="line"><span class="keyword">\printindex</span>          <span class="comment">% 利用 makeindex 工具生成索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="标题页">标题页</h2>
<p><span class="math inline">\(\LaTeX{}\)</span>
支持生成简单的标题页。首先需要给定标题和作者等信息：</p>
<p><code>\title&#123;&lt;title&gt;&#125;</code>
<code>\author&#123;&lt;author&gt;&#125;</code>
<code>\date&#123;&lt;date&gt;&#125;</code></p>
<p>其中前两个命令是必须的（不用 <code>\title</code> 会报错；不用
<code>\author</code> 会警告），<code>\date</code> 命令可选。<span
class="math inline">\(\LaTeX{}\)</span> 还提供了一个 <code>\today</code>
命令自动生成当前日期，<code>\date</code> 默认使用 <code>today</code>。在
<code>\title</code>、<code>\author</code> 等命令内可以使用
<code>\thanks</code> 命令生成标题页的脚注，用 <code>\and</code>
隔开多个人名。</p>
<p>在信息给定后，就可以使用 <code>\maketitle</code>
命令生成一个简单的标题页了。下面的源代码给出了一个标题页的示例和大致效果。</p>
<p><span class="math inline">\(\texttt{article}\)</span>
文档类的标题默认不单独成页，而 <span
class="math inline">\(\texttt{report}\)</span> 和 <span
class="math inline">\(\texttt{book}\)</span> 默认单独成页。可在
<code>\documentclass</code> 命令调用文档类时指定 <span
class="math inline">\(\texttt{titlepage}\)</span> 或 <span
class="math inline">\(\texttt{notitlepage}\)</span>
选项以修改默认的行为。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;Test title&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123; Mary<span class="keyword">\thanks</span>&#123;E-mail:*****@***.com&#125;</span><br><span class="line">  <span class="keyword">\and</span> Ted<span class="keyword">\thanks</span>&#123;Corresponding author&#125;</span><br><span class="line">  <span class="keyword">\and</span> Louis&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114201008937.png" alt="image-20250114201008937" style="zoom:67%;" /></p>
<p><span class="math inline">\(\LaTeX{}\)</span>
标准类还提供了一个简单的 <code>titlepage</code>
环境，生成不带页眉页脚的一页。用户可以在这个环境中使用各种排版元素自由发挥，生成自定义的标题页以替代
<code>\maketitle</code> 命令。甚至可以利用 <code>titlepage</code>
环境重新定义 <code>\maketitle</code>：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\maketitle</span>&#125;&#123;<span class="keyword">\begin</span>&#123;titlepage&#125;</span><br><span class="line">... <span class="comment">% 用户自定义命令</span></span><br><span class="line"><span class="keyword">\end</span>&#123;titlepage&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，为标准文档类指定了 <span
class="math inline">\(\texttt{titlepage}\)</span> 选项以后，使用
<code>\maketitle</code> 命令生成的标题页就是一个 <span
class="math inline">\(\texttt{titlepage}\)</span> 环境。</p>
<p>以上是 <span class="math inline">\(\LaTeX{}\)</span>
标准文档类的标题页相关命令用法。在各种文档模板中经常有自定义的标题页，有可能需要除了
<code>\title</code> 和 <code>\author</code>
以外的命令给定信息，用法也可能与标准文档类的不一致（甚至有些模板可能没有定义
<span class="math inline">\(\texttt{titlepage}\)</span> 等环境）。</p>
<p><strong>使用文档模板前一定要仔细阅读文档模板的帮助文档。</strong></p>
<hr />
<h2 id="交叉引用">交叉引用</h2>
<p>交叉引用是 <span class="math inline">\(\LaTeX{}\)</span>
强大的自动排版功能的体现之一。在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用
<code>\label</code> 命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\label</span>&#123;&lt;label-name&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>之后可以在别处使用 <code>\ref</code> 或 <code>\pageref</code>
命令，分别生成交叉引用的编号和页码：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ref</span>&#123;&lt;label-name&gt;&#125;	<span class="keyword">\pageref</span>&#123;&lt;label-name&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114202135903.png" alt="image-20250114202135903" style="zoom:67%;" /></p>
<p>为了生成正确的交叉引用，一般也需要
<strong>多次编译源代码</strong>。</p>
<p><code>label</code>
命令可用于记录各种类型的交叉引用，使用位置分别为：</p>
<ul>
<li><strong>章节标题</strong> 在章节标题命令 <code>\section</code>
等之后紧接着使用。</li>
<li><strong>行间公式</strong>
单行公式在公式内任意位置使用；多行公式在每一行公式的任意位置使用。</li>
<li><strong>有序列表</strong> 在 <span
class="math inline">\(\texttt{enumerate}\)</span> 环境的每个
<code>\item</code> 命令之后、下一个 <code>\item</code>
命令之前任意位置使用。</li>
<li><strong>图表标题</strong> 在图表标题命令 <code>\caption</code>
之后紧接着使用。</li>
<li><strong>定理环境</strong> 在定理环境内部任意位置使用。</li>
</ul>
<p>在使用不记编号的命令形式（<code>\section*</code>、<code>\caption*</code>、带可选参数的
<code>\item</code> 命令等）时不要使用 <code>\label</code>
命令，否则生成的引用编号不正确。</p>
<hr />
<h2 id="脚注和边注">脚注和边注</h2>
<p>使用 <code>\footnote</code>
命令可以在页面底部生成一个脚注。假如输入以下文字和命令：</p>
<blockquote>
<p>“ 天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。” <span
class="math inline">\(\texttt{\footnote{出自《千字文》。}}\)</span></p>
</blockquote>
<p>在正文中则为：“天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。”<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p>有些情况下（比如在表格环境、各种盒子内）使用 <code>\footnote</code>
并不能正确生成脚注。可以分两步进行，先使用 <code>\footnotemark</code>
为脚注计数，再在合适的位置用 <code>\footnotetext</code>
生成脚注。比如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;l&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">“天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。”<span class="keyword">\footnotemark</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\footnotetext</span>&#123;表格里的名句出自《千字文》。&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114210530107.png" alt="image-20250114210530107" style="zoom:67%;" /></p>
<p>使用 <code>\marginpar</code> 命令可在边栏位置生成边注：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\marginpar</span>[⟨left-margin⟩]&#123;⟨right-margin⟩&#125;</span><br></pre></td></tr></table></figure>
<p>如果只给定了 right-margin，那么边注在奇偶数页文字相同；如果同时给定了
left-margin，则偶数页使用 left-margin 的文字。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114211653969.png" alt="image-20250114211653969" style="zoom:67%;" /></p>
<hr />
<h2 id="特殊环境">特殊环境</h2>
<h3 id="列表">列表</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
提供了基本的有序和无序列表环境 <span
class="math inline">\(\texttt{enumerate}\)</span> 和 <span
class="math inline">\(\texttt{itemize}\)</span>，两者用法类似，都用
<code>\item</code> 标明每个列表项。<span
class="math inline">\(\texttt{enumerate}\)</span>
环境会自动对列表项编号。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> …</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>\item</code>
可带一个可选参数，将有序列表的计数或者无序列表的符号替换成自定义的符号。列表可以嵌套使用，最多嵌套四层。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">  <span class="keyword">\item</span> An item.</span><br><span class="line">  <span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">    <span class="keyword">\item</span> A nested item.<span class="keyword">\label</span>&#123;itref&#125;</span><br><span class="line">    <span class="keyword">\item</span>[*] A starred item.</span><br><span class="line">  <span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line">  <span class="keyword">\item</span> Reference(<span class="keyword">\ref</span>&#123;itref&#125;).</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114212322245.png" alt="image-20250114212322245" style="zoom:67%;" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">  <span class="keyword">\item</span> An item.</span><br><span class="line">  <span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">    <span class="keyword">\item</span> A nested item.</span><br><span class="line">    <span class="keyword">\item</span>[+] A `plus&#x27; item.</span><br><span class="line">    <span class="keyword">\item</span> Another item.</span><br><span class="line">  <span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line">  <span class="keyword">\item</span> Go back to upper level.</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114212430376.png" alt="image-20250114212430376" style="zoom:67%;"/></p>
<p>关键字环境 <span class="math inline">\(\texttt{description}\)</span>
的用法与以上两者类似，不同的是 <code>\item</code>
后的可选参数用来写关键字，以粗体显示，一般是必填的：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;description&#125;</span><br><span class="line"><span class="keyword">\item</span>[⟨item title⟩] …</span><br><span class="line"><span class="keyword">\end</span>&#123;description&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;description&#125;</span><br><span class="line">  <span class="keyword">\item</span>[Enumerate] Numbered list.</span><br><span class="line">  <span class="keyword">\item</span>[Itemize] Non-numbered list.</span><br><span class="line"><span class="keyword">\end</span>&#123;description&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114212752393.png" alt="image-20250114212752393" style="zoom:67%;" /></p>
<p>各级无序列表的符号由命令 <code>\labelitemi</code> 到
<code>\labelitemiv</code> 定义，可以简单地重新定义它们：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\labelitemi</span>&#125;&#123;<span class="keyword">\ddag</span>&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\labelitemii</span>&#125;&#123;<span class="keyword">\dag</span>&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">  <span class="keyword">\item</span> First item</span><br><span class="line">  <span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">    <span class="keyword">\item</span> Subitem</span><br><span class="line">    <span class="keyword">\item</span> Subitem</span><br><span class="line">  <span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line">  <span class="keyword">\item</span> Second item</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114213005038.png" alt="image-20250114213005038" style="zoom:67%;" /></p>
<p>有序列表的符号由命令 <code>\labelenumi</code> 到
<code>\labelenumiv</code>
定义，重新定义这些命令需要用到计数器相关命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\labelenumi</span>&#125;<span class="comment">%</span></span><br><span class="line">  &#123;<span class="keyword">\Alph</span>&#123;enumi&#125;&gt;&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">  <span class="keyword">\item</span> First item</span><br><span class="line">  <span class="keyword">\item</span> Second item</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114213232649.png" alt="image-20250114213232649" style="zoom:67%;" /></p>
<p>默认的列表间距比较宽，<span class="math inline">\(\LaTeX{}\)</span>
本身也未提供方便的定制功能，可用 <code>enumitem</code>
宏包定制各种列表间距。<code>enumitem</code>
宏包还提供了对列表标签、引用等的定制。有兴趣的读者可参考其帮助文档。</p>
<h3 id="对齐环境">对齐环境</h3>
<p><span class="math inline">\(\texttt{center}\)</span>、<span
class="math inline">\(\texttt{flushleft}\)</span> 和 <span
class="math inline">\(\texttt{flushright}\)</span>
环境分别用于生成居中、左对齐和右对齐的文本环境。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125; … <span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushleft&#125; … <span class="keyword">\end</span>&#123;flushleft&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushright&#125; … <span class="keyword">\end</span>&#123;flushright&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">Centered text using a</span><br><span class="line"><span class="keyword">\verb</span>|<span class="string">center</span>| environment.</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushleft&#125;</span><br><span class="line">Left-aligned text using a</span><br><span class="line"><span class="keyword">\verb</span>|<span class="string">flushleft</span>| environment.</span><br><span class="line"><span class="keyword">\end</span>&#123;flushleft&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushright&#125;</span><br><span class="line">Right-aligned text using a</span><br><span class="line"><span class="keyword">\verb</span>|<span class="string">flushright</span>| environment.</span><br><span class="line"><span class="keyword">\end</span>&#123;flushright&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114214234722.png" alt="image-20250114214234722" style="zoom:67%;" /></p>
<p>除此之外，还可以用以下命令直接改变文字的对齐方式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\centering</span>	 <span class="keyword">\raggedright</span> 	<span class="keyword">\raggedleft</span></span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\centering</span></span><br><span class="line">Centered text paragraph.</span><br><span class="line"></span><br><span class="line"><span class="keyword">\raggedright</span></span><br><span class="line">Left-aligned text paragraph.</span><br><span class="line"></span><br><span class="line"><span class="keyword">\raggedleft</span></span><br><span class="line">Right-aligned text paragraph.</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114214436517.png" alt="image-20250114214436517" style="zoom:67%;" /></p>
<p>三个命令和对应的环境经常被误用，有直接用所谓 <code>\flushleft</code>
命令或者 <code>raggedright</code>
环境的，都是不甚严格的用法（即使它们可能有效）。有一点可以将两者区分开来：<span
class="math inline">\(\texttt{center}\)</span>
等<strong>环境会在上下文产生一个额外间距</strong>，而
<code>\centering</code>
等<strong>命令不产生，只是改变对齐方式</strong>。比如在浮动体环境 <span
class="math inline">\(\texttt{table}\)</span> 或 <span
class="math inline">\(\texttt{figure}\)</span> 内实现居中对齐，用
<code>\centering</code> 命令即可，没必要再用 <span
class="math inline">\(\texttt{center}\)</span> 环境。</p>
<h3 id="引用环境">引用环境</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
提供了两种引用的环境：<span
class="math inline">\(\texttt{quote}\)</span>
用于引用较短的文字，首行不缩进；<span
class="math inline">\(\texttt{quotation}\)</span>
用于引用若干段文字，首行缩进。引用环境较一般文字有额外的左右缩进。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Francis Bacon says:</span><br><span class="line"><span class="keyword">\begin</span>&#123;quote&#125;</span><br><span class="line">Knowledge is power.</span><br><span class="line"><span class="keyword">\end</span>&#123;quote&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114215152828.png" alt="image-20250114215152828" style="zoom:67%;" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">《木兰诗》：</span><br><span class="line"><span class="keyword">\begin</span>&#123;quotation&#125;</span><br><span class="line">万里赴戎机，关山度若飞。</span><br><span class="line">朔气传金柝，寒光照铁衣。</span><br><span class="line">将军百战死，壮士十年归。</span><br><span class="line"></span><br><span class="line">归来见天子，天子坐明堂。</span><br><span class="line">策勋十二转，赏赐百千强。……</span><br><span class="line"><span class="keyword">\end</span>&#123;quotation&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114215308777.png" alt="image-20250114215308777" style="zoom:67%;" /></p>
<p><span class="math inline">\(\texttt{verse}\)</span> 用于排版诗歌，与
<span class="math inline">\(\texttt{quotation}\)</span> 恰好相反，<span
class="math inline">\(\texttt{verse}\)</span> 是首行悬挂缩进的。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Rabindranath Tagore&#x27;s short poem:</span><br><span class="line"><span class="keyword">\begin</span>&#123;verse&#125;</span><br><span class="line">Beauty is truth&#x27;s smile</span><br><span class="line">when she beholds her own face in</span><br><span class="line">a perfect mirror.</span><br><span class="line"><span class="keyword">\end</span>&#123;verse&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114215501957.png" alt="image-20250114215501957" style="zoom:67%;" /></p>
<h3 id="摘要环境">摘要环境</h3>
<p>摘要环境 <span class="math inline">\(\texttt{abstract}\)</span>
默认只在标准文档类中的 <span
class="math inline">\(\texttt{article}\)</span> 和 <span
class="math inline">\(\texttt{report}\)</span> 文档类可用，一般用于紧跟
<code>\maketitle</code> 命令之后介绍文档的摘要。如果文档类指定了 <span
class="math inline">\(\texttt{titlepage}\)</span>
选项，则单独成页；反之，单栏排版时相当于一个居中的小标题加一个 <span
class="math inline">\(\texttt{quotation}\)</span> 环境，双栏排版时相当于
<code>\section*</code> 定义的一节。</p>
<h3 id="代码环境">代码环境</h3>
<p>有时需要将一段代码原样转义输出，这就要用到代码环境 <span
class="math inline">\(\texttt{verbatim}\)</span>，它以等宽字体排版代码，回车和空格也分别起到换行和空位的作用；
带星号的版本更进一步将空格显示成 <code>␣</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;verbatim&#125;<span class="string"></span></span><br><span class="line"><span class="string">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  std::cout &lt;&lt; &quot;Hello, world!&quot;</span></span><br><span class="line"><span class="string">            &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span><span class="keyword">\end</span>&#123;verbatim&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114220451842.png" alt="image-20250114220451842" style="zoom:67%;" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;verbatim*&#125;<span class="string"></span></span><br><span class="line"><span class="string">for (int i=0; i&lt;4; ++i)</span></span><br><span class="line"><span class="string">  printf(&quot;Number %d\n&quot;,i);</span></span><br><span class="line"><span class="string"></span><span class="keyword">\end</span>&#123;verbatim*&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114220636123.png" alt="image-20250114220636123" style="zoom:67%;" /></p>
<p>要排版简短的代码或关键字，可使用 <code>\verb</code> 命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\verb</span>⟨<span class="string">delim⟩</span>⟨code⟩⟨delim⟩</span><br></pre></td></tr></table></figure>
<p><code>&lt;delim&gt;</code>
标明代码的分界位置，前后必须一致，除字母、空格或星号外，可任意选择使得不与代码本身冲突，习惯上使用
<span class="math inline">\(\texttt|\)</span> 符号。</p>
<p>同 <span class="math inline">\(\texttt{verbatim}\)</span>
环境，<code>\verb</code> 后也可以带一个星号，以显示空格：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\verb</span>|<span class="string">\LaTeX</span>| <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\verb</span>+<span class="string">(a || b)</span>+ <span class="keyword">\verb</span>*<span class="string">+(a || b)+</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114220953291.png" alt="image-20250114220953291" style="zoom:67%;" /></p>
<p><code>\verb</code>
命令对符号的处理比较复杂，一般<strong>不能用在其它命令的参数里</strong>，否则多半会出错。</p>
<p><span class="math inline">\(\texttt{verbatim}\)</span> 宏包优化了
<span class="math inline">\(\texttt{verbatim}\)</span>
环境的内部命令，并提供了 <code>\verbatiminput</code>
命令用来直接读入文件生成代码环境。 <span
class="math inline">\(\texttt{fancyvrb}\)</span> 宏包提供了可定制格式的
<span class="math inline">\(\texttt{Verbatim}\)</span> 环境；<span
class="math inline">\(\texttt{listings}\)</span> 和 <span
class="math inline">\(\texttt{minted}\)</span>
宏包更进一步，可生成关键字高亮的代码环境，支持各种程序设计语言的语法和关键字。详情请参考各自的帮助文档。</p>
<hr />
<h2 id="表格">表格</h2>
<p>排版表格最基本的 <span
class="math inline">\(\texttt{tabular}\)</span> 环境用法为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;[⟨align⟩]&#123;⟨column-spec⟩&#125;</span><br><span class="line">⟨item1⟩ <span class="built_in">&amp;</span> ⟨item2⟩ <span class="built_in">&amp;</span> … <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">⟨item1⟩ <span class="built_in">&amp;</span> ⟨item2⟩ <span class="built_in">&amp;</span> … <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;column-spec&gt;</code>
是列格式标记，在接下来的内容将仔细介绍；<code>&amp;</code>
用来分隔单元格；<code>\\</code> 用来换行；<code>\hline</code>
用来在行与行之间绘制横线。</p>
<p>直接使用 <span class="math inline">\(\texttt{tabular}\)</span>
环境的话，会 <strong>和周围的文字混排</strong>。此时可用一个可选参数
<code>&lt;align&gt;</code> 控制垂直对齐：<span
class="math inline">\(\verb|t|\)</span> 和 <span
class="math inline">\(\verb|b|\)</span>
分别表示按表格顶部、底部对齐，其他参数或省略不写（默认）表示居中对齐。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|&#125;</span><br><span class="line">  center-<span class="keyword">\\</span> aligned <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;,</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;[t]&#123;|c|&#125;</span><br><span class="line">  top-<span class="keyword">\\</span> aligned <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;,</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;[b]&#123;|c|&#125;</span><br><span class="line">  bottom-<span class="keyword">\\</span> aligned<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125; tabulars.</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250114222501332.png" alt="image-20250114222501332" style="zoom:67%;" /></p>
<p>但是通常情况下 <span class="math inline">\(\texttt{tabular}\)</span>
环境很少与文字直接混排，而是会放在 <span
class="math inline">\(\texttt{table}\)</span> 浮动体环境中，并用
<code>\caption</code> 命令加标题。</p>
<h3 id="列格式">列格式</h3>
<p><span class="math inline">\(\texttt{tabular}\)</span> 环境使用
<code>&lt;column-spec&gt;</code>参数指定表格的列数以及每列的格式。基本的列格式见下表。</p>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>列格式</strong></th>
<th style="text-align: left;"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span class="math inline">\(\texttt{l/c/r
}\)</span></td>
<td style="text-align: left;">单元格内容左对齐/居中/右对齐，不折行</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{p\{&lt;width&gt;\}}\)</span></td>
<td style="text-align: left;">单元格宽度固定为
<code>&lt;width&gt;</code>，可自动折行</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\mid\)</span></td>
<td style="text-align: left;">绘制竖线</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{@\{&lt;string&gt;\}}\)</span></td>
<td style="text-align: left;">自定义内容
<code>&lt;string&gt;</code></td>
</tr>
</tbody>
</table>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;lcr|p&#123;6em&#125;&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  left <span class="built_in">&amp;</span> center <span class="built_in">&amp;</span> right</span><br><span class="line">       <span class="built_in">&amp;</span> par box with fixed width<span class="keyword">\\</span></span><br><span class="line">  L    <span class="built_in">&amp;</span> C      <span class="built_in">&amp;</span> R     <span class="built_in">&amp;</span> P <span class="keyword">\\</span></span><br><span class="line"> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115130809432.png" alt="image-20250115130809432" style="zoom:67%;" /></p>
<p>表格中每行的单元格数目不能多于列格式里 <span
class="math inline">\(\texttt{l/c/r/p}\)</span>
的总数（可以少于这个总数），否则出错。</p>
<p><span class="math inline">\(\texttt{@}\)</span>
格式可在单元格前后插入任意的文本，但同时它也消除了单元格前后额外添加的间距。<span
class="math inline">\(\texttt{@}\)</span>
格式可以适当使用以充当“竖线”。特别地，<span
class="math inline">\(\texttt{@\{\}}\)</span>
可直接用来消除单元格前后的间距：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;@&#123;&#125; r@&#123;:&#125;lr @&#123;&#125;&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  1  <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> one <span class="keyword">\\</span></span><br><span class="line">  11 <span class="built_in">&amp;</span> 3 <span class="built_in">&amp;</span> eleven <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115131115056.png" alt="image-20250115131115056" style="zoom:67%;" /></p>
<p>另外还提供了简便的将格式参数重复的写法
<code>*&#123;&lt;n&gt;&#125;&#123;&lt;columnspec&gt;&#125;</code>，比如以下两种写法是等效的：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|c|c|p&#123;4em&#125;|p&#123;4em&#125;|&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|*&#123;5&#125;&#123;c|&#125;*&#123;2&#125;&#123;p&#123;4em&#125;|&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>有时需要为整列修饰格式，比如整列改变为粗体，如果每个单元格都加上
<code>\bfseries</code> 命令会比较麻烦。<code>array</code>
宏包提供了辅助格式 <span class="math inline">\(\texttt&gt;\)</span> 和
<span
class="math inline">\(\texttt&lt;\)</span>，用于给列格式前后加上修饰命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;array&#125;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;&gt;&#123;<span class="keyword">\itshape</span>&#125;r&lt;&#123;*&#125;l&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  italic <span class="built_in">&amp;</span> normal <span class="keyword">\\</span></span><br><span class="line">  column <span class="built_in">&amp;</span> column <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115131903387.png" alt="image-20250115131903387" style="zoom:67%;" /></p>
<p>辅助格式甚至支持插入 <code>\centering</code> 等命令改变 <span
class="math inline">\(\texttt{p}\)</span>
列格式的对齐方式，一般还要加额外的命令 <code>\arraybackslash</code>
以免出错。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;array&#125;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;<span class="comment">%</span></span><br><span class="line">&#123;&gt;&#123;<span class="keyword">\centering</span><span class="keyword">\arraybackslash</span>&#125;p&#123;9em&#125;&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  Some center-aligned long text. <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115132303588.png" alt="image-20250115132303588" style="zoom:67%;" /></p>
<p><code>array</code> 宏包还提供了类似 <span
class="math inline">\(\texttt{p}\)</span> 格式的 <span
class="math inline">\(\texttt{m}\)</span> 格式和 <span
class="math inline">\(\texttt{b}\)</span>
格式，三者分别在垂直方向上靠顶端对齐、居中以及底端对齐。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;array&#125;</span></span><br><span class="line"><span class="keyword">\newcommand</span><span class="keyword">\txt</span>&#123;a b c d e f g h i&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;cp&#123;2em&#125;m&#123;2em&#125;b&#123;2em&#125;&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  pos <span class="built_in">&amp;</span> <span class="keyword">\txt</span> <span class="built_in">&amp;</span> <span class="keyword">\txt</span> <span class="built_in">&amp;</span> <span class="keyword">\txt</span> <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115132526382.png" alt="image-20250115132526382" style="zoom:67%;" /></p>
<h3 id="列宽">列宽</h3>
<p>在控制列宽方面，<span class="math inline">\(\LaTeX{}\)</span>
表格有着明显的不足：<span class="math inline">\(\texttt{l/c/r}\)</span>
格式的列宽是由文字内容的自然宽度决定的，而 <span
class="math inline">\(\texttt{p}\)</span>
格式给定了列宽却不好控制对齐（可用 <code>array</code>
宏包的辅助格式），更何况列与列之间通常还有间距，所以直接生成给定总宽度的表格并不容易。</p>
<p><span class="math inline">\(\LaTeX{}\)</span> 本身提供了 <span
class="math inline">\(\texttt{tabular*}\)</span>
环境用来排版定宽表格，但是不太方便使用，比如要用到 <span
class="math inline">\(\texttt{@}\)</span>
格式插入额外命令，令单元格之间的间距为
<code>\fill</code>，但即使这样仍然有瑕疵：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular*&#125;&#123;14em&#125;<span class="comment">%</span></span><br><span class="line">&#123;@&#123;<span class="keyword">\extracolsep</span>&#123;<span class="keyword">\fill</span>&#125;&#125;|c|c|c|c|&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  A <span class="built_in">&amp;</span> B <span class="built_in">&amp;</span> C <span class="built_in">&amp;</span> D <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">  a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="built_in">&amp;</span> d <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular*&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115132953911.png" alt="image-20250115132953911" style="zoom:67%;" /></p>
<p><code>tabularx</code> 宏包为我们提供了方便的解决方案。它引入了一个
<span class="math inline">\(\texttt{X}\)</span> 列格式，类似 <span
class="math inline">\(\texttt{p}\)</span>
列格式，不过会根据表格宽度自动计算列宽，多个 <span
class="math inline">\(\texttt{X}\)</span> 列格式平均分配列宽。 <span
class="math inline">\(\texttt{X}\)</span> 列格式也可以用
<code>array</code> 里的辅助格式修饰对齐方式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;array,tabularx&#125;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabularx&#125;&#123;14em&#125;<span class="comment">%</span></span><br><span class="line">&#123;|*&#123;4&#125;&#123;&gt;&#123;<span class="keyword">\centering</span><span class="keyword">\arraybackslash</span>&#125;X|&#125;&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  A <span class="built_in">&amp;</span> B <span class="built_in">&amp;</span> C <span class="built_in">&amp;</span> D <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">  a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="built_in">&amp;</span> d <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabularx&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115133221441.png" alt="image-20250115133221441" style="zoom:67%;" /></p>
<h3 id="横线">横线</h3>
<p>在之前的例子见过许多次绘制表格线的 <code>\hline</code> 命令。另外
<code>\cline&#123;&lt;i&gt;-&lt;j&gt;&#125;</code>
用来绘制跨越部分单元格的横线：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  4 <span class="built_in">&amp;</span> 9 <span class="built_in">&amp;</span> 2 <span class="keyword">\\</span> </span><br><span class="line">  <span class="keyword">\cline</span>&#123;2-3&#125;</span><br><span class="line">  3 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 7 <span class="keyword">\\</span> </span><br><span class="line">  <span class="keyword">\cline</span>&#123;1-1&#125;</span><br><span class="line">  8 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span> </span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115133628644.png"
alt="image-20250115133628644" />
<figcaption aria-hidden="true">image-20250115133628644</figcaption>
</figure>
<p>在科技论文排版中广泛应用的表格形式是三线表，形式干净简明。三线表由
<code>booktabs</code> 宏包支持，它提供了
<code>\toprule</code>、<code>\midrule</code> 和 <code>\bottomrule</code>
命令用以排版三线表的三条线，以及和 <code>\cline</code> 对应的
<code>\cmidrule</code>。除此之外，最好不要用其它横线以及竖线：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;booktabs&#125;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;cccc&#125;</span><br><span class="line">  <span class="keyword">\toprule</span></span><br><span class="line">   <span class="built_in">&amp;</span> <span class="keyword">\multicolumn</span>&#123;3&#125;&#123;c&#125;&#123;Numbers&#125; <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\cmidrule</span>&#123;2-4&#125;</span><br><span class="line">           <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\midrule</span></span><br><span class="line">  Alphabet <span class="built_in">&amp;</span> A <span class="built_in">&amp;</span> B <span class="built_in">&amp;</span> C <span class="keyword">\\</span></span><br><span class="line">  Roman    <span class="built_in">&amp;</span> I <span class="built_in">&amp;</span> II<span class="built_in">&amp;</span> III <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\bottomrule</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115140704162.png" alt="image-20250115140704162" style="zoom:67%;" /></p>
<h3 id="合并单元格">合并单元格</h3>
<p>横向合并单元格由 <code>\multicolumn</code> 命令实现：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\multicolumn</span>&#123;⟨n⟩&#125;&#123;⟨column-spec⟩&#125;&#123;⟨item⟩&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;n&gt;</code>
为要合并的列数，<code>&lt;column-spec&gt;</code>
为合并单元格后的列格式，只允许出现一个 <span
class="math inline">\(\texttt{l/c/r}\)</span> 或 <span
class="math inline">\(\texttt{p}\)</span>
格式。如果合并前的单元格前后带表格线 <span
class="math inline">\(\texttt|\)</span>，合并后的列格式也要带 <span
class="math inline">\(\texttt|\)</span> 以使得表格的竖线一致。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> Center <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">  <span class="keyword">\multicolumn</span>&#123;2&#125;&#123;|c|&#125;&#123;3&#125; <span class="built_in">&amp;</span></span><br><span class="line">  <span class="keyword">\multicolumn</span>&#123;1&#125;&#123;r|&#125;&#123;Right&#125; <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">  4 <span class="built_in">&amp;</span> <span class="keyword">\multicolumn</span>&#123;2&#125;&#123;c|&#125;&#123;C&#125; <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115142430321.png" alt="image-20250115142430321" style="zoom:67%;" /></p>
<p><strong>纵向合并单元格</strong> 需要用到 <code>multirow</code>
宏包提供的 <code>\multirow</code> 命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\multirow</span>&#123;⟨n⟩&#125;&#123;⟨width⟩&#125;&#123;⟨item⟩&#125;</span><br></pre></td></tr></table></figure>
<p><width> 为合并后单元格的宽度，可以填 <span
class="math inline">\(\texttt{*}\)</span> 以使用自然宽度。</p>
<p>我们看一个结合 <code>\cline</code>、<code>\multicolumn</code> 和
<code>\multirow</code> 命令的例子：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;multirow&#125;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;ccc&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  <span class="keyword">\multirow</span>&#123;2&#125;&#123;*&#125;&#123;Item&#125; <span class="built_in">&amp;</span></span><br><span class="line">    <span class="keyword">\multicolumn</span>&#123;2&#125;&#123;c&#125;&#123;Value&#125; <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\cline</span>&#123;2-3&#125;</span><br><span class="line">    <span class="built_in">&amp;</span> First <span class="built_in">&amp;</span> Second <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">  A <span class="built_in">&amp;</span> 1     <span class="built_in">&amp;</span> 2 <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115142135335.png" alt="image-20250115142135335" style="zoom:67%;" /></p>
<h3 id="嵌套表格">嵌套表格</h3>
<p>在以下的例子中，注意要用 <code>\multicolumn</code> 命令配合 <span
class="math inline">\(\texttt{@\{\}}\)</span>
格式把单元格的额外边距去掉，使得嵌套的表格线能和外层的表格线正确相连：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line"> <span class="keyword">\hline</span></span><br><span class="line"> a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"> a <span class="built_in">&amp;</span> <span class="keyword">\multicolumn</span>&#123;1&#125;&#123;@&#123;&#125;c@&#123;&#125;|&#125;</span><br><span class="line"> &#123;<span class="keyword">\begin</span>&#123;tabular&#125;&#123;c|c&#125;</span><br><span class="line">   e <span class="built_in">&amp;</span> f <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">   e <span class="built_in">&amp;</span> f <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\end</span>&#123;tabular&#125;&#125;</span><br><span class="line">       <span class="built_in">&amp;</span> c <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"> a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115142824913.png" alt="image-20250115142824913" style="zoom:67%;" /></p>
<p>如果不需要为“拆分的单元格”画线，并且只在垂直方向“拆分”的话，<code>makecell</code>
宏包提供的 <code>\makecell</code> 命令是一个简单的解决方案：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;makecell&#125;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|&#125;</span><br><span class="line"> <span class="keyword">\hline</span></span><br><span class="line"> a <span class="built_in">&amp;</span> <span class="keyword">\makecell</span>&#123;d1 <span class="keyword">\\</span> d2&#125; <span class="keyword">\\</span></span><br><span class="line"> <span class="keyword">\hline</span></span><br><span class="line"> b <span class="built_in">&amp;</span> c <span class="keyword">\\</span></span><br><span class="line"> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115143114195.png" alt="image-20250115143114195" style="zoom:67%;" /></p>
<h3 id="行距控制">行距控制</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
生成的表格看起来通常比较紧凑。修改参数 <code>\arraystretch</code>
可以得到行距更加宽松的表格。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\arraystretch</span>&#123;1.8&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  Really loose <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">  tabular rows.<span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;example&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115143416039.png" alt="image-20250115143416039" style="zoom:67%;" /></p>
<p>另一种增加间距的办法是给换行命令 <code>\\</code>
添加可选参数，在这一行下面加额外的间距，适合用于在行间不加横线的表格：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;c&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  Head lines <span class="keyword">\\</span>[6pt]</span><br><span class="line">  tabular lines <span class="keyword">\\</span></span><br><span class="line">  tabular lines <span class="keyword">\\</span> </span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115143537544.png" alt="image-20250115143537544" style="zoom:67%;" /></p>
<p>但是这种换行方式的存在导致了一个缺陷——从第二行开始，表格的首个单元格不能直接使用中括号
<span class="math inline">\(\texttt{[]}\)</span>，否则 <code>\\</code>
往往会将下一行的中括号当作自己的可选参数，因而出错。如果要使用中括号，应当放在花括号
<code>&#123;&#125;</code> 里面。或者也可以选择将换行命令写成 <span
class="math inline">\(\texttt{\\\\[0pt]}\)</span>。</p>
<hr />
<h2 id="图片">图片</h2>
<p><span class="math inline">\(\LaTeX{}\)</span>
本身不支持插图功能，需要由 <code>graphicx</code> 宏包辅助支持。</p>
<p>使用 <span class="math inline">\(\texttt{latex + dvipdfmx}\)</span>
编译命令时，调用 <code>graphicx</code> 宏包时要指定 <span
class="math inline">\(\texttt{dvipdfmx}\)</span> 选项；而使用 <span
class="math inline">\(\texttt{pdflatex}\)</span> 或 <span
class="math inline">\(\texttt{xelatex}\)</span> 命令编译时不需要。</p>
<p>不同编译命令支持的图片格式种类各异，见下表。这个表格也能解答诸如“为什么
<span class="math inline">\(\texttt{.eps}\)</span> 格式图片在 <span
class="math inline">\(\texttt{pdflatex}\)</span>
编译命令下出错”之类的问题。本表格也再一次说明，使用 <span
class="math inline">\(\texttt{xelatex}\)</span> 命令是最推荐的方式。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115144839982.png" alt="image-20250115144839982" style="zoom:67%;" /></p>
<p>在调用了 <code>graphicx</code> 宏包以后，就可以使用
<code>\includegraphics</code> 命令加载图片了：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\includegraphics</span>[⟨options⟩]&#123;⟨filename⟩&#125;</span><br></pre></td></tr></table></figure>
<p>其中 &lt;filename&gt;
为图片文件名，文件名可能需要用相对路径或绝对路径表示。图片文件的扩展名一般可不写。另外一定要注意，<strong>文件名里既不要有空格也不要有多余的英文点号</strong>，否则宏包在解析文件名的过程中会出错。</p>
<p>另外 <code>graphicx</code> 宏包还提供了 <code>graphicspath</code>
命令，用于声明一个或多个图片文件存放的目录，使用这些目录里的图片时可不用写路径：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 假设主要的图片放在 figures 子目录下，标志放在 logo 子目录下</span></span><br><span class="line"><span class="keyword">\graphicspath</span>&#123;&#123;figures/&#125;&#123;logo/&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>\includegraphics</code> 命令的可选参数
<code>&lt;options&gt;</code> 中可以使用
<code>&lt;key&gt;=&lt;value&gt;</code> 的形式，常用的参数如下：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115145631351.png" alt="image-20250115145631351" style="zoom:67%;" /></p>
<p><code>graphicx</code> 宏包也支持 <span
class="math inline">\(\texttt{draft}\)</span>/<span
class="math inline">\(\texttt{final}\)</span> 选项。当
<code>graphicx</code> 宏包或文档类指定 <span
class="math inline">\(\texttt{draft}\)</span>
选项时，图片将不会被实际插入，取而代之的是一个包含文件名的与原图片等大的方框。(<strong>加快编译过程</strong>)</p>
<hr />
<h2 id="盒子">盒子</h2>
<p>盒子是 <span class="math inline">\(\LaTeX{}\)</span>
排版的基础单元，虽然解释略有抽象：每一行是一个盒子，里面的文字从左到右依次排列；每一页也是一个盒子，各行文字从上到下依次排布……颇有一些活字印刷术的味道。</p>
<p>不管如何，<span class="math inline">\(\LaTeX{}\)</span>
提供了一些命令让我们手动生成一些有特定用途的盒子。</p>
<h3 id="水平盒子">水平盒子</h3>
<p>生成水平盒子的命令如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mbox</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">\makebox</span>[⟨width⟩][⟨align⟩]&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p><code>\mbox</code>
生成一个基本的水平盒子，内容只有一行，不允许分段（除非嵌套其它盒子，比如后文的垂直盒子）。外表看上去，<code>\mbox</code>
的内容与正常的文本无二，不过断行时文字不会从盒子里断开。</p>
<p><code>\makebox</code> 更进一步，可以加上可选参数用于控制盒子的宽度
<code>&lt;width&gt;</code>，以及内容的对齐方式
<code>&lt;align&gt;</code>，可选居中 <span
class="math inline">\(\texttt{c}\)</span>（默认值）、左对齐 <span
class="math inline">\(\texttt{l}\)</span>、右对齐 <span
class="math inline">\(\texttt{r}\)</span> 和分散对齐 <span
class="math inline">\(\texttt{s}\)</span>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">|<span class="keyword">\mbox</span>&#123;Test some words.&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em]&#123;Test some words.&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][l]&#123;Test some words.&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][r]&#123;Test some words.&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][s]&#123;Test some words.&#125;|</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115150814856.png" alt="image-20250115150814856" style="zoom:67%;" /></p>
<h3 id="带框的水平盒子">带框的水平盒子</h3>
<p><code>\fbox</code> 和 <code>\framebox</code>
让我们可以为水平盒子添加边框。使用的语法与 <code>\mbox</code> 和
<code>\makebox</code> 一模一样：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\fbox</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">\framebox</span>[⟨width⟩][⟨align⟩]&#123;…&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\fbox</span>&#123;Test some words.&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;Test some words.&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115151302157.png" alt="image-20250115151302157" style="zoom:67%;" /></p>
<p>可以通过 <code>\setlength</code> 命令调节边框的宽度
<code>\fboxrule</code> 和内边距 <code>\fboxsep</code>：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;Test box&#125;<span class="keyword">\\</span>[1ex]</span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\fboxrule</span>&#125;&#123;1.6pt&#125;</span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\fboxsep</span>&#125;&#123;1em&#125;</span><br><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;Test box&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115151733062.png" alt="image-20250115151733062" style="zoom:67%;" /></p>
<h3 id="垂直盒子">垂直盒子</h3>
<p>如果需要排版一个文字可以换行的盒子，<span
class="math inline">\(\LaTeX{}\)</span> 提供了两种方式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\parbox</span>[⟨align⟩][⟨height⟩][⟨inner-align⟩]&#123;⟨width⟩&#125;&#123;…&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;minipage&#125;[⟨align⟩][⟨height⟩][⟨inner-align⟩]&#123;⟨width⟩&#125;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">\end</span>&#123;minipage&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;align&gt;</code>
为盒子和周围文字的对齐情况；<code>&lt;height&gt;</code> 和
<code>&lt;inner-align&gt;</code>
设置盒子的高度和内容的对齐方式，<code>&lt;inner-align&gt;</code>
接受的参数是顶部 <span class="math inline">\(\texttt{t}\)</span>、底部
<span class="math inline">\(\texttt{b}\)</span>、居中 <span
class="math inline">\(\texttt{c}\)</span> 和分散对齐 <span
class="math inline">\(\texttt{s}\)</span>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">三字经：<span class="keyword">\parbox</span>[t]&#123;3em&#125;<span class="comment">%</span></span><br><span class="line">&#123;人之初 性本善 性相近 习相远&#125;</span><br><span class="line"><span class="keyword">\quad</span></span><br><span class="line">千字文：</span><br><span class="line"><span class="keyword">\begin</span>&#123;minipage&#125;[b][8ex][t]&#123;4em&#125;</span><br><span class="line">天地玄黄 宇宙洪荒</span><br><span class="line"><span class="keyword">\end</span>&#123;minipage&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115152828516.png" alt="image-20250115152828516" style="zoom:67%;" /></p>
<p>如果在 <code>minipage</code> 里使用 <code>\footnote</code>
命令，生成的脚注会出现在盒子底部，编号是独立的，并且使用小写字母编号。这也是
<span class="math inline">\(\texttt{minipage}\)</span>
环境之被称为“迷你页”（Mini-page）的原因。而在 <code>\parbox</code>
里无法正常使用 <code>\footnote</code> 命令，只能在盒子里使用
<code>\footnotemark</code>，在盒子外使用
<code>\footnotetext</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\fbox</span>&#123;<span class="keyword">\begin</span>&#123;minipage&#125;&#123;15em&#125;<span class="comment">%</span></span><br><span class="line">  这是一个垂直盒子的测试。</span><br><span class="line">  <span class="keyword">\footnote</span>&#123;脚注来自 minipage。&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;minipage&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115153544989.png" alt="image-20250115153544989" style="zoom:67%;" /></p>
<h3 id="标尺盒子">标尺盒子</h3>
<p><code>\rule</code>
命令用来画一个实心的矩形盒子，也可适当调整以用来画线（标尺）：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\rule</span>[⟨raise⟩]&#123;⟨width⟩&#125;&#123;⟨height⟩&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Black <span class="keyword">\rule</span>&#123;12pt&#125;&#123;4pt&#125; box.</span><br><span class="line"></span><br><span class="line">Upper <span class="keyword">\rule</span>[4pt]&#123;6pt&#125;&#123;8pt&#125; and</span><br><span class="line">lower <span class="keyword">\rule</span>[-4pt]&#123;6pt&#125;&#123;8pt&#125; box.</span><br><span class="line"></span><br><span class="line">A <span class="keyword">\rule</span>[-.4pt]&#123;3em&#125;&#123;.4pt&#125; line.</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115153851284.png" alt="image-20250115153851284" style="zoom:67%;" /></p>
<hr />
<h2 id="浮动体">浮动体</h2>
<p>内容丰富的文章或者书籍往往包含许多图片和表格等内容。这些内容的尺寸往往太大，导致分页困难。<span
class="math inline">\(\LaTeX{}\)</span>
为此引入了浮动体的机制，令大块的内容可以脱离上下文，放置在合适的位置。
<span class="math inline">\(\LaTeX{}\)</span> 预定义了两类浮动体环境
<span class="math inline">\(\texttt{figure}\)</span> 和 <span
class="math inline">\(\texttt{table}\)</span>。习惯上 <span
class="math inline">\(\texttt{figure}\)</span> 里放图片，<span
class="math inline">\(\texttt{table}\)</span>
里放表格，但并没有严格限制，可以在任何一个浮动体里放置文字、公式、表格、图片等等任意内容。</p>
<p>以 <span class="math inline">\(\texttt{table}\)</span>
环境的用法举例，<span class="math inline">\(\texttt{figure}\)</span>
同理：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[⟨placement⟩]</span><br><span class="line">…</span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;placement&gt;</code>
参数提供了一些符号用来表示浮动体允许排版的位置，如 <span
class="math inline">\(\texttt{hbp}\)</span>
允许浮动体排版在当前位置、底部或者单独成页。<span
class="math inline">\(\texttt{table}\)</span> 和 <span
class="math inline">\(\texttt{figure}\)</span> 浮动体的默认设置为 <span
class="math inline">\(\texttt{tbp}\)</span>。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115155105789.png" alt="image-20250115155105789" style="zoom:67%;" /></p>
<p>双栏排版环境下，<span class="math inline">\(\LaTeX{}\)</span> 提供了
<span class="math inline">\(\texttt{table*}\)</span> 和 <span
class="math inline">\(\texttt{figure*}\)</span> 环境用来排版
<strong>跨栏</strong> 的浮动体。用法与 <span
class="math inline">\(\texttt{table}\)</span> 和 <span
class="math inline">\(\texttt{figure}\)</span> 一样，不同之处为双栏的
<code>&lt;placement&gt;</code> 参数只能用 <span
class="math inline">\(\texttt{tp}\)</span> 两个位置。</p>
<p>浮动体的位置选取受到先后顺序的限制。如果某个浮动体由于参数限制、空间限制等原因在当前页无法放置，就要推迟到之后处理，并使得之后的同类浮动体一并推迟。<code>\clearpage</code>
命令会在另起一页之前，先将所有推迟处理的浮动体排版成页，此时 <span
class="math inline">\(\texttt{htbp}\)</span> 等位置限制被完全忽略。</p>
<p><code>float</code> 宏包为浮动体提供了 <span
class="math inline">\(\texttt{H}\)</span> 位置参数，不与 <span
class="math inline">\(\texttt{htbp}\)</span> 及 <span
class="math inline">\(\texttt{!}\)</span> 混用。使用 <span
class="math inline">\(\texttt{H}\)</span>
位置参数时，会取消浮动机制，将浮动体视为一般的盒子插入当前位置。这在一些特殊情况下很有用（如使用
<code>multicol</code>
宏包排版分栏内容的时候），但尺寸过大的浮动体可能使得分页比较困难。</p>
<h3 id="浮动体的标题">浮动体的标题</h3>
<p>图表等浮动体提供了 <code>\caption</code>
命令加标题，并且自动给浮动体编号，可以用带星号的命令
<code>\caption*</code>(需加载相关宏包，如 <code>caption</code>)
生成不带编号的标题，也可以使用带可选参数的形式
<code>\caption[...]&#123;...&#125;</code>，使得在目录里使用短标题。命令之后还可以紧跟
<code>\label</code> 命令标记交叉引用。</p>
<p><code>\caption</code> 生成的标题形如“Figure 1: …”或“Table 1:
…”可通过修改 <code>\figurename</code> 和 <code>\tablename</code>
的内容来修改标题的前缀。标题样式的定制功能由 <code>caption</code>
宏包提供，详见该宏包的帮助文档，在此不作赘述。</p>
<p><span class="math inline">\(\texttt{table}\)</span> 和 <span
class="math inline">\(\texttt{figure}\)</span>
两种浮动体分别有各自的生成目录的命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\listoftables</span></span><br><span class="line"><span class="keyword">\listoffigures</span></span><br></pre></td></tr></table></figure>
<p>它们类似 <code>\tableofcontents</code> 生成单独的章节。</p>
<h3 id="并排和子图表">并排和子图表</h3>
<p>我们时常有在一个浮动体里面放置多张图的用法。最简单的用法就是直接并排放置，也可以通过分段或者换行命令
<code>\\</code>
排版多行多列的图片。以下为示意代码，效果大致如图所示。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">  <span class="keyword">\centering</span></span><br><span class="line">  <span class="keyword">\includegraphics</span>[width=...]&#123;...&#125;</span><br><span class="line">  <span class="keyword">\qquad</span></span><br><span class="line">  <span class="keyword">\includegraphics</span>[width=...]&#123;...&#125; <span class="keyword">\\</span>[...pt]</span><br><span class="line">  <span class="keyword">\includegraphics</span>[width=...]&#123;...&#125;</span><br><span class="line">  <span class="keyword">\caption</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115160703778.png" alt="image-20250115160703778" style="zoom:67%;" /></p>
<p>由于标题是横跨一行的，用 <code>\caption</code>
命令为每个图片单独生成标题就需要借助前文提到的 <code>parbox</code> 或者
<span class="math inline">\(\texttt{minipage}\)</span>
环境，将标题限制在盒子内。效果见图所示。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">  <span class="keyword">\centering</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;minipage&#125;&#123;...&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=...]&#123;...&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">  <span class="keyword">\qquad</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;minipage&#125;&#123;...&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=...]&#123;...&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115161039696.png" alt="image-20250115161039696" style="zoom:67%;" /></p>
<p>当需要更进一步，给每个图片定义小标题时，就要用到
<code>subcaption</code>
宏包的功能了。这里仅举一例，效果见图。更详细的用法请参考
<code>subcaption</code> 宏包的帮助文档。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">  <span class="keyword">\centering</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;subfigure&#125;&#123;...&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=...]&#123;...&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">\end</span>&#123;subfigure&#125;</span><br><span class="line">  <span class="keyword">\qquad</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;subfigure&#125;&#123;...&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=...]&#123;...&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">\end</span>&#123;subfigure&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250115161220429.png" alt="image-20250115161220429" style="zoom:67%;" /></p>
<p><code>subcaption</code> 依赖上文提到过的 <code>caption</code>
宏包，因此也支持子图表标题样式的定制。并排子图表的功能也可通过
<code>subfig</code> 宏包的 <code>subfloat</code>
命令实现，具体请参考宏包文档。</p>
<hr />
<h2 id="参考博文">参考博文</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>出自《千字文》。<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之排版样式设定（五）</title>
    <url>/lang-latex/notes-lshort/05-layout-style/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>本章内容将一览如何修改 <span class="math inline">\(\LaTeX{}\)</span>
的排版样式，具体包括设置字体和字号，修饰和强调文字，调整段落格式和间距，设定页面参数和分栏，以及如何更改页眉页脚的样式和内容。</p>
<span id="more"></span>
<hr />
<h2 id="字体和字号">字体和字号</h2>
<p><span class="math inline">\(\LaTeX{}\)</span>
根据文档的逻辑结构（章节、脚注等）来选择默认的字体样式以及字号。需要更改字体样式或字号的话，可以使用
下表 中列出的命令。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250121100704497.png" alt="image-20250121100704497" style="zoom:67%;" /></p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250121101016109.png" alt="image-20250121101016109" style="zoom:67%;" /></p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250121101037202.png" alt="image-20250121101037202" style="zoom:67%;" /></p>
<h3 id="字体样式">字体样式</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
提供了两组修改字体的命令，见上表。其中诸如 <code>\bfseries</code>
形式的命令将会影响之后所有的字符，如果想要让它在局部生效，需要用花括号<strong>分组</strong>，也就是写成<code>\bfseries &lt;some text&gt;</code>
这样的形式；对应的 <code>\textbf</code>
形式带一个参数，只改变参数内部的字体，更为常用。</p>
<p>在公式中，直接使用<code>\textbf</code>
等命令不会起效，甚至报错。<span class="math inline">\(\LaTeX{}\)</span>
提供了修改数学字母样式的命令，如 <code>\mathbf</code> 等。</p>
<h3 id="字号">字号</h3>
<p>字号命令实际大小依赖于所使用的文档类及其选项。下表列出了这些命令在标准文档类中的绝对大小，单位为
pt。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250121102202770.png" alt="image-20250121102202770" style="zoom:67%;" /></p>
<p>使用字号命令的时候，通常也需要用花括号进行分组，如同
<code>\rmfamily</code> 那样。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250121102848593.png" alt="image-20250121102848593" style="zoom:67%;" /></p>
<p><span class="math inline">\(\LaTeX{}\)</span> 还提供了一个基础的命令
<code>\fontsize</code> 用于设定任意大小的字号：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\fontsize</span>&#123;&lt;size&gt;&#125;&#123;&lt;base line-skip&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>\fontsize</code> 用到两个参数，<code>&lt;size&gt;</code>
为字号，<code>&lt;base lineskip&gt;</code> 为基础行距。表 5.3
中的命令也都各自设定了与字号对应的基础行距，大小为字号的 1.2
倍。如果不是在导言区，<code>\fontsize</code> 的设定需要
<code>\selectfont</code> 命令才能立即生效，而表 5.2
的字号设定都是立即生效的。</p>
<h3 id="选用字体宏包">选用字体宏包</h3>
<p>下表
列出了较为常用的字体宏包，其中相当多的宏包还配置了数学字体，或者文本、数学字体兼而有之。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250121105449196.png" alt="image-20250121105449196" style="zoom:67%;" /></p>
<h3 id="字体编码">字体编码</h3>
<p>常见的正文字体编码有 <span
class="math inline">\(\texttt{OT1}\)</span> 和 <span
class="math inline">\(\texttt{T1}\)</span> 等。 默认使用兼容 plainTeX 的
<span class="math inline">\(\texttt{OT1}\)</span>
编码，使用起来有诸多限制：高德纳在设计 Computer Modern
字体时认为一些符号，如大于号、小于号等，原则上都应该在公式里出现，所以在正文字体里这些符号所在的位置被其它符号所占据（<span
class="math inline">\(\texttt{OT1}\)</span> 字体编码、<span
class="math inline">\(\texttt{rmfamily}\)</span> 和 <span
class="math inline">\(\texttt{sffamly}\)</span> 字体族下， <span
class="math inline">\(\texttt&lt;\)</span> 和 <span
class="math inline">\(\texttt&gt;\)</span> 排版 <span
class="math inline">\(!\)</span> 和 <span
class="math inline">\(¿\)</span>
两个倒立的标点符号，正常的大于号和小于号可用命令
<code>\textgreater</code> 和 <code>\textless</code> 输入；<span
class="math inline">\(\texttt{ttfamily}\)</span>
字体族下是正常的大于号和小于号）。扩展的 <span
class="math inline">\(\texttt{T1}\)</span> 字体编码则更加靠近 ASCII
文本编码，不会出现上述的大于号、小于号的问题。</p>
<p>切换字体编码要用到 <code>fontenc</code> 宏包：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[T1]&#123;fontenc&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 <span class="math inline">\(\texttt{xelatex}\)</span>
编译方式，并使用 <code>fontspec</code> 宏包调用 <span
class="math inline">\(\texttt{ttf}\)</span> 或 <span
class="math inline">\(\texttt{otf}\)</span> 格式字体，就不要再使用
<code>fontenc</code> 宏包。</p>
<h3 id="使用-fontspec-宏包更改字体">使用 <code>fontspec</code>
宏包更改字体</h3>
<p><span class="math inline">\(\texttt{xelatex}\)</span> 和 <span
class="math inline">\(\texttt{lualatex}\)</span>
编译命令能够支持直接调用系统和 <span
class="math inline">\(\TeX{}\)</span> 发行版中的 <span
class="math inline">\(\texttt{.ttf}\)</span> 或 <span
class="math inline">\(\texttt{.otf}\)</span> 格式字体(Linux 下的 TeXLive
为了令 XeTeX 使用 OpenType
字体，需要额外的配置）。相比于前文介绍的字体宏包，我们有了更多自由修改字体的余地。</p>
<p><span class="math inline">\(\texttt{xelatex}\)</span> 和 <span
class="math inline">\(\texttt{lualatex}\)</span>
命令下支持用户调用字体的宏包是
<code>fontspec</code>。宏包提供了几个设置全局字体的命令，设置
<code>\rmfamily</code> 等对应命令的默认字体：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setmainfont</span>&#123;&lt;font name&gt;&#125;[&lt;font features&gt;] <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\setsansfont</span>&#123;&lt;font name&gt;&#125;[&lt;font features&gt;] <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\setmonofont</span>&#123;&lt;font name&gt;&#125;[&lt;font features&gt;]</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;font name&gt;</code>
使用字体的文件名（带扩展名）或者字体的英文名称。<code>&lt;font features&gt;</code>
用来手动配置对应的粗体或斜体，比如为 Windows 下的无衬线字体 Arial
配置粗体和斜体（通常情况下自动检测并设置对应的粗体和斜体，无需手动指定）：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setsansfont</span>&#123;Arial&#125;[BoldFont=&#123;Arial Bold&#125;, ItalicFont=&#123;Arial Italic&#125;]</span><br></pre></td></tr></table></figure>
<p><code>&lt;font features&gt;</code>
还能配置字体本身的各种特性，这里不再赘述，感兴趣的读者请参考
<code>fontspec</code> 宏包的帮助文档。</p>
<p>需要注意的是，<code>fontspec</code> 宏包会覆盖数学字体设置。需要调用
上表 中列出的一些数学字体宏包时，应当在调用 <code>fontspec</code>
宏包时指定 <span class="math inline">\(\texttt{no-math}\)</span>
选项。<code>fontspec</code> 宏包可能被其它宏包或文档类（如
<code>ctex</code> 文档类）自动调用时，则在文档开头的
<code>documentclass</code> 命令里指定 $ $选项。</p>
<h3 id="在-ctex-宏包或文档类中更改中文字体">在 <code>ctex</code>
宏包或文档类中更改中文字体</h3>
<p>前文已经介绍过的 <code>ctex</code>
宏包或文档类提供了和<code>fontspec</code>
宏包非常类似的语法设置中文字体(使用 <span
class="math inline">\(\texttt{xelatex}\)</span>
编译时，这几个命令实际上由 <code>xeCJK</code> 宏包提供；使用 <span
class="math inline">\(\texttt{lualatex}\)</span> 编译时，则是由
<code>ctex</code> 宏包或文档类对 <code>luatexja</code>
宏包提供的类似命令进行额外封装)。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setCJKmainfont</span>&#123;&lt;font name&gt;&#125;[&lt;font features&gt;] <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\setCJKsansfont</span>&#123;&lt;font name&gt;&#125;[&lt;font features&gt;] <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\setCJKmonofont</span>&#123;&lt;font name&gt;&#125;[&lt;font features&gt;] </span><br></pre></td></tr></table></figure>
<p>由于中文字体少有对应的粗体或斜体，<code>&lt;font features&gt;</code>
里多用其他字体来配置，比如在 Windows 中设定基本字体为宋体，并设定对应的
<span class="math inline">\(\texttt{BoldFont}\)</span> 为黑体， <span
class="math inline">\(\texttt{ItalicFont}\)</span> 为楷体：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setCJKmainfont</span>&#123;SimSun&#125;[BoldFont=SimHei, ItalicFont=KaiTi]</span><br></pre></td></tr></table></figure>
<h3 id="使用-unicode-math-宏包配置-unicode-数学字体">使用
<code>unicode-math</code> 宏包配置 Unicode 数学字体</h3>
<p>Unicode 数学字体是一类 OpenType 字体，包含了 Unicode
字符集中的数学符号部分，字体中也设定了数学公式排版所需的一些参数。在
<span class="math inline">\(\texttt{xelatex}\)</span> 或者 <span
class="math inline">\(\texttt{lualatex}\)</span> 编译命令下，借助
<code>unicode-math</code> 宏包可以调用 Unicode
数学字体配置数学公式的字体风格。</p>
<p>在导言区使用<code>\usepackage&#123;unicode-math&#125;</code> 后，使用
<code>\setmathfont</code> 命令即可：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setmathfont</span>&#123;&lt;font name&gt;&#125;[&lt;font features&gt;] </span><br></pre></td></tr></table></figure>
<p>绝大多数时候，只需要给定字体名称 <code>&lt;font name&gt;</code>
即可。Unicode 数学字体相比于正文字体的选择余地不多。下表
给出了较为常用的 Unicode 数学字体。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125120819345.png" alt="image-20250125120819345" style="zoom:67%;" /></p>
<hr />
<h2 id="文字装饰和强调">文字装饰和强调</h2>
<p>强调文字的方法，或者是添加下划线等装饰物，或者是改变文字的字体。</p>
<p><span class="math inline">\(\LaTeX{}\)</span> 定义了
<code>\underline</code> 命令用来为文字添加下划线：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">An <span class="keyword">\underline</span>&#123;underlined&#125; text.</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
An \  \underline{underlined} \  text.
\]</span></p>
<p><code>\underline</code>
命令生成下划线的样式不够灵活，不同的单词可能生成高低各异的下划线，并且无法换行。<code>ulem</code>
宏包提供了更灵活的解决方案，它提供的 <code>\uline</code>
命令能够轻松生成自动换行的下划线：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125121752045.png" alt="image-20250125121752045" style="zoom:67%;" /></p>
<p>前一节介绍了 <code>\emph</code>
命令，它将文字变为斜体以示强调，而如果在已强调的文字中嵌套使用
<code>\emph</code> 命令，命令内则使用直立体文字：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Some <span class="keyword">\emph</span>&#123;emphasized words,</span><br><span class="line">including <span class="keyword">\emph</span>&#123;double-emphasized&#125;</span><br><span class="line">words&#125;, are shown here.</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125121906215.png" alt="image-20250125121906215" style="zoom:67%;" /></p>
<hr />
<h2 id="段落格式和间距">段落格式和间距</h2>
<h3 id="长度和长度变量">长度和长度变量</h3>
<p>在本节首先统一介绍长度和长度变量。长度的数值
<code>&lt;length&gt;</code> 由数字和单位组成。常用的单位见下表。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125124002209.png" alt="image-20250125124002209" style="zoom:67%;" /></p>
<p>在一些情况下还会用到可伸缩的“弹性长度”，如 <span
class="math inline">\(\texttt{12pt plus 2pt minus 3pt}\)</span>
表示基础长度为 <span
class="math inline">\(\texttt{12pt}\)</span>，可以伸展到 <span
class="math inline">\(\texttt{14pt}\)</span>，也可以收缩到 <span
class="math inline">\(\texttt{9pt}\)</span>。 也可只定义 <span
class="math inline">\(\texttt{plus}\)</span> 或者 <span
class="math inline">\(\texttt{minus}\)</span> 的部分，如 <span
class="math inline">\(\texttt{0pt plus 5pt}\)</span>。</p>
<p>长度的数值还可以用长度变量本身或其倍数来表达，如 <span
class="math inline">\(\texttt{2.5\\parindent}\)</span> 等。</p>
<p><span class="math inline">\(\LaTeX{}\)</span>
预定义了大量的长度变量用于控制版面格式。如页面宽度和高度、首行缩进、段落间距等。如果需要自定义长度变量，需使用如下命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newlength</span>&#123;<span class="keyword">\&lt;</span>length command&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>长度变量可以用 <code>\setlength</code> 赋值，或用
<code>\addtolength</code> 增加长度：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setlength</span>&#123;&lt;length command&gt;&#125;&#123;&lt;length&gt;&#125; </span><br><span class="line"><span class="keyword">\addtolength</span>&#123;&lt;length command&gt;&#125;&#123;&lt;length&gt;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行距">行距</h3>
<p>前文中提到过 <code>\fontsize</code>
命令可以为字号设定对应的行距，但很少那么用。更常用的办法是在导言区使用
<code>\linespread</code> 命令。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\linespread</span>&#123;&lt;factor&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;factor&gt;</code>
作用于基础行距而不是字号。缺省的基础行距是 1.2 倍字号大小（参考
<code>\fontsize</code> 命令），因此使用 <code>\linespread&#123;1.5&#125;</code>
意味着最终行距为 <strong>1.8 倍</strong>的字号大小。</p>
<p>如果不是在导言区全局修改，而想要<strong>局部地</strong>改变某个段落的行距，需要用
<code>\selectfont</code> 命令使 <code>\linespread</code>
命令的改动立即生效：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125130505191.png" alt="image-20250125130505191" style="zoom:67%;" /></p>
<p>字号的改变是即时生效的，而行距的改变直到文字<strong>分段</strong>时才生效。如果需要改变某一部分文字的行距，那么不能简单地将文字包含在花括号内。注意下面两个例子中
<code>\par</code> 命令的位置：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125130826941.png" alt="image-20250125130826941" style="zoom:67%;" /></p>
<h3 id="段落格式">段落格式</h3>
<p>以下长度分别为段落的左缩进、右缩进和首行缩进：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\leftskip</span>&#125;&#123;&lt;length&gt;&#125;  </span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\rightskip</span>&#125;&#123;&lt;length&gt;&#125;</span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\parindent</span>&#125;&#123;&lt;length&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>它们和设置行距的命令一样，在分段时生效。</p>
<p>控制段落缩进的命令为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\indent</span></span><br><span class="line"><span class="keyword">\noindent</span></span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(\LaTeX{}\)</span>
默认在段落开始时缩进，长度为用上述命令设置的
<code>parindent</code>。如果需要在某一段不缩进，可在段落开头使用<code>\noindent</code>
命令。相反地，<code>\indent</code>
命令强制开启一段首行缩进的段落。在段落开头使用多个 <code>\indent</code>
命令可以累加缩进量。</p>
<p><span class="math inline">\(\LaTeX{}\)</span> 还默认在
<code>\chapter</code>、<code>\section</code>
等章节标题命令之后的第一段不缩进(<code>ctex</code>
宏包和文档类默认按照中文习惯保持标题后第一段的首行缩进)。如果不习惯这种设定，可以调用
<code>indentfirst</code> 宏包，令第一段的首行缩进照常。</p>
<p>段落间的垂直间距为 <code>parskip</code>，如设置段落间距在 <span
class="math inline">\(\texttt{0.8ex}\)</span> 到 <span
class="math inline">\(\texttt{1.5ex}\)</span> 变动：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\parskip</span>&#125;&#123;1ex plus 0.5ex minus 0.2ex&#125;</span><br></pre></td></tr></table></figure>
<h3 id="水平间距">水平间距</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
默认为将单词之间的“空格”转化为水平间距。如果需要在文中手动插入额外的水平间距，可使用
<code>\hspace</code> 命令：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125143708280.png" alt="image-20250125143708280" style="zoom:67%;" /></p>
<p><code>\hspace</code>
命令生成的水平间距如果位于一行的开头或末尾，则有可能因为断行而被舍弃。可使用
<code>\hspace*</code> 命令代替<code>\hspace</code>
命令得到不会因断行而消失的水平间距。</p>
<p>命令 <code>\stretch&#123;&lt;n&gt;&#125;</code> 生成一个特殊弹性长度，参数
<code>&lt;n&gt;</code> 为权重。它的基础长度为
0pt，但可以无限延伸，如果同一行内出现多个
<code>\stretch&#123;&lt;n&gt;&#125;</code>，这一行的所有可用空间将按每个
<code>\stretch</code> 命令给定的权重 <code>&lt;n&gt;</code>
进行分配。</p>
<p>命令 <code>\fill</code> 相当于 <code>\stretch&#123;1&#125;</code>(注意不要用
<span class="math inline">\(\texttt{1.5\\fill}\)</span>
这样的用法，它生成的长度只有基础长度 0pt 而没有延伸部分)。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125160138870.png" alt="image-20250125160138870" style="zoom:67%;" /></p>
<p>在正文中用 <code>\hspace</code> 命令生成水平间距时，往往使用 <span
class="math inline">\(\texttt{em}\)</span>
作为单位，生成的间距随字号大小而变。在数学公式中见过 <code>\quad</code>
和 <code>\qquad</code> 命令，它们也可以用于文本中，分别相当于
<code>\hspace&#123;1em&#125;</code> 和 <code>\hspace&#123;2em&#125;</code>：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125160343041.png" alt="image-20250125160343041" style="zoom:67%;" /></p>
<h3 id="垂直间距">垂直间距</h3>
<p>在页面中，段落、章节标题、行间公式、列表、浮动体等元素之间的间距是
<span class="math inline">\(\LaTeX{}\)</span> 预设的。比如
<code>\parskip</code>，默认设置为 <span
class="math inline">\(\texttt{0pt plus 1pt}\)</span>。</p>
<p>如果我们想要人为地增加段落之间的垂直间距，可以在两个段落之间的位置使用
<code>\vspace</code> 命令：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125160614418.png" alt="image-20250125160614418" style="zoom:67%;" /></p>
<p><code>\vspace</code>
命令生成的垂直间距在一页的顶端或底端可能被“吞掉”，类似
<code>\hspace</code>
在一行的开头和末尾那样。对应地，<code>\vspace*</code>
命令产生不会因断页而消失的垂直间距。<code>\vspace</code> 也可用
<code>\stretch&#125;</code>设置无限延伸的垂直长度。</p>
<p>在段落内的两行之间增加垂直间距，一般通过给断行命令 <code>\\</code>
加可选参数，如 <code>\\[6pt]</code> 或 <code>\\*[6pt]</code>。
<code>\vspace</code> 也可以在段落内使用，区别在于 <code>\vspace</code>
只引入垂直间距而不断行：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125161039548.png" alt="image-20250125161039548" style="zoom:67%;" /></p>
<p>另外 <span class="math inline">\(\LaTeX{}\)</span>
还提供了<code>\bigskip</code>, <code>\medskip</code>,
<code>\smallskip</code> 来增加预定义长度的垂直间距。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125161301100.png" alt="image-20250125161301100" style="zoom:67%;" /></p>
<hr />
<h2 id="页面和分栏">页面和分栏</h2>
<p><span class="math inline">\(\LaTeX{}\)</span>
允许用户通过为文档类指定选项来控制纸张的大小，包括 <span
class="math inline">\(\texttt{a4paper}\)</span>、<span
class="math inline">\(\texttt{letterpaper}\)</span>等等，并配合字号设置了适合的页边距。</p>
<p>控制页边距的参数由 下图 里给出的各种长度变量控制。可以用
<code>\setlength</code>
命令修改这些长度变量，以达到调节页面尺寸和边距的作用；反之也可以利用这些长度变量来决定排版内容的尺寸，如在
<span class="math inline">\(\texttt{tabularx}\)</span> 环境或
<code>\includegraphics</code> 命令的参数里，设置图片或表格的宽度为
<code>0.8\textwidth</code>。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125162000736.png" alt="image-20250125162000736" style="zoom:67%;" /></p>
<p>页边距等比较直观的参数则必须间接设置。根据 上图
将各个方向的页边距计算公式给出（以奇数页为例）：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125162309991.png" alt="image-20250125162309991" style="zoom:67%;" /></p>
<p>如果需要设置合适的 <code>&lt;left-margin&gt;</code> 和
<code>&lt;right-margin&gt;</code>，就要通过上述方程组把<code>\oddsidemargin</code>
和 <code>\textwidth</code> 等参数解出来！</p>
<p>幸好 <code>geometry</code>
宏包提供了设置页边距等参数的简便方法，能够帮我们完成背后繁杂的计算。</p>
<h3 id="利用-geometry-宏包设置页面参数">利用 <code>geometry</code>
宏包设置页面参数</h3>
<p><code>geometry</code> 宏包的调用方式类似于 <code>graphicx</code>，在
<span class="math inline">\(\texttt{latex}\)</span> + <span
class="math inline">\(\texttt{dvipdfmx}\)</span> 命令下需要指定选项
<span class="math inline">\(\texttt{dvipdfm}\)</span> 或 <span
class="math inline">\(\texttt{dvipdfmx}\)</span>；<span
class="math inline">\(\texttt{pdflatex}\)</span> 和 <span
class="math inline">\(\texttt{xelatex}\)</span> 编译命令下不需要。</p>
<p>既可以调用 <code>geometry</code> 宏包，然后用其提供的
<code>\geometry</code>命令设置页面参数：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;geometry&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;&lt;eometry-settings&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以直接在宏包选项中设置：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[&lt;geometry-settings&gt;]&#123;geometry&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;geometry-settings&gt;</code> 多以
<code>&lt;key&gt;=&lt;value&gt;</code> 的形式组织。</p>
<p>比如，符合 Microsoft Word 习惯的页面设定是 A4 纸张，上下边距 1
英寸，左右边距 1.25
英寸，于是我们可以通过如下两种等效的方式之一设定页边距：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\geometry</span>&#123;a4paper,left=1.25in,right=1.25in,top=1in,bottom=1in&#125;</span><br><span class="line"><span class="comment">% or like this:</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;a4paper,hmargin=1.25in,vmargin=1in&#125;</span><br></pre></td></tr></table></figure>
<p>又比如，需要设定周围的边距一致为 1.25 英寸，可以用更简单的语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\geometry</span>&#123;margin=1.25in&#125;</span><br></pre></td></tr></table></figure>
<p>对于书籍等双面文档，习惯上奇数页右边、偶数页左边留出较大的页边距，而靠近书脊一侧的奇数页左边、偶数页右边页边距较小。可以这样设定：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\geometry</span>&#123;inner=1in,outer=1.25in&#125;</span><br></pre></td></tr></table></figure>
<p>需要指出的是，通过 <code>geometry</code> 宏包设置的纸张大小是输出 PDF
文件的真实大小，而在文档类选项中设置的参数实际上只影响输出区域。<code>geometry</code>
宏包还能够修改页眉页脚高度、边注宽度等参数，并且能比较好地处理各参数之间的依赖关系。更详细的用法不再赘述，感兴趣的用户可查阅其帮助文档。</p>
<h3 id="页面内容的垂直对齐">页面内容的垂直对齐</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
默认将页面内容在垂直方向分散对齐。对于有大量图表的文档，许多时候想要做到排版匀称的页面很困难，垂直分散对齐会造成某些页面的垂直间距过宽，还可能报大量的
<span class="math inline">\(\texttt{Underfull \\vbox}\)</span>
警告。<span class="math inline">\(\LaTeX{}\)</span>
还提供了另一种策略：将页面内容向顶部对齐，给底部留出高度不一的空白。</p>
<p>以下命令分别令页面在垂直方向向顶部对齐/分散对齐：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\raggedbottom</span></span><br><span class="line"><span class="keyword">\flushbottom</span></span><br></pre></td></tr></table></figure>
<h3 id="分栏">分栏</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
支持简单的单栏或双栏排版。标准文档类的全局选项 <span
class="math inline">\(\texttt{onecolumn}\)</span>、<span
class="math inline">\(\texttt{twocolumn}\)</span>
可控制全文分单栏或双栏排版。<span
class="math inline">\(\LaTeX{}\)</span>
也提供了切换单/双栏排版的命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\onecolumn</span></span><br><span class="line"><span class="keyword">\twocolumn</span>[&lt;one-column top material&gt;]</span><br></pre></td></tr></table></figure>
<p><code>\twocolumn</code>
支持带一个可选参数，用于排版双栏之上的一部分单栏内容。</p>
<p>切换单/双栏排版时总是会另起一页（<code>\clearpage</code>）。在双栏模式下使用
<code>\newpage</code> 会换栏而不是换页；<code>\clearpage</code>
则能够换页。</p>
<p>双栏排版时每一栏的宽度为
<code>\columnwidth</code>，它由<code>\textwidth</code> 减去
<code>\columnsep</code> 的差除以 2 得到。两栏之间还有一道竖线，宽度为
<code>\columnseprule</code>，默认为零，也就是看不到竖线。</p>
<p>一个比较好用的分栏解决方案是 <code>multicol</code>，它提供了简单的
<span class="math inline">\(\texttt{multicols}\)</span>
环境自动产生分栏，如以下环境将内容分为 3 栏：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;multicols&#125;&#123;3&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;multicols&#125;</span><br></pre></td></tr></table></figure>
<p><code>multicol</code>
宏包能够在一页之中切换单栏/多栏，也能处理跨页的分栏，且各栏的高度分布平衡。但代价是<strong>在
<span class="math inline">\(\texttt{multicols}\)</span>
环境中无法正常使用 <span class="math inline">\(\texttt{table}\)</span>
和 <span class="math inline">\(\texttt{figure}\)</span>
等浮动体环境</strong>，它会直接让浮动体丢失。<code>multicols</code>
环境中只能用跨栏的 <span class="math inline">\(\texttt{table*}\)</span>
和 <span class="math inline">\(\texttt{figure*}\)</span> 环境，或者用
<code>float</code> 宏包提供的 <span
class="math inline">\(\texttt{H}\)</span> 参数固定浮动体的位置。</p>
<hr />
<h2 id="页眉页脚">页眉页脚</h2>
<h3 id="基本的页眉页脚样式">基本的页眉页脚样式</h3>
<p><span class="math inline">\(\LaTeX{}\)</span> 中提供了命令
<code>\pagestyle</code> 来修改页眉页脚的样式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\pagestyle</span>&#123;&lt;page-style&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>命令 <code>\thispagestyle</code> 只影响当页的页眉页脚样式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\thispagestyle</span>&#123;&lt;page-style&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;page-style&gt;</code> 参数为样式的名称，在 <span
class="math inline">\(\LaTeX{}\)</span> 里预定义了四类样式，见
下表。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125170414339.png" alt="image-20250125170414339" style="zoom:67%;" /></p>
<p>其中 <span class="math inline">\(\texttt{headings}\)</span>
的情况较为复杂：</p>
<ul>
<li><span class="math inline">\(\texttt{article}\)</span> 文档类，<span
class="math inline">\(\texttt{twoside}\)</span> 选项:
偶数页为页码和节标题，奇数页为小节标题和页码；</li>
<li><span class="math inline">\(\texttt{article}\)</span>文档类，<span
class="math inline">\(\texttt{oneside}\)</span> 选项:
页眉为节标题和页码；</li>
<li><span class="math inline">\(\texttt{report}\)</span> 和 <span
class="math inline">\(\texttt{book}\)</span> 文档类，<span
class="math inline">\(\texttt{twoside}\)</span> 选项:
偶数页为页码和章标题，奇数页为节标题和页码；</li>
<li><span class="math inline">\(\texttt{report}\)</span> 和 <span
class="math inline">\(\texttt{book}\)</span> 文档类，<span
class="math inline">\(\texttt{oneside}\)</span> 选项:
页眉为章标题和页码。</li>
</ul>
<p><code>\pagenumbering</code>
命令令我们能够改变页眉页脚中的页码样式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\pagenumbering</span>&#123;&lt;style&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;style&gt;</code> 为页码样式，默认为 <span
class="math inline">\(\texttt{arabic}\)</span>（阿拉伯数字），还可修改为
<span
class="math inline">\(\texttt{roman}\)</span>（小写罗马数字）、<span
class="math inline">\(\texttt{Roman}\)</span>（大写罗马数字）等。注意使用
<code>\pagenumbering</code> 命令后会将页码重置为 1。<span
class="math inline">\(\texttt{book}\)</span> 文档类的
<code>\frontmatter</code> 和 <code>\mainmatter</code> 内部就使用了
<code>\pagenumbering</code> 命令切换页码样式。</p>
<h3 id="手动更改页眉页脚的内容">手动更改页眉页脚的内容</h3>
<p>对于 <span class="math inline">\(\texttt{headings}\)</span> 或者
<span class="math inline">\(\texttt{myheadings}\)</span> 样式，<span
class="math inline">\(\LaTeX{}\)</span>
允许用户使用命令手动修改页眉上面的内容，特别是因为使用了
<code>\chapter*</code> 等命令而无法自动生成页眉页脚的情况：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\markright</span>&#123;&lt;right-mark&gt;&#125;</span><br><span class="line"><span class="keyword">\markboth</span>&#123;&lt;left-mark&gt;&#125;&#123;&lt;right-mark&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>在双面排版、<span class="math inline">\(\texttt{headings}\)</span> 或
<span class="math inline">\(\texttt{myheadings}\)</span>
页眉页脚样式下，<code>&lt;left-mark&gt;</code> 和
<code>&lt;right-mark&gt;</code>
的内容分别预期出现在左页（偶数页）和右页（奇数页）。 事实上
<code>\chapter</code> 和 <code>\section</code> 等章节命令内部也使用
<code>\markboth</code> 或者 <code>\markright</code> 生成页眉。</p>
<p><span class="math inline">\(\LaTeX{}\)</span>
默认将页眉的内容都转为大写字母。如需要保持字母的大小写，可以尝试以下代码（但是这不能改变页眉的斜体样式<code>\slshape</code>，斜体定义在
<span class="math inline">\(\texttt{headings}\)</span>
样式里的。如不喜欢斜体，可在 <code>markboth</code> 等命令参数里先使用
<code>\normalfont</code>，再使用想要的字体样式命令，或直接尝试使用
<code>fancyhdr</code> 宏包)：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\chaptermark</span>[1]&#123;<span class="comment">%</span></span><br><span class="line">  <span class="keyword">\markboth</span>&#123;Chapter <span class="keyword">\thechapter</span><span class="keyword">\quad</span> <span class="params">#1</span>&#125;&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\sectionmark</span>[1]&#123;<span class="comment">%</span></span><br><span class="line">  <span class="keyword">\markright</span>&#123;<span class="keyword">\thesection</span><span class="keyword">\quad</span> <span class="params">#1</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>\thechapter</code>、<code>\thesection</code>
等命令为章节计数器的数值。注意以上代码适用于 <span
class="math inline">\(\texttt{report}\)</span> 和 <span
class="math inline">\(\texttt{book}\)</span> 文档类；对于 <span
class="math inline">\(\texttt{article}\)</span>
文档类，与两个页眉相关的命令分别为 <code>\sectionmark</code> 和
<code>\subsectionmark</code>。</p>
<h3 id="fancyhdr-宏包"><code>fancyhdr</code> 宏包</h3>
<p><code>fancyhdr</code>
宏包改善了页眉页脚样式的定义方式，允许将内容自由安置在页眉和页脚的左、中、右三个位置，还为页眉和页脚各加了一条横线。</p>
<p><code>fancyhdr</code> 自定义了样式名称 <span
class="math inline">\(\texttt{fancy}\)</span>。使用
<code>fancyhdr</code> 宏包定义页眉页脚之前，通常先用
<code>\pagestyle&#123;fancy&#125;</code> 调用这个样式。在
<code>fancyhdr</code>定义页眉页脚的命令为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\fancyhf</span>[&lt;position&gt;]&#123;...&#125;</span><br><span class="line"><span class="keyword">\fancyhead</span>[&lt;position&gt;]&#123;...&#125;</span><br><span class="line"><span class="keyword">\fancyfoot</span>[&lt;position&gt;]&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;position&gt;</code> 为 L（左）/ C（中）/ R（右）以及与
O（奇数页）/ E（偶数页）字母的组合。<code>\fancyhf</code>
用于同时定义页眉和页脚，习惯上使用 <code>\fancyhf&#123;&#125;</code>
来清空页眉页脚的设置。</p>
<p>下面的源代码 给出了 <code>fancyhdr</code>
基础用法的一个示例，效果为将章节标题放在和 headings
一致的位置，但使用加粗格式；页码都放在页脚正中；修改横线宽度，“去掉”页脚的横线。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250125174255995.png" alt="image-20250125174255995" style="zoom:67%;" /></p>
<p><code>fancyhdr</code> 还支持用 <code>\fancypagestyle</code>
为自定义的页眉页脚样式命名，或者重新定义已有的样式如 <span
class="math inline">\(\texttt{plain}\)</span> 等：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 自定义 myfancy 样式</span></span><br><span class="line"><span class="keyword">\fancypagestyle</span>&#123;myfancy&#125;&#123;<span class="comment">%</span></span><br><span class="line">  <span class="keyword">\fancyhf</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">\fancyhead</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">\fancyfoot</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">% 使用样式</span></span><br><span class="line"><span class="keyword">\pagestyle</span>&#123;myfancy&#125;</span><br></pre></td></tr></table></figure>
<p>更多用法请参考 <code>fancyhdr</code> 宏包的帮助文档。</p>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言之字符串操作</title>
    <url>/lang-c/c-string-operation/</url>
    <content><![CDATA[<p>C
语言提供了丰富的字符串处理相关的库函数，这些函数基本上，都声明在<strong>头文件string.h</strong>当中，所以使用它们需要包含这个头文件。这里只介绍几种最基本的和最常用的，以及自己实现这些函数的方式。</p>
<span id="more"></span>
<hr />
<h2 id="字符串长度strlen">字符串长度strlen</h2>
<h3 id="strlen">strlen</h3>
<p><strong>函数全名：</strong>string_length</p>
<p><strong>函数声明</strong>:
<code>size_t strlen (const char *s);</code></p>
<p><strong>函数作用：</strong>返回当前字符串的长度，也就是字符数组中空字符’\0’前面的字符数量。==<strong>不包括空字符’\0’!</strong>==</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">char</span> str3[<span class="number">5</span>] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">len = <span class="built_in">strlen</span>(<span class="string">&quot;abc&quot;</span>);    <span class="comment">/* len is now 3 */</span></span><br><span class="line">len = <span class="built_in">strlen</span>(<span class="string">&quot;&quot;</span>);       <span class="comment">/* len is now 0 */</span></span><br><span class="line">len = <span class="built_in">strlen</span>(str);      <span class="comment">/* len is now 4 */</span></span><br><span class="line">len = <span class="built_in">strlen</span>(str2);     <span class="comment">/* len is now 5 */</span></span><br><span class="line">len = <span class="built_in">strlen</span>(str3);     <span class="comment">/* len is now 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str4[<span class="number">4</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">len = <span class="built_in">strlen</span>(str4);     <span class="comment">// str4并不能表示一个字符串,该函数调用会引发未定义行为</span></span><br></pre></td></tr></table></figure>
<h3 id="手动实现my_strlen">手动实现my_strlen</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen1</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;		<span class="comment">// 遍历直到遇到空字符</span></span><br><span class="line">        len++;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组下标形式</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (str[len] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen3</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = str;	<span class="comment">// 用一个指针记录数组首元素</span></span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;		<span class="comment">// 惯用法: 遍历直到字符串的末尾，</span></span><br><span class="line">        str++;</span><br><span class="line">    &#125;   <span class="comment">// 循环结束时，str指针指向空字符，p指针指向数组首元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相当于空字符的下标减去首元素下标，结果就是字符串的长度</span></span><br><span class="line">    <span class="keyword">return</span> str - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="字符串复制strcpystrncpy">字符串复制strcpy，strncpy</h2>
<h3 id="strcpy">strcpy</h3>
<p><strong>函数全名：</strong> string_copy</p>
<p><strong>函数声明：</strong>
<code>char *strcpy(char *dest, const char *src);</code></p>
<p><strong>函数作用：</strong> 将 <strong>src</strong> 中存储的以空字符
‘\0’ 结束的字符串复制到 <strong>dest</strong>所指向的数组中。</p>
<p>也就是说，会从首字符开始逐个字符地从 src
复制字符，<strong>包括空字符在内</strong>，都会从dest首位置开始，复制到dest当中。</p>
<p>这个过程中，src数组是不会被修改的，所以它被const修饰。总之，该函数调用后，dest
将包含 src 的完整副本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数后，src不变</span></span><br><span class="line"><span class="comment">// dest数组就会变成&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27;, ....&#125;</span></span><br><span class="line"><span class="comment">// 其中前6个字符是字符串&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">strcpy</span>(dest, src);</span><br></pre></td></tr></table></figure>
<p><strong>函数返回值：</strong></p>
<p>该函数会返回指向目标数组 dest
的指针，一般来说，该函数的返回值没有什么意义，推荐忽略它。</p>
<p>但某些场景下，这个<strong>返回值允许strcpy
函数的调用，可以被嵌套使用或者用于更复杂的表达式中。</strong>比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// strcpy返回复制完成后指向 dest 数组的指针</span></span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> dest2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接利用printf、puts函数打印复制后的目标数组</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">strcpy</span>(dest, src));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更加复杂的函数调用</span></span><br><span class="line"><span class="comment">// 将src复制到dest，再将dest复制给dest2</span></span><br><span class="line"><span class="built_in">strcpy</span>(dest2, <span class="built_in">strcpy</span>(dest, src));</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol type="1">
<li>strcpy函数是不安全的，它并不会检查dest是否真的能够包含src数组。如果dest不够大，就会因数组越界而产生未定义行为。</li>
<li>为了安全起见，可以考虑使用strncpy函数解决这一问题，虽然它可能效率更低一些。</li>
</ol>
<h3 id="strncpy">strncpy</h3>
<p><strong>函数声明:</strong>
<code>char *strncpy(char *dest, const char *src, size_t n);</code></p>
<p><strong>函数作用：</strong></p>
<p>该函数会将最多n个字符从src中复制到dest数组中：</p>
<ol type="1">
<li>如果<code>n &lt; strlen(src) + 1</code>，也就是 n 小于源字符串的长度
+ 1时，此时strncpy函数就无法将整个源字符串数据都复制到 dest
中，并且此时复制完成的 dest
数组也不会以空字符结尾，无法表示一个字符串。不过好在，它不会引起越界问题，是安全的操作。</li>
<li>如果<code>n = strlen(src) + 1</code>，即 n 恰好是源字符串长度 +
1时，strncpy函数会将src完整复制到dest数组中，包括空字符。</li>
<li>如果<code>n &gt; strlen(src) + 1</code>，即 n 完全大于源字符串长度 +
1时，strncpy函数不仅会完整复制src字符串到dest中，还会将<strong>剩余 (n -
strlen(src) - 1) 个字符</strong>设置为空字符。</li>
</ol>
<p>strncpy函数一定会处理n个字符数据，如果n比较大，在复制完源数组后，它会顺道将
dest 数组中的元素置为空字符。</p>
<p>实际开发中，建议将<strong>n的值设定为
dest长度-1</strong>，并<strong>主动将dest的最后一个元素设置为空字符</strong>，这样总能安全地得到一个字符串。</p>
<p>也就是以下操作代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(dest, src, <span class="keyword">sizeof</span>(dest) - <span class="number">1</span>);</span><br><span class="line">dest[<span class="keyword">sizeof</span>(dest) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 这个复制是没有问题的</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, src, <span class="keyword">sizeof</span>(dest) - <span class="number">1</span>);</span><br><span class="line">dest[<span class="keyword">sizeof</span>(dest) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> dest2[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 这个复制虽然没有真的将&quot;hello&quot;都复制到dest2，但是一个安全的操作。最终dest2存放字符串&quot;hell&quot;</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest2, src, <span class="keyword">sizeof</span>(dest2) - <span class="number">1</span>);</span><br><span class="line">dest2[<span class="keyword">sizeof</span>(dest2) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这样的复制行为，若dest足够装下src，会导致dest剩余部分全都被设置为空字符。</p>
<h3 id="手动实现my_strcpymy_strncpy">手动实现my_strcpy、my_strncpy</h3>
<h4 id="my_strcpy">my_strcpy</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcpy1</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *tmp = dest;   <span class="comment">// dest数组的首元素指针要作为返回值,所以要临时保存一下</span></span><br><span class="line">    <span class="keyword">while</span> (*src) &#123;</span><br><span class="line">        *dest++ = *src++;</span><br><span class="line">    &#125;   <span class="comment">// 这个while循环没有复制空字符,所以需要手动来复制空字符</span></span><br><span class="line">    <span class="comment">// while循环结束时,src指针指向空字符, dest指针也指向对应的位置</span></span><br><span class="line">    *dest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化: 复制字符串的惯用法</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">my_strcpy2</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *tmp = dest;   <span class="comment">// dest数组的首元素指针要作为返回值,所以要临时保存一下</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        (*dest++ = *src++)</span></span><br><span class="line"><span class="comment">        主要作用: 返回*src的值</span></span><br><span class="line"><span class="comment">        副作用: src和dest都往后挪动指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        当主要作用返回src指针指向的元素, 且返回空字符结束这个while循环时</span></span><br><span class="line"><span class="comment">        =的副作用赋值并不会消失</span></span><br><span class="line"><span class="comment">        所以所以这种写法, 空字符也会连带被复制</span></span><br><span class="line"><span class="comment">        不需要考虑空字符的手动复制</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (*dest++ = *src++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="my_strncpy">my_strncpy</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">my_strncpy1</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *tmp = dest;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            复制src到dest，直到达到n个字符或遇到src的终结符</span></span><br><span class="line"><span class="comment">            while循环结束条件是:</span></span><br><span class="line"><span class="comment">            1.n足够长时(n &gt;= strlen(src)+1时)，会将src中直到空字符的数据复制到dest中，然后结束循环</span></span><br><span class="line"><span class="comment">            2.n不够长时(n &lt; strlen(src)+1时)，会将src中的前n个字符复制到dest中,然后结束循环</span></span><br><span class="line"><span class="comment">                此时dest数组不会存储空字符,它不能表示字符串,但不会有越界风险</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; (*dest++ = *src++)) &#123;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            当n &gt;= strlen(src) + 1时</span></span><br><span class="line"><span class="comment">            上面的while循环依靠(*dest++ = *src++)结束循环</span></span><br><span class="line"><span class="comment">            此时空字符被复制到dest中了</span></span><br><span class="line"><span class="comment">            但循环体没有执行循环就终止了, n--没有执行, 即复制了一个字符但n没有减少1</span></span><br><span class="line"><span class="comment">            所以下面要判断n &gt; 1 而不是n &gt; 0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不将n设置为无符号类型,而设置为int类型</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">my_strncpy2</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *tmp = dest;</span><br><span class="line">    <span class="comment">// 这个循环不用担心无符号0减1变为最大值的情况发生,可以放心使用</span></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; (*dest++ = *src++))</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// 由于n--正常执行,所以下面仍然可以判断n&gt;0</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *dest++ = <span class="number">0</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然为了追求原汁原味, 还是应该保留n的size_t类型</span></span><br><span class="line"><span class="comment">// 同时为了保证n&gt;0的正常使用,我们就需要保证n--正常执行</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">my_strncpy3</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *tmp = dest;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; (*dest = *src)) &#123; </span><br><span class="line">        dest++;</span><br><span class="line">        src++;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;<span class="comment">// while循环结束时，src指针指向指向空字符，dest指针也指向空字符</span></span><br><span class="line">    <span class="comment">// 虽然空字符已经复制结束后，但由于指针仍然指向空字符，下面的while循环就可以n&gt;0执行</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="字符串拼接strcatstrncat">字符串拼接strcat，strncat</h2>
<h3 id="strcat">strcat</h3>
<p><strong>函数全名：</strong>
string_concat，顾名思义，它用于将一个字符串拼接到另一个字符串的末尾。</p>
<p><strong>函数声明：</strong>
<code>char *strcat(char *dest, const char *src);</code></p>
<p><strong>函数作用：</strong> strcat 函数会将
src（源字符串）中存储的以空字符 ‘\0’ 结束的字符串拼接到
dest（目标字符串）的末尾。</p>
<p>具体来说：</p>
<p>会从 dest 字符串的空字符 ‘\0’
开始，替换这个空字符，然后<strong>将src中表示字符串的字符数据从开头到空字符</strong>，全部拼接到dest末尾。</p>
<p>这个过程中，src 字符串不会被修改，所以它被 const 修饰。</p>
<p><strong>总之，该函数调用后，dest 将包含 dest 和 src
的字符串拼接后的副本。</strong></p>
<p>简单的代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"><span class="comment">// 调用函数后，dest数组变为 &quot;Hello, World!\0&quot;，其余部分填充为空字符</span></span><br><span class="line"><span class="built_in">strcat</span>(dest, src);</span><br><span class="line"><span class="comment">// 输出拼接后的字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, dest); <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>函数返回值：</strong></p>
<p>该函数会返回指向目标数组 dest
的指针。一般来说这个返回值可以忽略，但有些场景中可以利用该返回值，对函数调用进行嵌套处理。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Everyone!&quot;</span>;</span><br><span class="line"><span class="type">char</span> src2[] = <span class="string">&quot; Have a nice day!&quot;</span>;</span><br><span class="line"><span class="comment">// 嵌套，将src和src2都拼接到dest上</span></span><br><span class="line"><span class="built_in">strcat</span>(<span class="built_in">strcat</span>(dest, src), src2);</span><br><span class="line"><span class="comment">// 输出最终的拼接字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, dest); <span class="comment">// 输出 &quot;Hello, Everyone! Have a nice day!&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol type="1">
<li><strong>src 和
dest两个参数都必须是字符串，即以空字符串结尾的字符数组，否则将引发未定义行为。</strong></li>
<li>strcat 函数与 strcpy 一样，不会检查 dest
数组是否能够容纳拼接后的字符串。如果 dest
不够大，就会产生未定义行为，这是潜在的安全隐患。</li>
<li>可以考虑使用更安全的strncat函数来实现字符串拼接，它允许指定最大拼接的字符数。</li>
</ol>
<hr />
<h3 id="strncat">strncat</h3>
<p><strong>函数声明：</strong>
<code>char *strncat(char *dest, const char *src, size_t n);</code></p>
<p><strong>函数作用：</strong></p>
<p>仍旧是找到dest字符串末尾的空字符，然后从该字符开始，将 src
的首个元素复制到 dest末尾，直到：</p>
<ul>
<li><p>已经复制了 n 个字符。</p></li>
<li><p>或者复制到达了<code>src</code>字符串的结尾，即遇到了<code>src</code>的空字符串。所以该函数<strong>不会把src中的空字符复制到dest中</strong>。</p></li>
</ul>
<p>最后，<code>strncat</code>函数一定会在dest的末尾添加一个空字符，以确保dest能够表示一个字符串。由于这一步操作的存在，该函数仍然具有越界访问的风险，需要程序员自己设定合理的n取值，以规避这种情况。</p>
<p>为了安全的使用此函数，基于函数的特点，我们就可以得出n的计算公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="keyword">sizeof</span>(dest) - <span class="built_in">strlen</span>(dest) - <span class="number">1</span>;    <span class="comment">// dest数组的长度 - 已存储字符串的长度 - 1(留给存空字符)</span></span><br></pre></td></tr></table></figure>
<p>表达式中<code>-1</code>是必要的，否则会导致数组越界情况发生。</p>
<p>给strncat函数传入这样的一个<code>n</code>参数，就能够保证一定安全的得到一个拼接后的结果字符串。</p>
<p>当然若dest容量不够大，拼接只会截取src的一部分字符数据。但安全是更重要的事情，这样的结果是我们可以接受的。</p>
<p>实际开发中，建议采取以下方式来调用此函数，避免dest空间不足导致溢出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">10</span>] = <span class="string">&quot;hello, &quot;</span>;</span><br><span class="line"><span class="comment">// 确保dest是一个数组类型，而不是一个指针类型才能这样操作</span></span><br><span class="line"><span class="type">int</span> n =  <span class="keyword">sizeof</span>(dest) - <span class="built_in">strlen</span>(dest) - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">strncat</span>(dest, src, n);</span><br></pre></td></tr></table></figure>
<p>dest最多再拼接<strong>(自身数组长度 - 字符串长度 -
1)</strong>个字符，最后留一个字节，strncat函数会自动拼接一个空字符表示字符串结束。</p>
<h3 id="手动实现my_strcatmy_strncat">手动实现my_strcat、my_strncat</h3>
<h4 id="my_strcat">my_strcat</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* temp = dest;</span><br><span class="line">    <span class="comment">// 找到dest的末尾，也就是让dest指针指向空字符</span></span><br><span class="line">    <span class="keyword">while</span> (*dest) &#123;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将src的字符串数据从开头到空字符都拷贝到dest的末尾</span></span><br><span class="line">    <span class="keyword">while</span> ((*dest++ = *src++))</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> temp;  <span class="comment">// 返回dest的起始地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="my_strncat">my_strncat</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">my_strncat1</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* temp = dest;</span><br><span class="line">    <span class="comment">// 找到dest的末尾，也就是让dest指针指向空字符</span></span><br><span class="line">    <span class="keyword">while</span> (*dest) &#123;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝最多n个字符从src到dest的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; (*src)) &#123;</span><br><span class="line">        *dest++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保dest以空字符结尾,所以一定会将末尾置为空字符。这里没有判断越界，所以strncpy函数实际仍存在越界风险</span></span><br><span class="line">    <span class="comment">// 这就要求我们传入一个正确合理的n以确保安全    </span></span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;  <span class="comment">// 返回dest的起始地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="字符串比较大小strcmp">字符串比较大小strcmp</h2>
<h3 id="strcmp">strcmp</h3>
<p><strong>函数全名：</strong>string_compare，用于比较两个字符串的大小。</p>
<p><strong>函数声明：</strong>
<code>int strcmp(const char *str1, const char *str2);</code></p>
<p><strong>函数作用：</strong>
<strong>strcmp函数按照字典顺序比较两个字符串的大小。</strong>当调用
strcmp函数时，它会逐个字符地比较两个字符串 str1 和 str2：</p>
<p>注意：</p>
<ol type="1">
<li><strong>这个函数不会修改任何一个字符串，所以两个参数都被 const
修饰。</strong></li>
<li>不同编译器和环境可能对strcmp函数返回值的表现有所不同。在某些环境中<strong>（比如VS）</strong>，出于简化的目的，可能会将返回值归一化为
-1、0 或 1。但是标准的 C 语言库中 strcmp
的返回值是根据实际字符的ASCII值差异来确定的，而不是简单的 -1、0 或
1。</li>
<li>要确保传入的两个参数数组都表示字符串，都以空字符结尾，否则可能会导致比较越界。</li>
<li>strcmp 是区分大小写的比较，如果需要进行不区分大小写的比较，可以使用
strcasecmp 函数。</li>
<li>由于strcmp是基于ASCII值进行比较的，它在处理非ASCII或多字节字符（如UTF-8编码的文本）时可能不会表现出预期的行为。</li>
</ol>
<h3 id="手动实现strcmp">手动实现strcmp</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp1</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; *str2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str1 != *str2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">        &#125;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个实现可读性更差，但简洁很多</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*s1 &amp;&amp; (*s1 == *s2)) &#123;</span><br><span class="line">        <span class="comment">// 移动两个指针，比较下一对字符</span></span><br><span class="line">        s1++;</span><br><span class="line">        s2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * while循环结束的条件是：</span></span><br><span class="line"><span class="comment">    * 1.s1指针指向了空字符</span></span><br><span class="line"><span class="comment">    * 2.或者s2指针指向了空字符</span></span><br><span class="line"><span class="comment">    * 3.或者s1和s2指针指向的字符不一致</span></span><br><span class="line"><span class="comment">    * 不管是哪一种情况，返回它们的编码值差就是结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="字符相关的库函数">字符相关的库函数</h2>
<p>在操作字符串的过程中，经常需要对单个字符做出判断，比如：</p>
<ol type="1">
<li>判断字符是大写字母还是小写</li>
<li>判断字符是不是数字</li>
<li>…</li>
</ol>
<p>C 标准函数库在<strong>头文件 <code>&lt;ctype.h&gt;</code></strong>
中定义了大量此类功能函数。比如：</p>
<p><strong>islower 和 isupper</strong> 函数是 C 标准库中声明在
&lt;ctype.h&gt;
头文件中的函数，它们用于检查给定的字符是否为小写字母或大写字母。</p>
<p>除此之外，<code>&lt;ctype.h&gt;</code>
头文件中还包括了以下类似的库函数：</p>
<ol type="1">
<li><code>isalpha(int c)</code>：检查传入的字符是否为字母（包括大写和小写）。</li>
<li><code>isdigit(int c)</code>：检查传入的字符是否为十进制数字（0到9）。</li>
<li><code>isalnum(int c)</code>：检查传入的字符是否为字母或数字。</li>
<li><code>isspace(int c)</code>：检查传入的字符是否为空白字符，比如空格、制表符、换行符等。</li>
<li><code>isblank(int c)</code>：检查传入的字符是否为空格或制表符。</li>
<li>…</li>
</ol>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之绘图功能（七）</title>
    <url>/lang-latex/notes-lshort/07-graphic/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>除了排版文字，<span class="math inline">\(\LaTeX{}\)</span>
也支持用代码表示图形。不同的扩展已极大丰富了 <span
class="math inline">\(\LaTeX{}\)</span> 的图形功能，<code>TikZ</code>
就是其中之一。本章将带你了解一些基本的绘图功能。</p>
<p>一些特殊的绘图，如交换图、树状图甚至分子式和电路图也能够通过代码绘制，有兴趣的读者可以查阅一些帮助文档，或者在互联网寻求帮助。</p>
<span id="more"></span>
<hr />
<h2 id="绘图语言简介">绘图语言简介</h2>
<p><span class="math inline">\(\LaTeX{}\)</span> 提供了原始的 <span
class="math inline">\(\texttt{picture}\)</span>
环境，能够绘制一些基本的图形如点、线、矩形、圆、B'ezier
曲线等等，不过受制于 <span class="math inline">\(\LaTeX{}\)</span>
本身，它的绘图功能极为有限，效果也不够美观。</p>
<p>当前较为流行的、用于 <span class="math inline">\(\LaTeX{}\)</span>
的绘图宏包/程序主要有：</p>
<ul>
<li><p><span class="math inline">\(\textrm{PSTricks}\)</span></p>
<p>以 <span class="math inline">\(\textrm{PostSciprt}\)</span>
语法为基础的绘图宏包，具有优秀的绘图能力。它对老式的 <span
class="math inline">\(\texttt{latex + dvips}\)</span>
编译命令支持最好，而现在的几种编译命令下使用起来都不够方便。</p></li>
<li><p><span class="math inline">\(\textrm{TikZ}\)</span> <span
class="math inline">\(\&amp;\)</span> <span
class="math inline">\(\textrm{pgf}\)</span></p>
<p>德国的 Till Tantau 教授在开发著名的 <span
class="math inline">\(\LaTeX{}\)</span> 幻灯片文档类 <span
class="math inline">\(\texttt{beamer}\)</span> 时一并开发了绘图宏包
<code>pgf</code>，目的是令其能够在 <span
class="math inline">\(\texttt{pdflatex}\)</span> 或 <span
class="math inline">\(\texttt{xelatex}\)</span>
等不同的编译命令下都能使用。<span
class="math inline">\(\textrm{TikZ}\)</span> 是在 <code>pgf</code>
基础上封装的一个宏包，采用了类似 <span
class="math inline">\(\texttt{METAPOST}\)</span>
的语法，提供了方便的绘图命令，绘图能力不输 <span
class="math inline">\(\textrm{PSTricks}\)</span> 。</p></li>
<li><p><span class="math inline">\(\textrm{METAPOST}\)</span> <span
class="math inline">\(\&amp;\)</span> <span
class="math inline">\(\textrm{Asymptote}\)</span></p>
<p><span class="math inline">\(\textrm{METAPOST}\)</span> 脱胎于高德纳为
<span class="math inline">\(\TeX{}\)</span> 配套开发的字体生成程序 <span
class="math inline">\(\textrm{METAFONT}\)</span>，具有优秀的绘图能力，并能够调用
<span class="math inline">\(\TeX{}\)</span>
引擎向图片中插入文字和公式。<span
class="math inline">\(\textrm{Asymptote}\)</span> 在 <span
class="math inline">\(\textrm{METAPOST}\)</span>
的基础上更进一步，具有一定的类似 C
语言的编程能力，支持三维图形的绘制。</p></li>
</ul>
<p>它们作为独立的程序，通常的用法是将代码写在单独的文件里，编译生成图片供
<span class="math inline">\(\LaTeX{}\)</span>
引用，也可以借助特殊的宏包在 <span
class="math inline">\(\LaTeX{}\)</span> 代码里直接使用。</p>
<hr />
<h2 id="textrmtikz-绘图语言"><span
class="math inline">\(\textrm{TikZ}\)</span> 绘图语言</h2>
<p>在导言区调用 <span class="math inline">\(\textrm{TikZ}\)</span>
宏包，就可以用以下命令和环境使用 <span
class="math inline">\(\textrm{TikZ}\)</span> 的绘图功能了（<span
class="math inline">\(\texttt{latex + dvipdfmx}\)</span> 编译方式要在
<span class="math inline">\(\textrm{TikZ}\)</span> 宏包之前调用
<code>graphicx</code> 宏包并指定 <span
class="math inline">\(\texttt{dvipdfmx}\)</span> 选项。）：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128171123106.png" alt="image-20250128171123106" style="zoom:67%;" /></p>
<p>前一种用法为 <code>\tikz</code>
带单条绘图命令，以分号结束，一般用于在文字之间插入简单的图形；
后两种用法较为常见，使用多条绘图命令，可以在 <span
class="math inline">\(\texttt{figure}\)</span> 等浮动体中使用。</p>
<h3 id="textrmtikz-坐标和路径"><span
class="math inline">\(\textrm{TikZ}\)</span> 坐标和路径</h3>
<p><span class="math inline">\(\textrm{TikZ}\)</span>
用直角坐标系或者极坐标系描述点的位置。</p>
<ul>
<li>直角坐标下，点的位置写作 <code>(&lt;x&gt;,&lt;y&gt;)</code>，坐标
<code>&lt;x&gt;</code> 和 <code>&lt;y&gt;</code> 可以用 <span
class="math inline">\(\LaTeX{}\)</span> 支持的任意单位表示， 缺省为
<span class="math inline">\(\texttt{cm}\)</span>；</li>
<li>极坐标下，点的位置写作 <span
class="math inline">\((\theta:r)\)</span>。<span
class="math inline">\(\theta\)</span> 为极角，单位是度。</li>
</ul>
<p>还可以为某个点命名：<code>\coordinate (A) at (&lt;coordinate&gt;)</code>，然后就可以使用
<span class="math inline">\(\texttt{(A)}\)</span> 作为点的位置了。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) -- (30:1);</span><br><span class="line"><span class="keyword">\draw</span> (1,0) -- (2,1);</span><br><span class="line"><span class="keyword">\coordinate</span> (S) at (0,1);</span><br><span class="line"><span class="keyword">\draw</span> (S) -- (1,1);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128175453993.png" alt="image-20250128175453993" style="zoom:67%;" /></p>
<p>坐标的表示形式还包括“垂足”形式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\coordinate</span> (S) at (2,2);</span><br><span class="line"><span class="keyword">\draw</span>[gray] (-1,2) -- (S);</span><br><span class="line"><span class="keyword">\draw</span>[gray] (2,-1) -- (S);</span><br><span class="line"><span class="keyword">\draw</span>[red] (0,0) -- (0,0 -| S);</span><br><span class="line"><span class="keyword">\draw</span>[blue] (0,0) -- (0,0 |- S);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128175922953.png" alt="image-20250128175922953" style="zoom:67%;" /></p>
<p><span class="math inline">\(\textrm{TikZ}\)</span>
最基本的路径为两点之间连线，如 <span class="math inline">\((x_1,y_1) --
(x_2,y_2)\)</span>，可以连用表示多个连线（折线）。连续使用连线时，可以使用
<span class="math inline">\(\texttt{cycle}\)</span>
令路径回到起点，生成闭合的路径。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) -- (1,1) -- (2,0) -- cycle;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128180317382.png" alt="image-20250128180317382" style="zoom:67%;" /></p>
<p><strong>多条路径</strong>可用于同一条画图命令中，以<strong>空格分隔</strong>：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) -- (0,1)</span><br><span class="line">      (1,0) -- (1,1) -- (2,0) -- cycle;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128180447083.png" alt="image-20250128180447083" style="zoom:67%;" /></p>
<p>其它常用的路径还包括：</p>
<ul>
<li><p>矩形、圆和椭圆：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) rectangle (1.5,1);</span><br><span class="line"><span class="keyword">\draw</span> (2.5,0.5) circle [radius=0.5];</span><br><span class="line"><span class="keyword">\draw</span> (4.5,0.5) ellipse</span><br><span class="line">    [x radius=1,y radius=0.5];</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128180748916.png" alt="image-20250128180748916" style="zoom:67%;" /></p></li>
<li><p>直角、圆弧、椭圆弧</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) |- (1,1);</span><br><span class="line"><span class="keyword">\draw</span> (1,0) -| (2,1);</span><br><span class="line"><span class="keyword">\draw</span> (4,0) arc (0:135:1);</span><br><span class="line"><span class="keyword">\draw</span> (6,0) arc (0:135:1 and 0.5);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128180937724.png" alt="image-20250128180937724" style="zoom:67%;" /></p></li>
<li><p>正弦、余弦曲线（1/4 周期）：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) sin (1,1);</span><br><span class="line"><span class="keyword">\draw</span> (0,1) sin (1,0);</span><br><span class="line"><span class="keyword">\draw</span> (2,1) cos (3,0);</span><br><span class="line"><span class="keyword">\draw</span> (2,0) cos (3,1);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128181343493.png" alt="image-20250128181343493" style="zoom:67%;" /></p></li>
<li><p>抛物线，用 <span class="math inline">\(\texttt{bend}\)</span>
控制顶点：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) parabola (1,2);</span><br><span class="line"><span class="keyword">\draw</span> (2,0) parabola</span><br><span class="line">      bend (2.25,-0.25) (3,2);</span><br><span class="line"><span class="keyword">\draw</span> (4,0) parabola</span><br><span class="line">      bend (4.75,2.25) (5,2);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128181601221.png" alt="image-20250128181601221" style="zoom:67%;" /></p></li>
<li><p>二次和三次 B'ezier 曲线，分别使用一个和两个控制点：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) .. controls</span><br><span class="line">  (2,1) and (3,1) .. (3,0);</span><br><span class="line"><span class="keyword">\draw</span> (4,0) .. controls</span><br><span class="line">  (5,1) .. (5,0);</span><br><span class="line"><span class="keyword">\draw</span>[help lines] (0,0)</span><br><span class="line">  -- (2,1) -- (3,1) -- (3,0)</span><br><span class="line">  (4,0) -- (5,1) -- (5,0);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128181655169.png" alt="image-20250128181655169" style="zoom:67%;" /></p></li>
<li><p>网格、函数图像，网格可用 <span
class="math inline">\(\texttt{step}\)</span>
参数控制网格大小，函数图像用 <span
class="math inline">\(\texttt{domain}\)</span> 参数控制定义域：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span>[help lines,step=0.5]</span><br><span class="line">     (-1,-1) grid (1,1);</span><br><span class="line"><span class="keyword">\draw</span>[-&gt;] (-1.5,0) -- (1.5,0);</span><br><span class="line"><span class="keyword">\draw</span>[-&gt;] (0,-1.5) -- (0,1.5);</span><br><span class="line"><span class="keyword">\draw</span>[domain=-1:1]</span><br><span class="line">     plot(<span class="keyword">\x</span>,&#123;<span class="keyword">\x</span>*<span class="keyword">\x</span>*2 -1&#125;);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128181832752.png" alt="image-20250128181832752" style="zoom:67%;" /></p></li>
</ul>
<h3 id="textrmtikz-绘图命令和参数"><span
class="math inline">\(\textrm{TikZ}\)</span> 绘图命令和参数</h3>
<p>除了 <code>\draw</code> 命令之外，<span
class="math inline">\(\textrm{TikZ}\)</span> 还提供了 <code>\fill</code>
命令用来填充图形，<code>\filldraw</code>
命令则同时填充和描边。除了矩形、圆等现成的闭合图形外，<code>\fill</code>
和 <code>\filldraw</code> 命令也能够填充人为构造的闭合路径。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128182617607.png" alt="image-20250128182617607" style="zoom:67%;" /></p>
<p>绘图参数可作为可选参数用在 <span
class="math inline">\(\texttt{tikzpicture}\)</span> 环境或
<code>\tikz</code>
命令时，参数会影响到所有具体的绘图命令；用在单个绘图命令
<code>\draw</code>、<code>\filldraw</code> 等时，只对这个命令起效。</p>
<p><span class="math inline">\(\textrm{TikZ}\)</span>
有数不清的绘图参数，这些参数令 <span
class="math inline">\(\textrm{TikZ}\)</span>
能够绘制丰富多彩的图像，同时也令其难以精通。以下示例常用的一些绘图参数。</p>
<ul>
<li><p><span
class="math inline">\(\texttt{color/draw/fill=&lt;color&gt;}\)</span> 为
<code>\draw</code> 或 <code>\fill</code> 等命令指定颜色。<span
class="math inline">\(\texttt{draw}\)</span> 和 <span
class="math inline">\(\texttt{fill}\)</span>
分别指定描边和填充的颜色，而 <span
class="math inline">\(\texttt{color}\)</span> 同时指定，也可以省略 <span
class="math inline">\(\texttt{color=}\)</span> 直接写颜色名称。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;[thick]</span><br><span class="line"><span class="keyword">\draw</span>[blue] (0,0) rectangle (1,1);</span><br><span class="line"><span class="keyword">\filldraw</span>[fill=yellow,draw=red]</span><br><span class="line">  (2,0.5) circle [radius=0.5];</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129092336978.png" alt="image-20250129092336978"  style="zoom:67%;" /></p></li>
<li><p><span
class="math inline">\(\texttt{thick=&lt;length&gt;/thin/semithick/...}\)</span>
指定线条的粗细。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span>[ultra thin] (0,0)--(0,2);</span><br><span class="line"><span class="keyword">\draw</span>[very thin] (0.5,0)--(0.5,2);</span><br><span class="line"><span class="keyword">\draw</span>[thin] (1,0)--(1,2);</span><br><span class="line"><span class="keyword">\draw</span>[semithick] (1.5,0)--(1.5,2);</span><br><span class="line"><span class="keyword">\draw</span>[thick] (2,0)--(2,2);</span><br><span class="line"><span class="keyword">\draw</span>[very thick] (2.5,0)--(2.5,2);</span><br><span class="line"><span class="keyword">\draw</span>[ultra thick] (3,0)--(3,2);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129092537257.png" alt="image-20250129092537257" style="zoom:67%;" /></p></li>
<li><p><span class="math inline">\(\texttt{solid/dashed/dotted/dash
dot/dash dot dot}\)</span> 指定线条类型（实线、虚线、点划线等）。与
<span class="math inline">\(\texttt{dashed}\)</span> 对应地有 <span
class="math inline">\(\texttt{densely dashed}\)</span> 和 <span
class="math inline">\(\texttt{loosely
dashed}\)</span>，后三种类型同理。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span>[dashed] (0,0) -- (0,2);</span><br><span class="line"><span class="keyword">\draw</span>[dotted] (0.5,0) -- (0.5,2);</span><br><span class="line"><span class="keyword">\draw</span>[dash dot] (1,0) -- (1,2);</span><br><span class="line"><span class="keyword">\draw</span>[dash dot dot] (1.5,0) -- (1.5,2);</span><br><span class="line"><span class="keyword">\draw</span>[densely dotted]</span><br><span class="line">   (2,0) -- (3,2) -- (4,0) -- cycle;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129092948158.png" alt="image-20250129092948158" style="zoom:67%;" /></p></li>
<li><p><span class="math inline">\(\texttt{arrow - arrow}\)</span>
指定线条首尾的箭头形式。复杂的箭头形式需要在导言区使用
<code>\usetikzlibrary&#123;arrows.meta&#125;</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;[thick]</span><br><span class="line"><span class="keyword">\draw</span>[-&gt;] (0,4) -- (3,4);</span><br><span class="line"><span class="keyword">\draw</span>[-&gt;&gt;] (0,3.5) -- (3,3.5);</span><br><span class="line"><span class="keyword">\draw</span>[-&gt;|] (0,3) -- (3,3);</span><br><span class="line"><span class="keyword">\draw</span>[&lt;-] (0,2.5) -- (3,2.5);</span><br><span class="line"><span class="keyword">\draw</span>[&lt;-&gt;] (0,2) -- (3,2);</span><br><span class="line"><span class="keyword">\draw</span>[&gt;-&gt;|] (0,1.5) -- (3,1.5);</span><br><span class="line"><span class="keyword">\draw</span>[-stealth] (0,1) -- (3,1);</span><br><span class="line"><span class="keyword">\draw</span>[-latex] (0,0.5) -- (3,0.5);</span><br><span class="line"><span class="keyword">\draw</span>[-to] (0,0) -- (3,0);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129093329315.png" alt="image-20250129093329315" style="zoom:67%;" /></p></li>
<li><p><span class="math inline">\(\texttt{rounded
corners[=&lt;radius&gt;]/sharp corners}\)</span>
将路径转向处绘制成圆角/直角。可选参数<code>&lt;radius&gt;</code>
控制圆角的半径。可对某一段路径直接使用。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span>[rounded corners]</span><br><span class="line">  (0,0) rectangle (1,1);</span><br><span class="line"><span class="keyword">\draw</span> (2,0) -- (2,1)</span><br><span class="line">  [rounded corners=.3cm]</span><br><span class="line">  -- (3,1) -- (3.5,0)</span><br><span class="line">  [sharp corners] -- cycle;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129093732376.png" alt="image-20250129093732376" style="zoom:67%;" /></p></li>
<li><p><span
class="math inline">\(\texttt{scale/xshift/yshift/xslant/yslant/rotate}\)</span>
设定图形的缩放、位移和旋转。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span>[help lines](0,0) rectangle (1,1);</span><br><span class="line"><span class="keyword">\draw</span>[scale=1.5] (0,0) rectangle (1,1);</span><br><span class="line"><span class="keyword">\draw</span>[rotate=30] (0,0) rectangle (1,1);</span><br><span class="line"><span class="keyword">\draw</span>[help lines](2,0) rectangle (3,1);</span><br><span class="line"><span class="keyword">\draw</span>[yshift=4pt](2,0) rectangle (3,1);</span><br><span class="line"><span class="keyword">\draw</span>[help lines](4,0) rectangle (5,1);</span><br><span class="line"><span class="keyword">\draw</span>[xslant=0.4](4,0) rectangle (5,1);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129094034719.png" alt="image-20250129094034719" style="zoom:67%;" /></p></li>
</ul>
<p>为了重复利用绘图参数，减少代码冗余，<span
class="math inline">\(\textrm{TikZ}\)</span>
引入了“样式”的概念，可以定义一个样式包含绘图参数，然后将样式作为一个参数用于绘图：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line">  [myarrow/.style=&#123;blue,thick,-&gt;&#125;]</span><br><span class="line"><span class="keyword">\draw</span> (0,0)--(0,1)--(2,1);</span><br><span class="line"><span class="keyword">\draw</span>[myarrow] (0,0)--(2,1);</span><br><span class="line"><span class="keyword">\draw</span>[myarrow,dotted]</span><br><span class="line">  (0,0)--(2,0)--(2,1);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129094345438.png" alt="image-20250129094345438" style="zoom:67%;" /></p>
<p><span class="math inline">\(\textrm{TikZ}\)</span> 还提供了<span
class="math inline">\(\texttt{scope}\)</span>
环境，令绘图参数或样式在局部生效：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) rectangle (2.5, 2.5);</span><br><span class="line"><span class="keyword">\begin</span>&#123;scope&#125;[thick,scale=0.5]</span><br><span class="line"><span class="keyword">\draw</span> (0,0) rectangle (2.5, 2.5);</span><br><span class="line"><span class="keyword">\end</span>&#123;scope&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129094453595.png" alt="image-20250129094453595" style="zoom:67%;" /></p>
<h3 id="textrmtikz-文字结点"><span
class="math inline">\(\textrm{TikZ}\)</span> 文字结点</h3>
<p><span class="math inline">\(\textrm{TikZ}\)</span> 用
<code>\node</code> 命令绘制文字结点：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\node</span>[&lt;options&gt;] (&lt;name&gt;) at (&lt;coordinate&gt;) &#123;&lt;text&gt;&#125;;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(\texttt{(&lt;name&gt;)}\)</span>
为结点命名，类似 <code>\coordinate</code>；<span
class="math inline">\(\texttt{at (&lt;coordinate&gt;)}\)</span>
指定结点的位置。这两者和前面的 <code>&lt;options&gt;</code>
都可以省略，只有 <code>&lt;text&gt;</code> 是必填的。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\node</span> (A) at (0,0) &#123;A&#125;;</span><br><span class="line"><span class="keyword">\node</span> (B) at (1,0) &#123;B&#125;;</span><br><span class="line"><span class="keyword">\node</span> (C) at (60:1) &#123;C&#125;;</span><br><span class="line"><span class="keyword">\draw</span> (A) -- (B) -- (C) -- (A);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129095143645.png" alt="image-20250129095143645" style="zoom:67%;" /></p>
<p>上一 小节中的参数可用于 <code>\node</code>
命令的配置。除此之外，<code>\node</code> 还有一些特定的参数：</p>
<ul>
<li><p><span
class="math inline">\(\texttt{anchor=&lt;position&gt;}\)</span>
令结点的某个角落 <code>&lt;position&gt;</code> 与
<code>&lt;coordinate&gt;</code> 对应。</p></li>
<li><p><span class="math inline">\(\texttt{centered}\)</span>/<span
class="math inline">\(\texttt{above}\)</span>/<span
class="math inline">\(\texttt{below}\)</span>/<span
class="math inline">\(\texttt{left}\)</span>/<span
class="math inline">\(\texttt{right}\)</span>/<span
class="math inline">\(\texttt{above left}\)</span>/<span
class="math inline">\(\ldots [=&lt;length&gt;]\)</span> 与 <span
class="math inline">\(\texttt{anchor}\)</span> 等效的选项。可选的
<code>&lt;length&gt;</code> 为结点相对于 <code>&lt;coordinate&gt;</code>
的距离。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\coordinate</span> (A) at (1,1);</span><br><span class="line"><span class="keyword">\fill</span> (A) circle[radius=2pt];</span><br><span class="line"><span class="keyword">\node</span>[draw,anchor=south] at (A) &#123;a&#125;;</span><br><span class="line"><span class="keyword">\node</span>[draw,below right=4pt] at (A) &#123;b&#125;;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129100019973.png" alt="image-20250129100019973" style="zoom:67%;" /></p></li>
<li><p><span class="math inline">\(\texttt{shape=&lt;shape&gt;}\)</span>
结点的形状，默认可用 <span
class="math inline">\(\texttt{rectangle}\)</span> 和 <span
class="math inline">\(\texttt{circle}\)</span>，可省略 <span
class="math inline">\(\texttt{shape=}\)</span>
直接写。在导言区使用命令<code>\usetikzlibrary&#123;shapes.geometric&#125;</code>
可用更多的形状。</p></li>
<li><p><span class="math inline">\(\texttt{text=&lt;color&gt;}\)</span>
结点文字的颜色。</p></li>
<li><p><span class="math inline">\(\texttt{node font={&lt;font
command&gt;}}\)</span>结点文字的字体，形如 <code>\bfseries</code> 或
<code>\itshape</code> 等。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\node</span>[circle,fill=blue,text=white,</span><br><span class="line">  node font=&#123;<span class="keyword">\bfseries</span>&#125;]</span><br><span class="line">  (A) at (0,0) &#123;A node&#125;;</span><br><span class="line"><span class="keyword">\node</span>[rectangle,rounded corners,</span><br><span class="line">  draw=gray,</span><br><span class="line">  node font=&#123;<span class="keyword">\sffamily</span><span class="keyword">\slshape</span>&#125;]</span><br><span class="line">  (B) at (2,0) &#123;B node&#125;;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129111754629.png" alt="image-20250129111754629" style="zoom:67%;" /></p></li>
<li><p><span class="math inline">\(\texttt{inner sep= &lt;length&gt;} /
\texttt{outer sep=&lt;length&gt;}\)</span>
结点边界向外和向内的额外距离。</p></li>
<li><p><span class="math inline">\(\texttt{minimum
size=&lt;length&gt;}\)</span> / <span
class="math inline">\(\texttt{minimum height=&lt;length&gt;}\)</span>
/<span class="math inline">\(\texttt{minimum
width=&lt;length&gt;}\)</span>结点的最小大小或最小高度/宽度。</p></li>
</ul>
<p><code>\node</code> 命令不仅为文字结点的位置命名，在
<code>\draw</code>
等命令中还可以使用某个结点的相对位置，以“东南西北”的方式命名：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0) circle[radius=1];</span><br><span class="line"><span class="keyword">\fill</span> (0,0) circle[radius=2pt];</span><br><span class="line"><span class="keyword">\node</span>[draw] (P) at (15:2) &#123;center&#125;;</span><br><span class="line"><span class="keyword">\draw</span>[dotted] (0,0) -- (P.west);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129112355158.png" alt="image-20250129112355158" style="zoom:67%;" /></p>
<p><code>\node</code> 命令的一种等效用法是在 <code>\draw</code>
等命令的路径中使用 <span
class="math inline">\(\texttt{node}\)</span>，不仅可以对某个位置标记结点，还能够对线标记：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (2,1.5) node[above] &#123;<span class="built_in">$</span>A<span class="built_in">$</span>&#125;</span><br><span class="line">       -- node[above left]  &#123;<span class="built_in">$</span>c<span class="built_in">$</span>&#125;</span><br><span class="line">    (0,0) node[left]  &#123;<span class="built_in">$</span>B<span class="built_in">$</span>&#125;</span><br><span class="line">       -- node[below]       &#123;<span class="built_in">$</span>a<span class="built_in">$</span>&#125;</span><br><span class="line">  (2.5,0) node[right] &#123;<span class="built_in">$</span>C<span class="built_in">$</span>&#125;</span><br><span class="line">       -- node[above right] &#123;<span class="built_in">$</span>b<span class="built_in">$</span>&#125;</span><br><span class="line">       cycle;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129112621479.png" alt="image-20250129112621479" style="zoom:67%;" /></p>
<p>在此举一个较为复杂的例子，综合前面介绍过的各种路径、形状、文字结点和参数设置，见下面的源代码。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129112859971.png" alt="image-20250129112859971" style="zoom:67%;" /></p>
<h3 id="在-textrmtikz-中使用循环">在 <span
class="math inline">\(\textrm{TikZ}\)</span> 中使用循环</h3>
<p><span class="math inline">\(\textrm{TikZ}\)</span> 通过
<code>pgffor</code> 功能宏包实现了简单的循环功能，语法为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\foreach</span> <span class="keyword">\a</span> in &#123;&lt;list&gt;&#125; &#123;&lt;commands&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>上述语法定义了 <code>\a</code> 为变量，在
<code>&lt;commands&gt;</code> 中使用 <code>\a</code> 完成循环。</p>
<p><code>&lt;list&gt;</code> 可以直接将所有值写出来，如 <span
class="math inline">\(\texttt{1,2,3,4}\)</span>；也可以写成省略形式，如
<span class="math inline">\(\texttt{1,2,...,10}\)</span>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\draw</span> (0,0)--(5,0);</span><br><span class="line"><span class="keyword">\foreach</span> <span class="keyword">\i</span> in &#123;0.0,0.1,...,5.0&#125;</span><br><span class="line">  &#123;<span class="keyword">\draw</span>[very thin]</span><br><span class="line">     (<span class="keyword">\i</span>,0)--(<span class="keyword">\i</span>,0.15);&#125;</span><br><span class="line"><span class="keyword">\foreach</span> <span class="keyword">\I</span> in &#123;0,1,2,3,4,5&#125;</span><br><span class="line">  &#123;<span class="keyword">\draw</span> (<span class="keyword">\I</span>,0)--(<span class="keyword">\I</span>,0.25)</span><br><span class="line">     node[above] &#123;<span class="keyword">\I</span>&#125;;&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129113731045.png" alt="image-20250129113731045" style="zoom:67%;" /></p>
<p><code>\foreach</code> 还可使用变量对参与循环：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\foreach</span> <span class="keyword">\n</span>/<span class="keyword">\t</span> in</span><br><span class="line">  &#123;0/<span class="keyword">\alpha</span>,1/<span class="keyword">\beta</span>,2/<span class="keyword">\gamma</span>&#125;</span><br><span class="line">  &#123;<span class="keyword">\node</span>[circle,fill=lightgray,draw]</span><br><span class="line">    at (<span class="keyword">\n</span>,0) &#123;<span class="built_in">$</span><span class="keyword">\t</span><span class="built_in">$</span>&#125;;&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250129113823045.png" alt="image-20250129113823045" style="zoom:67%;" /></p>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之特色工具和功能（六）</title>
    <url>/lang-latex/notes-lshort/06-special/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>本文介绍一些特色的 <span class="math inline">\(\LaTeX{}\)</span>
辅助功能。前两个功能 <span
class="math inline">\(\texttt{BibTeX}\)</span> 和 <span
class="math inline">\(\texttt{makeindex}\)</span>
依靠一些辅助程序自动生成参考文献、索引等；之后的使用颜色、超链接等则生成美观易用的电子文档。</p>
<span id="more"></span>
<hr />
<h2 id="参考文献和-textttbibtex-工具">参考文献和 <span
class="math inline">\(\texttt{BibTeX}\)</span> 工具</h2>
<h3 id="基本的参考文献和引用">基本的参考文献和引用</h3>
<p><span class="math inline">\(\LaTeX{}\)</span>
提供的参考文献和引用方式比较原始，需要用户自行书写参考文献列表（包括格式），因此较难直接使用。相关的命令只作最简单的介绍。</p>
<p><span class="math inline">\(\LaTeX{}\)</span> 提供了最基本的
<code>\cite</code> 命令用于在正文中引用参考文献：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cite</span>&#123;&lt;citation&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;citation&gt;</code> 为引用的参考文献的标签，类似
<code>\ref</code> 里的参数；<code>\cite</code>
带一个可选参数，为引用的编号后加上额外的内容，如
<code>\cite[page 22]&#123;Paper2013&#125;</code>可能得到形如
<code>[13, page 22]</code> 这样的引用。</p>
<p>参考文献由 <span
class="math inline">\(\texttt{thebibliography}\)</span>
环境包裹。每条参考文献由 <code>\bibitem</code>
开头，其后是参考文献本身的内容：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;&lt;widest label&gt;&#125;</span><br><span class="line">	<span class="keyword">\bibitem</span>[&lt;item number&gt;&#125;&#123;&lt;citation&gt;&#125; ...</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;citation&gt;</code> 是 <code>\cite</code>
使用的文献标签，<code>&lt;item number&gt;</code>
自定义参考文献的序号，如果省略，则按自然排序给定序号。<code>&lt;widest label&gt;</code>
用以限制参考文献序号的宽度，如 99
意味着不超过两位数字。通常设定为与参考文献的数目一致。</p>
<p>在 <span class="math inline">\(\texttt{article}\)</span>
文档类，<span class="math inline">\(\texttt{thebibliography}\)</span>
环境自动生成不带编号的一节，标题默认为<span
class="math inline">\(\texttt{“References”}\)</span>；而在 <span
class="math inline">\(\texttt{report}\)</span> 或 <span
class="math inline">\(\texttt{book}\)</span>
文档类中，则会生成不带编号的一章，标题默认为<span
class="math inline">\(\texttt{“Bibliography”}\)</span>。</p>
<p>以下为一个使用 <span
class="math inline">\(\texttt{thebibliography}\)</span>
排版参考文献的例子：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;Introduction&#125;</span><br><span class="line">Partl~<span class="keyword">\cite</span>&#123;germenTeX&#125; has proposed that <span class="keyword">\ldots</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line"><span class="keyword">\bibitem</span>&#123;germenTeX&#125; H.~Partl: <span class="keyword">\emph</span>&#123;German <span class="keyword">\TeX</span>&#125;,</span><br><span class="line">  TUGboat Volume~9, Issue~1 (1988)</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h3 id="textttbibtex-数据库"><span
class="math inline">\(\texttt{BibTeX}\)</span> 数据库</h3>
<p><span class="math inline">\(\texttt{BibTeX}\)</span>
是最为流行的参考文献数据组织格式之一。它的出现让我们摆脱手写参考文献条目的麻烦。还可以通过参考文献样式的支持，让同一份
<span class="math inline">\(\texttt{BibTeX}\)</span>
数据库生成不同样式的参考文献列表。</p>
<p><span class="math inline">\(\texttt{BibTeX}\)</span> 数据库以 <span
class="math inline">\(\texttt{.bib}\)</span>
作为扩展名，其内容是若干个文献条目，每个条目的格式为：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250126152050667.png" alt="image-20250126152050667" style="zoom:67%;" /></p>
<p>其中 <code>&lt;type&gt;</code> 为文献的类别，如 <span
class="math inline">\(\texttt{article}\)</span> 为学术论文，<span
class="math inline">\(\texttt{book}\)</span> 为书籍，<span
class="math inline">\(\texttt{incollection}\)</span>
为论文集中的某一篇，等等。<code>&lt;citation&gt;</code> 为
<code>\cite</code> 命令使用的文献标签。在<code>&lt;citation&gt;</code>
之后为条目里的各个字段，以 <code>&lt;key&gt; = &lt;value&gt;</code>
的形式组织。</p>
<p>在此简单列举学术论文里使用较多的 <span
class="math inline">\(\texttt{BibTeX}\)</span> 文献条目类别：</p>
<ul>
<li><span class="math inline">\(\texttt{article}\)</span>
<strong>学术论文</strong>，必需字段有 <span
class="math inline">\(\textrm{author}\)</span>, <span
class="math inline">\(\textrm{title}\)</span>, <span
class="math inline">\(\textrm{journal}\)</span>, <span
class="math inline">\(\textrm{year}\)</span>; 可选字段包括 <span
class="math inline">\(\textrm{volume}\)</span>, <span
class="math inline">\(\textrm{number}\)</span>, <span
class="math inline">\(\textrm{pages}\)</span>, <span
class="math inline">\(\textrm{doi}\)</span> 等；</li>
<li><span class="math inline">\(\texttt{book}\)</span>
<strong>书籍</strong>，必需字段有 <span
class="math inline">\(\textrm{author/editor}\)</span>, <span
class="math inline">\(\textrm{title}\)</span>, <span
class="math inline">\(\textrm{publisher}\)</span>, <span
class="math inline">\(\textrm{publisher}\)</span>; 可选字段包括 <span
class="math inline">\(\textrm{volume/number}\)</span>, <span
class="math inline">\(\textrm{series}\)</span>, <span
class="math inline">\(\textrm{address}\)</span> 等；</li>
<li><span class="math inline">\(\texttt{incollection}\)</span>
<strong>论文集中的一篇</strong>，必需字段有 <span
class="math inline">\(\textrm{author}\)</span>, <span
class="math inline">\(\textrm{title}\)</span>, <span
class="math inline">\(\textrm{booktitle}\)</span>, <span
class="math inline">\(\textrm{publisher}\)</span>, <span
class="math inline">\(\textrm{publisher}\)</span>; 可选字段包括 <span
class="math inline">\(\textrm{editor}\)</span>, <span
class="math inline">\(\textrm{volume/number}\)</span>, <span
class="math inline">\(\textrm{chapter}\)</span>, <span
class="math inline">\(\textrm{pages}\)</span>, <span
class="math inline">\(\textrm{address}\)</span> 等；</li>
<li><span class="math inline">\(\texttt{inbook}\)</span>
<strong>书中的一章</strong>，必需字段有 <span
class="math inline">\(\textrm{author/editor}\)</span>, <span
class="math inline">\(\textrm{title}\)</span>, <span
class="math inline">\(\textrm{chapter/pages}\)</span>, <span
class="math inline">\(\textrm{publisher}\)</span>, <span
class="math inline">\(\textrm{year}\)</span>; 可选字段包括 <span
class="math inline">\(\textrm{volume/number}\)</span>, <span
class="math inline">\(\textrm{series}\)</span>, <span
class="math inline">\(\textrm{address}\)</span> 等。</li>
</ul>
<p>例如 <span class="math inline">\(\texttt{article}\)</span>
类别的参考文献数据条目写法如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">@article&#123;Alice13,</span><br><span class="line">  title = &#123;Demostration of bibliography items&#125;,</span><br><span class="line">  author = &#123;Alice Axford and Bob Birkin and Charlie Copper and Danny Dannford&#125;,</span><br><span class="line">  year = &#123;2013&#125;,</span><br><span class="line">  month = &#123;Mar&#125;,</span><br><span class="line">  journal = &#123;Journal of <span class="keyword">\TeX</span> perts&#125;,</span><br><span class="line">  volume = &#123;36&#125;,</span><br><span class="line">  number = &#123;7&#125;,</span><br><span class="line">  pages = &#123;114-120&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>多数时候，我们无需自己手写 <span
class="math inline">\(\texttt{BibTeX}\)</span> 文献条目。从 Google
Scholar 或者期刊/数据库的网站上都能够导出 <span
class="math inline">\(\texttt{BibTeX}\)</span>文献条目，老牌的文献管理软件
EndNote 也支持生成 <span class="math inline">\(\texttt{BibTeX}\)</span>
格式的数据库。开源软件 JabRef 甚至支持 <span
class="math inline">\(\texttt{BibTeX}\)</span>
文献条目的导入、导出和管理。下面是<strong>从谷歌学术镜像获取bib</strong>的步骤：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250422160552215.png" alt="image-20250422160552215" style="zoom:50%;" /></p>
<h3 id="textttbibtex-样式"><span
class="math inline">\(\texttt{BibTeX}\)</span> 样式</h3>
<p>参考文献的写法在不同文献里千差万别，包括作者、标题、年份等各项的顺序和字体样式、文献在列表中的排序规则等。<span
class="math inline">\(\texttt{BibTeX}\)</span> 用样式（<span
class="math inline">\(\texttt{style}\)</span>）来管理参考文献的写法。<span
class="math inline">\(\texttt{BibTeX}\)</span>
提供了几个预定义的样式，如 <span
class="math inline">\(\texttt{plain}\)</span>, <span
class="math inline">\(\texttt{unsrt}\)</span>, <span
class="math inline">\(\texttt{alpha}\)</span>
等。如果使用期刊模板的话，可能会提供自用的样式。样式文件以 <span
class="math inline">\(\texttt{.bst}\)</span> 为扩展名。
使用样式文件的方法是在源代码内（一般在导言区）使用<code>\bibliographystyle</code>
命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\bibliographystyle</span>&#123;&lt;bst-name&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>&lt;bst-name&gt;</code> 为 <span
class="math inline">\(\texttt{.bst}\)</span>
样式文件的名称，<strong>不要带 <span
class="math inline">\(\texttt{.bst}\)</span> 扩展名</strong>。</p>
<p>以 上一小节给出的数据条目为例，使用 <code>\bibliographystyle</code>
命令选择不同的参考文献样式，效果大致如下表所示。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250127144405131.png" alt="image-20250127144405131" style="zoom:67%;" /></p>
<h3 id="使用-textttbibtex-排版参考文献">使用 <span
class="math inline">\(\texttt{BibTeX}\)</span> 排版参考文献</h3>
<p>现在我们来看如何利用 <span
class="math inline">\(\texttt{BibTeX}\)</span>
数据库生成参考文献和引用。</p>
<p>第一步：准备一份 <span class="math inline">\(\texttt{BibTeX}\)</span>
数据库，假设数据库文件名为 <span
class="math inline">\(\texttt{books.bib}\)</span>，和 <span
class="math inline">\(\LaTeX{}\)</span>
源代码<strong>一般位于同一个目录下</strong>。</p>
<p>第二步：在源代码中添加必要的命令。假设源代码名为 <span
class="math inline">\(\texttt{demo.tex}\)</span>（见下面的源代码）。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;plain&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;Some words&#125;</span><br><span class="line">Some excellent books, for example, <span class="keyword">\cite</span>&#123;citation1&#125; and <span class="keyword">\cite</span>&#123;citation2&#125; <span class="keyword">\ldots</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\bibliography</span>&#123;books&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>首先需要使用命令 <code>\bibliographystyle</code>
设定参考文献的格式。</p></li>
<li><p>其次，在正文中引用参考文献。<span
class="math inline">\(\texttt{BibTeX}\)</span>
程序在生成参考文献列表的时候，通常只列出用了 <code>\cite</code>
命令引用的那些。如果需要列出未被引用的文献，则需要<code>\nocite&#123;&lt;citation&gt;&#125;</code>
命令；而 <code>\nocite&#123;*&#125;</code> 则让所有未被引用的文献都列出。</p></li>
<li><p>再次，在需要列出参考文献的位置，使用<code>\bibliography</code>
命令代替 <span class="math inline">\(\texttt{thebibliography}\)</span>
环境：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\bibliography</span>&#123;&lt;bib-name&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;bib-name&gt;</code> 是 <span
class="math inline">\(\texttt{BibTeX}\)</span>
数据库的文件名，<strong>不要带 <span
class="math inline">\(\texttt{.bib}\)</span> 扩展名</strong>。</p></li>
</ol>
<p>注意：<code>\bibliographystyle</code> 和 <code>\bibliography</code>
命令缺一不可，没有这两个命令，使用 <span
class="math inline">\(\texttt{BibTeX}\)</span>
生成参考文献列表的时候会报错。</p>
<p>第三步：写好了以上两个文件之后，就可以开始编译了。</p>
<ol type="1">
<li>首先使用 <span class="math inline">\(\texttt{pdflatex}\)</span> 或
<span class="math inline">\(\texttt{xelatex}\)</span> 等命令编译 <span
class="math inline">\(\LaTeX{}\)</span> 源代码 <span
class="math inline">\(\texttt{demo.tex}\)</span>；</li>
<li>接下来用 <span class="math inline">\(\texttt{bibtex}\)</span>
命令处理 <span class="math inline">\(\texttt{demo.aux}\)</span>
辅助文件记录的参考文献格式、引用条目等信息。<span
class="math inline">\(\texttt{bibtex}\)</span> 命令处理完毕后会生成
<span class="math inline">\(\texttt{demo.bbl}\)</span>
文件，内容就是一个 <code>\thebibliography</code> 环境；</li>
<li>再使用 <span class="math inline">\(\texttt{pdflatex}\)</span> 或
<span class="math inline">\(\texttt{xelatex}\)</span> 等命令把源代码
<span class="math inline">\(\texttt{demo.tex}\)</span>
编译<strong>两遍</strong>，读入参考文献并正确生成引用。</li>
</ol>
<p>整个过程使用的命令如下（可以略去扩展名）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xelatex demo</span><br><span class="line">bibtex demo</span><br><span class="line">xelatex demo</span><br><span class="line">xelatex demo</span><br></pre></td></tr></table></figure>
<p>使用 <span class="math inline">\(\texttt{latex + dvipdfmx}\)</span>
命令编译时，则 <span class="math inline">\(\texttt{dvipdfmx}\)</span>
命令放在最后，相当于先后使用<span
class="math inline">\(\texttt{latex}\)</span>, <span
class="math inline">\(\texttt{bibtex}\)</span>, <span
class="math inline">\(\texttt{latex}\)</span>, <span
class="math inline">\(\texttt{latex}\)</span>, <span
class="math inline">\(\texttt{dvipdfmx}\)</span>。</p>
<h3 id="textttnatbib-宏包"><span
class="math inline">\(\texttt{natbib}\)</span> 宏包</h3>
<p>时下许多学术期刊比较喜欢使用人名——年份的引用方式，形如(<span
class="math inline">\({Axford~et~al.},
2013\)</span>)。<code>natbib</code>
宏包提供了对这种“自然”引用方式的处理。</p>
<p>除了 <code>\cite</code> 之外，<code>natbib</code>
宏包在正文中支持两种引用方式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\citep</span>&#123;&lt;citation&gt;&#125; </span><br><span class="line"><span class="keyword">\citet</span>&#123;&lt;citation&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>它们分别生成形如(<span class="math inline">\(Axford~et~al.,
2013\)</span>) 和 <span class="math inline">\(Axford~et~al.
(2013)\)</span> 的人名——年份引用。正确排版人名——年份引用还依赖于特定的
<span class="math inline">\(\texttt{BibTeX}\)</span>
样式。<code>natbib</code> 提供了与 <span
class="math inline">\(\LaTeX{}\)</span> 预定义样式相对应的几个样式，包括
<span class="math inline">\(\texttt{plainnat}\)</span>、<span
class="math inline">\(\texttt{abbrvnat}\)</span> 和 <span
class="math inline">\(\texttt{unsrtnat}\)</span>。学术论文模板是否支持
<code>natbib</code>，需要参考其帮助文档。</p>
<p><code>natbib</code>
宏包同样也支持数字引用，并且支持将引用的序号压缩，例如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[numbers,sort<span class="built_in">&amp;</span>compress]&#123;natbib&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>natbib</code>
宏包时指定以上选项后，连续引用多篇文献时，会生成形如 <span
class="math inline">\((3-7)\)</span> 的引用而不是 <span
class="math inline">\((3, 4, 5, 6, 7)\)</span>。</p>
<p><code>natbib</code>
宏包还有更多选项和用法，比如默认的引用是用小括号包裹的，可指定 <span
class="math inline">\(\texttt{square}\)</span> 选项改为中括号；再比如
<code>\citep</code>
命令也支持可选参数，为引用前后都添加额外内容。这里不再赘述，请参考
<code>natbib</code> 宏包的帮助文档。</p>
<h3 id="textttbiblatex-宏包"><span
class="math inline">\(\texttt{biblatex}\)</span> 宏包</h3>
<p>本节的末尾简单介绍一下基于 <code>biblatex</code>
宏包排版参考文献的方式。<code>biblatex</code> 宏包是一套基于 <span
class="math inline">\(\LaTeX{}\)</span>
宏命令的参考文献解决方案，提供了便捷的格式控制和强大的排序、分类、筛选、多文献表等功能。<code>biblatex</code>
宏包也因其对 UTF-8 和中文参考文献的良好支持，被国内较多 <span
class="math inline">\(\LaTeX{}\)</span> 模板采用。</p>
<p>基于 <code>biblatex</code> 宏包的方式与基于 <span
class="math inline">\(\texttt{BibTeX}\)</span>
的传统方式有一定区别，下面从文档结构和命令、编译方式、样式选择等方面逐一介绍：</p>
<h4 id="文档结构和-biblatex-相关命令">文档结构和 <code>biblatex</code>
相关命令</h4>
<ol type="1">
<li>首先是在导言区调用 <code>biblatex</code> 宏包。宏包支持以
<code>&lt;key&gt;=&lt;value&gt;</code> 形式指定选项，包括参考文献样式
style、参考文献著录排序的规则 sorting 等。</li>
<li>接着在导言区使用 <code>\addbibresource</code> 命令为
<code>biblatex</code> 引入参考文献数据库。与基于 <span
class="math inline">\(\texttt{BibTeX}\)</span>
的传统方式不同的是，这里需要写完整的文件名。</li>
<li>在正文中使用 <code>\cite</code>
命令引用参考文献。除此之外还可以使用丰富的命令达到不同的引用效果，如
<code>\citeauthor</code> 和 <code>\citeyear</code>
分别单独引用作者和年份，<code>\textcite</code> 和
<code>\parencite</code> 分别类似 <code>natbib</code> 宏包提供的
<code>\citet</code> 和 <code>\citep</code> 命令，以及脚注式引用
<code>\footcite</code> 等。</li>
<li>最后在需要排版参考文献的位置使用命令
<code>\printbibliography</code>。</li>
</ol>
<h4 id="编译方式">编译方式</h4>
<p>与基于 <span class="math inline">\(\texttt{BibTeX}\)</span>
的传统方式不同的是，<code>biblatex</code> 宏包使用 <span
class="math inline">\(\texttt{biber}\)</span>
程序处理参考文献。因此上述文档的编译步骤为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xelatex demo</span><br><span class="line">biber demo</span><br><span class="line">xelatex demo</span><br><span class="line">xelatex demo</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% File: egbibdata.bib</span></span><br><span class="line">@book&#123;caimin2006,</span><br><span class="line">  title      = &#123;UML基础和Rose建模教程&#125;,</span><br><span class="line">  address    = &#123;北京&#125;,</span><br><span class="line">  author     = &#123;蔡敏 and 徐慧慧 and 黄柄强&#125;,</span><br><span class="line">  publisher  = &#123;人民邮电出版社&#125;,</span><br><span class="line">  year       = &#123;2006&#125;,</span><br><span class="line">  month      = &#123;1&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% File: demo.tex</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br><span class="line"><span class="comment">% 使用符合 GB/T 7714-2015 规范的参考文献样式</span></span><br><span class="line"><span class="keyword">\usepackage</span>[style=gb7714-2015]&#123;biblatex&#125;</span><br><span class="line"><span class="comment">% 注意加 .bib 扩展名</span></span><br><span class="line"><span class="keyword">\addbibresource</span>&#123;egbibdata.bib&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line">见文献<span class="keyword">\cite</span>&#123;caimin2006&#125;。</span><br><span class="line"></span><br><span class="line"><span class="keyword">\printbibliography</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h4 id="biblatex-样式和其它选项"><code>biblatex</code>
样式和其它选项</h4>
<p><code>biblatex</code> 使用的参考文献样式分为著录样式（<span
class="math inline">\(\texttt{bibliography
style}\)</span>）和引用样式（<span
class="math inline">\(\texttt{citation style}\)</span>），分别以 <span
class="math inline">\(\texttt{.bbx}\)</span> 和 <span
class="math inline">\(\texttt{.cbx}\)</span>
为扩展名。参考文献的样式在调用宏包时使用 <span
class="math inline">\(\texttt{style}\)</span> 选项指定，或者使用 <span
class="math inline">\(\texttt{bibstyle}\)</span> 或 <span
class="math inline">\(\texttt{citestyle}\)</span> 分别指定：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 同时调用 gb7714-2015.bbx 和 gb7714-2015.cbx</span></span><br><span class="line"><span class="keyword">\usepackage</span>[style=gb7714-2015]&#123;biblatex&#125;</span><br><span class="line"><span class="comment">% 著录样式调用 gb7714-2015.bbx，引用样式调用 biblatex 宏包自带的 authoryear</span></span><br><span class="line"><span class="keyword">\usepackage</span>[bibstyle=gb7714-2015,citestyle=authoryear]&#123;biblatex&#125;</span><br></pre></td></tr></table></figure>
<p>以下总结一些常用的参考文献样式，除 <code>biblatex</code>
宏包自带的样式外，许多样式以单独的宏包在发行版内发布。</p>
<ul>
<li><span class="math inline">\(\texttt{authoryear}\)</span>
<code>biblatex</code>自带样式，类似 <code>natbib</code>
默认的引用样式效果。</li>
<li><span class="math inline">\(\texttt{authortitle}\)</span>
<code>biblatex</code>自带样式，采用作者-题名（shorttitle
字段）的引用样式。</li>
<li><span class="math inline">\(\texttt{verbose}\)</span>
<code>biblatex</code>
自带样式，引用样式中包含作者、题名、书名、页码等字段的信息。</li>
<li><span class="math inline">\(\texttt{alphabetic}\)</span>
<code>biblatex</code>自带样式，著录样式与 <span
class="math inline">\(\texttt{BibTeX}\)</span> 的 <span
class="math inline">\(\texttt{alpha}\)</span> 样式类似。</li>
<li><span class="math inline">\(\texttt{trad-alpha}\)</span>
<code>biblatex-trad</code> 样式包，移植自 <span
class="math inline">\(\texttt{BibTeX}\)</span> 默认的 <span
class="math inline">\(\texttt{alpha}\)</span> 样式。另外还包括 <span
class="math inline">\(\texttt{trad-abbrv}\)</span>、<span
class="math inline">\(\texttt{trad-plain}\)</span> 和 $。</li>
<li><span class="math inline">\(\texttt{gb7714-2015}\)</span>
符合中文文献著录标准 GB/T 7714—2015
的样式，著录按顺序编码排版。另外还包括按作者—年份顺序排版著录的样式
<span class="math inline">\(\texttt{gb7714-2015ay}\)</span>。</li>
<li><span class="math inline">\(\texttt{caspervector}\)</span>
以中文文献著录标准 GB/T 7714—2015 为基础的一个样式。</li>
<li><span class="math inline">\(\texttt{ieee}\)</span> 兼容
<code>IEEEtran</code>
风格的样式，著录按顺序编码排版。另外还包括按作者—年份顺序排版著录的样式
<span class="math inline">\(\texttt{ieee-alphabetic}\)</span>。</li>
</ul>
<hr />
<h2 id="索引和-textrmmakeindex-工具">索引和 <span
class="math inline">\(\textrm{makeindex}\)</span> 工具</h2>
<p>书籍和大文档通常用索引来归纳关键词，方便用户查阅。<span
class="math inline">\(\LaTeX{}\)</span> 借助配套的 <span
class="math inline">\(\textrm{makeindex}\)</span>
程序完成对索引的排版。</p>
<h3 id="使用-textrmmakeindex-工具的方法">使用 <span
class="math inline">\(\textrm{makeindex}\)</span> 工具的方法</h3>
<p>要使用索引，须经过这么几个步骤（仍设源代码名为 <span
class="math inline">\(\texttt{demo.tex}\)</span>）：</p>
<p>第一步，在 <span class="math inline">\(\LaTeX{}\)</span>
源代码的导言区调用 <code>makeidx</code> 宏包，并使用
<code>\makeindex</code> 命令开启索引的收集：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;makeidx&#125;</span><br><span class="line"><span class="keyword">\makeindex</span></span><br></pre></td></tr></table></figure>
<p>第二步，在正文中需要索引的地方使用 <code>\index</code>
命令。在需要输出索引的地方（如所有章节之后）使用
<code>\printindex</code> 命令。</p>
<p>第三步，编译过程：</p>
<ol type="1">
<li>首先用 <span class="math inline">\(\texttt{xelatex}\)</span>
等命令编译源代码 <span
class="math inline">\(\texttt{demo.tex}\)</span>。编译过程中产生索引记录文件
<span class="math inline">\(\texttt{demo.idx}\)</span>；</li>
<li>用 <span class="math inline">\(\texttt{makeindex}\)</span> 程序处理
<span
class="math inline">\(\texttt{demo.idx}\)</span>，生成用于排版的索引列表文件
<span class="math inline">\(\texttt{demo.ind}\)</span>；</li>
<li>再次编译源代码 <span
class="math inline">\(\texttt{demo.tex}\)</span>，正确生成索引列表。</li>
</ol>
<h3 id="索引项的写法">索引项的写法</h3>
<p>添加索引项的命令为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\index</span>&#123;&lt;index entry&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;index entry&gt;</code> 为索引项，写法由 下表
汇总。其中 <span class="math inline">\(\texttt!\)</span>、<span
class="math inline">\(\texttt @\)</span> 和 <span
class="math inline">\(\texttt|\)</span>
为特殊符号，如果要向索引项直接输出这些符号，需要加前缀 <span
class="math inline">\(\texttt&quot;\)</span>；而 <span
class="math inline">\(\texttt&quot;\)</span> 需要输入两个引号 <span
class="math inline">\(\texttt{&quot;&quot;}\)</span>
才能输出到索引项。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250127204208420.png" alt="image-20250127204208420" style="zoom:67%;" /></p>
<p>读者可以钻研一下以下给出的一个较为复杂的，结合多级索引、索引格式、页码格式等的用法示例。但在自己使用时，最好还是遵循“简单的就是最好的”原则，尽量使用
上表 中的写法。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Test index.</span><br><span class="line"><span class="keyword">\index</span>&#123;Test@<span class="keyword">\textsf</span>&#123;&quot;&quot;Test&#125;|(textbf&#125;</span><br><span class="line"><span class="keyword">\index</span>&#123;Test@<span class="keyword">\textsf</span>&#123;&quot;&quot;Test&#125;!sub@&quot;|sub&quot;||see&#123;Test&#125;&#125;</span><br><span class="line"><span class="keyword">\newpage</span></span><br><span class="line">Test index.</span><br><span class="line"><span class="keyword">\index</span>&#123;Test@<span class="keyword">\textsf</span>&#123;&quot;&quot;Test&#125;|)textbf&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="使用颜色">使用颜色</h2>
<p>原始的 <span class="math inline">\(\LaTeX{}\)</span>
不支持使用各种颜色。<code>color</code> 宏包或者 <code>xcolor</code>
宏包提供了对颜色的支持，给 PDF 输出生成颜色的特殊指令。</p>
<h3 id="颜色的表达方式">颜色的表达方式</h3>
<p>调用 <code>color</code> 或 <code>xcolor</code>
宏包后，我们就可以用如下命令切换颜色：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\color</span>[&lt;color-mode&gt;]&#123;&lt;code&gt;&#125;</span><br><span class="line"><span class="keyword">\color</span>&#123;&lt;color-name&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>颜色的表达方式有两种，其一是使用色彩模型和色彩代码，代码用 <span
class="math inline">\(0\sim1\)</span>
的数字代表成分的比例。<code>color</code> 宏包支持 <span
class="math inline">\(\texttt{rgb}\)</span>、<span
class="math inline">\(\texttt{cmyk}\)</span> 和 <span
class="math inline">\(\texttt{gray}\)</span> 模型，<code>xcolor</code>
支持更多的模型如 <span class="math inline">\(\texttt{hsb}\)</span>
等。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250127205538936.png" alt="image-20250127205538936" style="zoom:67%;" /></p>
<p>其二是直接使用名称代表颜色，前提是已经定义了颜色名称（没定义的话会报错）：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250127205710585.png" alt="image-20250127205710585" style="zoom:67%;" /></p>
<p><code>color</code> 宏包仅定义了 8 种颜色名称，<code>xcolor</code>
补充了一些，总共有 19 种，见下表。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250127205821233.png" alt="image-20250127205821233" style="zoom:67%;" /></p>
<p><code>xcolor</code> 还支持将颜色通过表达式混合或互补：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250127205941911.png" alt="image-20250127205941911" style="zoom:67%;" /></p>
<p>我们还可以通过命令自定义颜色名称，注意这里的 <code>color-mode</code>
是必选参数：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\definecolor</span>&#123;&lt;color-name&gt;&#125;&#123;&lt;color-mode&gt;&#125;&#123;&lt;code&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用 <code>color</code> 或 <code>xcolor</code> 宏包时指定 <span
class="math inline">\(\texttt{dvipsnames}\)</span> 选项，就有额外的 68
种颜色名称可用。<code>xcolor</code>
宏包还支持通过指定其它选项载入更多颜色名称。限于篇幅不展开介绍，详情请参考
<code>xcolor</code> 宏包的手册。</p>
<h3 id="带颜色的文本和盒子">带颜色的文本和盒子</h3>
<p>原始的 <code>\color</code> 命令类似于字体命令
<code>\bfseries</code>，它使之后排版的内容全部变成指定的颜色，所以直接使用时通常要加花括号分组。<code>color</code>
和 <code>xcolor</code> 宏包都定义了一些方便用户使用的带颜色元素。</p>
<p>输入带颜色的文本可以用类似 <code>\textbf</code> 的命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\textcolor</span>[&lt;color-mode&gt;]&#123;&lt;code&gt;&#125;&#123;&lt;text&gt;&#125;</span><br><span class="line"><span class="keyword">\textcolor</span>&#123;color-name&#125;&#123;&lt;text&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>以下命令构造一个带背景色的盒子，<code>&lt;material&gt;</code>
为盒子中的内容：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\colorbox</span>[&lt;color-mode&gt;]&#123;&lt;code&gt;&#125;&#123;&lt;material&gt;&#125;</span><br><span class="line"><span class="keyword">\colorbox</span>&#123;&lt;color-name&gt;&#125;&#123;&lt;material&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>以下命令构造一个带背景色和有色边框的盒子，<code>&lt;fcode&gt;</code>
或 <code>&lt;fcolor-name&gt;</code> 用于设置边框颜色：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\fcolorbox</span>[&lt;color-mode&gt;]&#123;&lt;fcode&gt;&#125;&#123;&lt;code&gt;&#125;&#123;&lt;material&gt;&#125; </span><br><span class="line"><span class="keyword">\fcolorbox</span>&#123;&lt;fcolor-name&gt;&#125;&#123;&lt;color-name&gt;&#125;&#123;&lt;material&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250127211405408.png" alt="image-20250127211405408" style="zoom:67%;" /></p>
<p><code>\fcolorbox</code> 也可以像 <code>\fbox</code> 那样调节
<code>\fboxrule</code> 和 <code>\fboxsep</code>；对于
<code>\colorbox</code>，调整 <code>\fboxsep</code> 是有效的。</p>
<hr />
<h2 id="使用超链接">使用超链接</h2>
<p><span class="math inline">\(\LaTeX{}\)</span> 中实现超链接功能的是
<code>hyperref</code> 宏包。</p>
<h3 id="hyperref-宏包"><code>hyperref</code> 宏包</h3>
<p><code>hyperref</code> 宏包涉及的链接遍布 <span
class="math inline">\(\LaTeX{}\)</span>
的每一个角落——目录、引用、脚注、索引、参考文献等等都被封装成超链接。但这也使得它与其它宏包发生冲突的可能性大大增加，虽然宏包已经尽力解决各方面的兼容性，但仍不能面面俱到。为减少可能的冲突，习惯上将
<code>hyperref</code> 宏包<strong>放在其它宏包之后调用</strong>。</p>
<p>与 <code>graphicx</code> 宏包类似，<span
class="math inline">\(\texttt{latex} + \texttt{dvipdfmx}\)</span>
命令下调用 <code>hyperref</code> 宏包时，需要指定选项 <span
class="math inline">\(\texttt{dvipdfmx}\)</span>；而 <span
class="math inline">\(\texttt{pdflatex}\)</span> 或 <span
class="math inline">\(\texttt{xelatex}\)</span> 命令下不需要。</p>
<p><code>hyperref</code> 宏包提供了命令 <code>\hypersetup</code>
配置各种参数。参数也可以作为宏包选项，在调用宏包时指定：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hypersetup</span>&#123;&lt;option1&gt;,&lt;option2&gt;=&lt;value&gt;,...&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[&lt;option1&gt;,&lt;option2&gt;=&lt;value&gt;,...]&#123;hyperref&#125;</span><br></pre></td></tr></table></figure>
<p>当选项值为 <span class="math inline">\(\texttt{true}\)</span>
时，可以省略“<span
class="math inline">\(\texttt{=true}\)</span>”不写。可用的参数见
下表。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128001606010.png" alt="image-20250128001606010" style="zoom:67%;" /></p>
<h3 id="超链接">超链接</h3>
<p><code>hyperref</code> 宏包提供了直接书写超链接的命令，用于在 PDF
中生成 URL：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\url</span>&#123;<span class="link">&lt;url&gt;</span>&#125; </span><br><span class="line"><span class="keyword">\nolinkurl</span>&#123;&lt;url&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>\url</code> 和 <code>\nolinkurl</code> 都像抄录命令
<code>\verb</code> 一样输出一个 URL，区别是前者还为 URL
加上了超链接，后者没有。在 <code>\url</code> 等命令的参数
<code>&lt;url&gt;</code> 里，可直接输入如
<code>%</code>、<code>&amp;</code> 这样的特殊符号。</p>
<p>也可以像 HTML 中的超链接一样，把一段文字作为超链接：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\href</span>&#123;<span class="link">url</span>&#125;&#123;text&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250128002508111.png" alt="image-20250128002508111" style="zoom:67%;" /></p>
<p>使用 <code>hyperref</code>
宏包后，文档中所有的引用、参考文献、索引等等都转换为超链接。用户也可对某个
<code>\label</code> 命令定义的标签 <code>&lt;label&gt;</code>
作超链接（注意这里的 <code>&lt;label&gt;</code>
虽然是可选参数的形式，但通常是<strong>必填的</strong>：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hyperref</span>[&lt;label&gt;]&#123;&lt;text&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>默认的超链接在文字外边加上一个带颜色的边框（在打印 PDF
时边框不会打印），可指定 <span
class="math inline">\(\texttt{colorlinks}\)</span>
参数修改为将文字本身加上颜色，或修改 <span
class="math inline">\(\texttt{pdfborder}\)</span>
参数调整边框宽度以“去掉”边框；<span
class="math inline">\(\texttt{hidelinks}\)</span>
参数则令超链接既不变色也不加边框。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hypersetup</span>&#123;hidelinks&#125;</span><br><span class="line"><span class="comment">% or:</span></span><br><span class="line"><span class="keyword">\hypersetup</span>&#123;pdfborder=&#123;0 0 0&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pdf-书签">PDF 书签</h3>
<p><code>hyperref</code> 宏包另一个强大的功能是为 PDF
生成书签。对于章节命令 <code>\chapter</code>、<code>\section</code>
等，默认情况下会为 PDF
自动生成书签。和交叉引用、索引等类似，生成书签也需要多次编译源代码，第一次编译将书签记录写入
<span class="math inline">\(\texttt{.out}\)</span>
文件，第二次编译才正确生成书签。</p>
<p>书签的一些属性见 上表。使用 <code>CJK</code>
宏包时，为了防止中文书签出现乱码，需要进行繁琐的设置；但在使用
<code>ctex</code> 宏包和文档类、且使用 <span
class="math inline">\(\texttt{xelatex}\)</span> 或 <span
class="math inline">\(\texttt{lualatex}\)</span>
编译的情况下，无需用户额外干预，即可正确生成中文书签。</p>
<p><code>hyperref</code> 还提供了手动生成书签的命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\pdfbookmark</span>[&lt;level&gt;]&#123;&lt;bookmark&gt;&#125;&#123;&lt;anchor&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;bookmark&gt;</code> 为书签名称，<code>&lt;anchor&gt;</code>
为书签项使用的锚点（类似交叉引用的标签）。可选参数<code>&lt;level&gt;</code>为书签的层级，默认为
0。</p>
<p>章节命令里往往有 <span class="math inline">\(\LaTeX{}\)</span>
命令甚至数学公式，而 PDF
书签是纯文本，对命令和公式的处理很困难，有出错的风险。<code>hyperref</code>
宏包已经为我们处理了许多常见命令，如 <code>\LaTeX</code> 和字体命令
<code>\textbf</code>
等，对于未被处理的命令或数学公式，就要在章节标题中使用如下命令，分别提供
<span class="math inline">\(\LaTeX{}\)</span> 代码和 PDF
书签可用的纯文本：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\texorpdfstring</span>&#123;&lt;LaTeX code&gt;&#125;&#123;&lt;PDF bookmark text&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>比如在章节名称里使用公式 <span
class="math inline">\(E=mc^2\)</span>，而书签则使用纯文本形式的
E=mc^2：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;质能公式 <span class="keyword">\texorpdfstring</span>&#123;<span class="built_in">$</span>E=mc<span class="built_in">^</span>2<span class="built_in">$</span>&#125;&#123;E=mc<span class="keyword">\textasciicircum</span> 2&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pdf-文档属性">PDF 文档属性</h3>
<p><code>hyperref</code> 宏包还提供了一些参数用于改变 PDF
文档的属性，部分见 上表。</p>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言之可变参数列表</title>
    <url>/lang-c/c-variable-argument-lists/</url>
    <content><![CDATA[<p>在 C 语言中，可变参数列表（Variable Argument List）通过
<code>stdarg.h</code>
头文件提供的宏和函数来实现。它允许函数接受可变数量的参数，类似于
<code>printf</code> 和 <code>scanf</code> 这样的函数。以下是
<code>va_list</code> 相关的函数和用法：</p>
<span id="more"></span>
<hr />
<h3 id="核心宏和函数">核心宏和函数</h3>
<p><code>stdarg.h</code> 提供了以下宏和函数来处理可变参数列表：</p>
<table>
<thead>
<tr>
<th>宏/函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>va_list</code></td>
<td>定义一个变量，用于存储可变参数列表。</td>
</tr>
<tr>
<td><code>va_start()</code></td>
<td>初始化 <code>va_list</code>，使其指向可变参数列表的第一个参数。</td>
</tr>
<tr>
<td><code>va_arg()</code></td>
<td>从 <code>va_list</code> 中获取下一个参数，并指定其类型。</td>
</tr>
<tr>
<td><code>va_end()</code></td>
<td>清理 <code>va_list</code>，结束可变参数列表的访问。</td>
</tr>
<tr>
<td><code>va_copy()</code></td>
<td>复制一个 <code>va_list</code>（C99 标准引入）。</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="使用步骤">使用步骤</h3>
<p>使用可变参数列表的典型步骤如下：</p>
<ol type="1">
<li>定义一个 <code>va_list</code> 类型的变量。</li>
<li>使用 <code>va_start()</code> 初始化 <code>va_list</code>。</li>
<li>使用 <code>va_arg()</code> 逐个获取参数。</li>
<li>使用 <code>va_end()</code> 清理 <code>va_list</code>。</li>
</ol>
<hr />
<h3 id="示例代码">示例代码</h3>
<p>以下是一个简单的示例，演示如何使用可变参数列表实现一个求和函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可变参数函数，计算任意数量整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    va_list args;  <span class="comment">// 定义 va_list 变量</span></span><br><span class="line"></span><br><span class="line">    va_start(args, count);  <span class="comment">// 初始化 args，使其指向第一个可变参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);  <span class="comment">// 获取下一个 int 类型的参数</span></span><br><span class="line">        total += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(args);  <span class="comment">// 清理 args</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, sum(<span class="number">3</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>));  <span class="comment">// 输出 60</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, sum(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));  <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="详细说明">详细说明</h3>
<h4 id="va_list">(1) <code>va_list</code></h4>
<ul>
<li><p>类型：<code>va_list</code>
是一个类型，用于存储可变参数列表。</p></li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_list args;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="va_start">(2) <code>va_start()</code></h4>
<ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list ap, last_arg)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>作用：</p>
<ul>
<li>初始化 <code>va_list</code>，使其指向可变参数列表的第一个参数。</li>
<li><code>last_arg</code> 是可变参数列表前的最后一个固定参数。</li>
</ul></li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_start(args, count);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="va_arg">(3) <code>va_arg()</code></h4>
<ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">va_arg</span><span class="params">(va_list ap, type)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>作用：</p>
<ul>
<li>从 <code>va_list</code> 中获取下一个参数，并指定其类型。</li>
<li><code>type</code> 是参数的类型（如
<code>int</code>、<code>double</code> 等）。</li>
</ul></li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="va_end">(4) <code>va_end()</code></h4>
<ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_end</span><span class="params">(va_list ap)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>作用：清理
<code>va_list</code>，结束可变参数列表的访问。</p></li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_end(args);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="va_copyc99-引入">(5) <code>va_copy()</code>（C99 引入）</h4>
<ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_copy</span><span class="params">(va_list dest, va_list src)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>作用：</p>
<ul>
<li>复制一个 <code>va_list</code> 变量。</li>
<li><code>dest</code> 是目标变量，<code>src</code> 是源变量。</li>
</ul></li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_list args_copy;</span><br><span class="line">va_copy(args_copy, args);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<h3 id="注意事项">注意事项</h3>
<ol type="1">
<li><strong>固定参数</strong>：
<ul>
<li>可变参数函数必须至少有一个固定参数（如
<code>count</code>），用于确定可变参数的数量或类型。</li>
</ul></li>
<li><strong>参数类型</strong>：
<ul>
<li>使用 <code>va_arg()</code>
时，必须明确指定参数的类型。如果类型不匹配，会导致未定义行为。</li>
</ul></li>
<li><strong>参数数量</strong>：
<ul>
<li>需要确保访问的参数数量不超过实际传递的参数数量，否则会导致未定义行为。</li>
</ul></li>
<li><strong>平台依赖性</strong>：
<ul>
<li>可变参数列表的实现依赖于底层平台，不同平台可能有不同的行为。</li>
</ul></li>
</ol>
<hr />
<h3 id="更复杂的示例">更复杂的示例</h3>
<p>以下是一个更复杂的示例，实现一个类似 <code>printf</code>
的函数，支持格式化输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*format) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*format == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            format++;  <span class="comment">// 跳过 &#x27;%&#x27;</span></span><br><span class="line">            <span class="keyword">switch</span> (*format) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: &#123;</span><br><span class="line">                    <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: &#123;</span><br><span class="line">                    <span class="type">double</span> num = va_arg(args, <span class="type">double</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line">                    <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">putchar</span>(*format);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(*format);</span><br><span class="line">        &#125;</span><br><span class="line">        format++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    my_printf(<span class="string">&quot;Integer: %d, Float: %f, String: %s\n&quot;</span>, <span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结">总结</h3>
<ul>
<li><code>va_list</code> 是处理可变参数列表的核心类型。</li>
<li><code>va_start()</code>、<code>va_arg()</code> 和
<code>va_end()</code> 是处理可变参数的基本宏。</li>
<li>可变参数函数需要至少一个固定参数，用于确定可变参数的数量或类型。</li>
<li>使用可变参数时需要注意参数类型和数量的匹配，避免未定义行为。</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言之排序算法</title>
    <url>/lang-c/c-sort-algorithm/</url>
    <content><![CDATA[<p>本文介绍了七种经典的基于比较的排序算法，其中基础排序算法包括冒泡排序、选择排序和插入排序三种，高级排序包括快速排序、归并排序、堆排序和希尔排序四种。文中首先对每个排序算法分析了其设计思想，接着使用C语言进行代码实现，然后从时间复杂度、空间复杂度和稳定性三个方面对各个算法进行分析，最后对这七种排序算法的性能和适用场景方面进行总结。</p>
<span id="more"></span>
<hr />
<h2 id="概述">概述</h2>
<p>排序算法，就是将一个无序数组内的全部元素，按照递增或递减的顺序重新排列起来的程序实现方法。在结构体中，还有针对结构体数组排序的排序算法。对于多种属性数据对象集合，按照其中的某一个或某一些属性的大小进行排序。例如：对一个公司的员工信息排序时，可以分别按工号、姓名或年龄等属性进行排序。</p>
<p>基础排序算法包括冒泡排序、选择排序和插入排序三种，高级排序包括快速排序、归并排序、堆排序和希尔排序等等。七种常见的、经典的基于”比较”的排序算法：</p>
<ol type="1">
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>堆排序</li>
</ol>
<p>这些排序算法各有各的特点、适用场景，没有一种算法总是最优解。但相对而言比较重要、更常用的是：快速排序、归并排序、堆排序以及插入排序。</p>
<p><strong>如何评估一个排序算法？</strong></p>
<p>从三个维度去分析一个排序算法：<strong>时间复杂度、空间复杂度和稳定性。</strong></p>
<p>下面这张图展示了算法随着数据规模的增大，指令数量和额外内存空间占用，在不同级别下的增加趋势：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202401151901805.png" alt="不同级别大O表示法的增加趋势-图" style="zoom: 50%;" />
</div>
<p>其中，常数级别O(1)和对数级别O(log
n)被认为是特别优秀的，稳定且高效。</p>
<p>而从O(n2)开始，就表示算法随着数据规模的增大而迅速变得低效，在实际应用中要尽量避免选择这样的算法去进行大数据集的处理。</p>
<hr />
<h2 id="冒泡排序">冒泡排序</h2>
<h3 id="算法思想">算法思想</h3>
<ol type="1">
<li><strong>第一轮冒泡排序：</strong>从数组的第一个元素开始，比较相邻的元素。如果第一个元素比第二个元素大，则交换它们的位置。然后，移动到下一对相邻元素，重复这个过程，直到比较最后一对元素。每一轮冒泡排序都会使当前比较序列的最大值到达数组末尾，随后第二轮排序过程中，需要比较的元素就减1。(将尾部最大的元素减去不再排序)</li>
<li><strong>第二轮冒泡排序：</strong>重复第一轮的过程，但这次只比较和交换直到倒数第二个元素（因为最后一个元素已经是最大的了）。在这一轮结束时，倒数第二大的元素会被“冒泡”到倒数第二的位置。</li>
<li>…</li>
<li><strong>结束条件：</strong>
<ol type="1">
<li>在不设置任何额外结束条件的前提下，冒泡排序每一轮都会将未排序序列的最大值”冒泡”到末尾。冒泡排序需要进行固定的(n
- 1)轮！</li>
<li>但实际上在这(n -
1)轮冒泡排序的过程中，只要某一轮完全不存在元素的交换，就说明数组已经完全有序了，排序就可以结束了。</li>
<li>所以我们可以设定一个布尔值来标记此轮冒泡排序是否存在元素交换，如果没有元素交换，直接结束整个排序。这种做法可以优化冒泡排序的性能，尤其是当原数组已基本有序时。</li>
</ol></li>
</ol>
<h3 id="代码实现">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">冒泡排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j ) &#123;      \
    int tmp = arr[i];           \
    arr[i] = arr[j];            \
    arr[j] = tmp;               \
&#125;
void print_arr(int arr[], int len) &#123;
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 冒泡排序
void bubble_sort(int arr[], int len) &#123;
    for (size_t i = 0; i < len-1; i++)
    &#123;
        // 标记在这一次冒泡排序中有没有交换,false表示没有交换
        bool swapped = false;
        for (size_t j = 0; j < len - i- 1; j++) &#123;
            if (arr[j]>arr[j+1])
            &#123;
                SWAP(arr, j, j+1);
                // 发生了交换改变标记
                swapped = true;
            &#125;
        &#125;
        // 在一轮冒泡排序中没有任何交换,则排序已经完成,终止循环
        if (!swapped) &#123;
            break;
        &#125;
        // 打印一轮冒泡排序后数组的元素排列
        print_arr(arr, len);
    &#125;
&#125;
int main(void) &#123;
    // 测试冒泡排序
    int arr[] = &#123; 1,10,2,5,3,4,5,6,3,2 &#125;;
    int len = ARR_LEN(arr);
    bubble_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析">性能分析</h3>
<p><strong>时间复杂度分析：</strong></p>
<p>最佳情况：由于使用了”swapped”标记，所以在最佳情况下，即输入的数组已经是有序的情况下，算法仅需要一次数组遍历就可以确定排序完成。</p>
<p>即：</p>
<p>比较次数： (n - 1)</p>
<p>交换次数： 0</p>
<p><strong>所以最佳情况下的时间复杂度是 O(n)。</strong></p>
<p>最坏情况：</p>
<p>在最坏的情况下（当数组完全逆序时），冒泡排序第一轮需要执行( n - 1)
次比较和交换，第二次执行( n - 2 )次，依此类推，直到最后一次执行 1
次。所以，总的执行次数是等差数列求和：n * ( n - 1) /
2。所以<strong>最坏情况下的时间复杂度是<span
class="math inline">\(O(n^2)\)</span> 。</strong></p>
<p>平均情况：<strong>在平均情况下，时间复杂度也是<span
class="math inline">\(O(n^2)\)</span>
。</strong>虽然不是所有的元素都需要交换，但总体而言，性能接近最坏情况。</p>
<p><strong>空间复杂度分析：</strong></p>
<p>冒泡排序是一种原地排序算法，不需要占用额外内存空间。空间复杂度是O(1)</p>
<p><strong>稳定性分析：</strong></p>
<p>冒泡排序显然是一种稳定的排序算法，因为交换的过程中不会交换任何两个相同的元素。</p>
<hr />
<h2 id="选择排序">选择排序</h2>
<h3 id="算法思想-1">算法思想</h3>
<p>①先假设第一个数是最小的,然后拿这个数去和后面的n个数依次进行比较,
②如果发现有比最小值还小的数 则通过中间变量记录下下标和值,
③然后继续拿这个最小值往后进行比较,如果又发现比最小值还小的值
就执行第②步,直到比完最后一个元素
④最后把存在中间变量的最小值和最小值的下标 和假设的那个最小值进行交换</p>
<h3 id="代码实现-1">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">选择排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j ) &#123;      \
    int tmp = arr[i];           \
    arr[i] = arr[j];            \
    arr[j] = tmp;               \
&#125;
void print_arr(int arr[], int len) &#123;
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 选择排序
void selection_sort(int arr[], int len) &#123;
    /*
    * i表示未排序序列的开头元素
    * 最后一轮选择排序时, 未排序序列的开头元素是数组倒数第二个元素
    * i的每个取值都表示一轮选择排序
    * 也就是选择排序一共执行9趟
    */
    for (int i = 0; i < len - 1; i++) &#123;
        // 不妨直接假设未排序序列的开头i位置元素就是最小值
        int min_index = i;
        // 遍历未排序数组序列,找出真正的最小值下标,此时应遍历最后一个元素
        for (int j = i + 1; j < len; j++) &#123;
            if (arr[j] < arr[min_index]) &#123;
                min_index = j;  // 记录较小值的下标
            &#125;
        &#125;   // for循环结束时，未排序序列的最小值下标就是min_index
        // 交换min_index和下标i的元素
        SWAP(arr, min_index, i);
        // 选择排序一趟打印一次数组
        print_arr(arr, len);
    &#125;
&#125;
int main(void) &#123;
    // 测试选择排序
    int arr[] = &#123; 1,10,2,5,3,4,5,6,3,2 &#125;;
    int len = ARR_LEN(arr);
    selection_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-1">性能分析</h3>
<p><strong>时间复杂度分析：</strong></p>
<p>在分析以比较为核心的排序算法的时间复杂度时，重点关注两点：</p>
<ol type="1">
<li>比较次数</li>
<li>交换元素次数</li>
</ol>
<p>在选择排序当中，无论什么情况下，比较次数和交换元素次数都是一样的：</p>
<ol type="1">
<li>比较次数：</li>
<li>每一轮的比较次数会随着未排序序列减少递减</li>
<li>即一共比较(n - 1) + (n - 2) + … + 1 = n * (n - 1) / 2
次（等差数列求和）</li>
<li>交换元素次数：数组一共有n个元素，除了末尾元素不需要交换，其它元素都需要交换，固定交换(n
- 1)次。</li>
</ol>
<p>将两者加起来就是总的指令执行数量。</p>
<p>除此之外，我们发现选择排序，在数组已经有序、逆序还是完全无序的各种情况下，这些比较和交换都不会减少。</p>
<p>所以用大O表示法，<strong>选择排序的时间复杂度是<span
class="math inline">\(O(n^2)\)</span>，任何情况下都一样。</strong></p>
<p><strong>空间复杂度分析：</strong></p>
<p>选择排序是一种原地排序算法，不需要占用额外内存空间。空间复杂度是O(1)</p>
<p><strong>稳定性分析：</strong></p>
<p>选择排序稳定吗？答：不稳定！</p>
<p>选择排序在每轮中选择最小元素，并与未排序部分的第一个元素交换。如果存在相等的元素，选择排序可能会改变它们的相对顺序。所以选择排序不是稳定的排序算法。</p>
<p>这样的例子随手可举，比如对于一个数组：</p>
<blockquote>
<p>[3, 5, 3’, 2, 8]</p>
</blockquote>
<p>两个3是相同的元素，相对位置是3在前，3’在后。在选择排序后，得出结果是：</p>
<blockquote>
<p>[2, 3’, 3 , 5, 8]</p>
</blockquote>
<p>变成3’在前，3在后。</p>
<hr />
<h2 id="插入排序">插入排序</h2>
<h3 id="算法思想-2">算法思想</h3>
<ol type="1">
<li><strong>以数组的首元素为初始状态：</strong>这个初始状态相当于抓到的第一张牌，它默认就是有序的。</li>
<li><strong>从数组的第二个元素开始遍历：</strong>相当于抓一张牌，然后从小到大整理手牌。</li>
<li><strong>比较与交换：</strong>将新插入的元素和前面的元素逐一比较，如果新插入元素较小，则交换两个元素，直到完全不可交换，则完成一轮排序。</li>
<li><strong>重复步骤2和3，直到步骤2遍历到最后一个元素。</strong></li>
</ol>
<h3 id="代码实现-2">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">插入排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j ) &#123;      \
    int tmp = arr[i];           \
    arr[i] = arr[j];            \
    arr[j] = tmp;               \
&#125;
void print_arr(int arr[], int len) &#123;
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 插入排序
void insert_sort(int arr[], int len) &#123;
    for (int i = 1; i < len; i++)
    &#123;
        for (int j = i - 1; j >= 0; j--) &#123;
            if (arr[j] > arr[j + 1])
            &#123;
                SWAP(arr, j, j + 1);
            &#125;
            else
            &#123;
                break;
            &#125;
        &#125;
        // 打印一轮插入排序后数组的元素排列
        print_arr(arr, len);
    &#125;
&#125;
// 插入排序 优化: 用向后移动腾出插入位置,然后插入实现插入排序
void insertion_sort2(int arr[], int len) &#123;
    // 现在第一个元素就是第一张手牌,从第二个元素开始就是每一次要摸的牌
    // 外层for循环代表每一轮摸到的新手牌, 也就是每一轮插入排序
    for (int i = 1; i < len; i++) &#123;
        // 先记录一下新手牌的值, 便于后续的插入操作
        int tmp = arr[i];
        int j = i - 1;
        for (; j >= 0; j--) &#123;
            if (arr[j] > tmp) &#123; // 注意:不能加=,加了就不是稳定排序算法了
                arr[j + 1] = arr[j];    // 将旧手牌中大于新手牌的所有牌都向后移
            &#125;
            else
            &#123;
                break;  // 只要发现一张旧手牌更小或相等, 就说明已经找到新手牌的插入位置了
            &#125;
        &#125;
        /*
            现在还有一件事情没做:新手牌要插入,需要确定插入位置
            分析: for循环什么时候结束?
            两种情况:
            1.j=-1时,循环结束,说明新手牌是最小的,所以插入到0这个位置,也就是j+1
            2.arr[j] <= tmp 也就是旧手牌更小或相等,此时新手牌放在j+1的位置
        */
        arr[j + 1] = tmp;
        print_arr(arr, len);    // 每一轮摸牌后查看排序后的数组
    &#125;
&#125;
int main(void) &#123;
    // 测试插入排序
    int arr[] = &#123; 1,10,2,5,3,4,5,6,3,2 &#125;;
    int len = ARR_LEN(arr);
    //insert_sort(arr, len);
    insert_sort2(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-2">性能分析</h3>
<p>以版本2为选择排序的实现，假设n为数组的长度，分析以下复杂度：</p>
<p><strong>时间复杂度分析：</strong></p>
<p>最佳情况：</p>
<ol type="1">
<li>当输入的数组已经是排序好的，此时不需要移动任何元素，但比较还是需要的。</li>
<li>比较次数(外层for循环次数)：(n - 1)</li>
<li>移动次数：0</li>
</ol>
<p><strong>所以最佳情况下的时间复杂度是 O(n)。</strong></p>
<p>最坏情况：</p>
<ol type="1">
<li>在最坏的情况下，即数组完全逆序时。</li>
<li>比较和交换的次数是相同的，第一轮需要比较和移动1次，第二轮需要比较和移动2次….最后一个元素需要比较和移动
(n - 1)次</li>
<li>等比数列求和：需要比较和移动各n(n-1)/2次，加起来就是<strong><span
class="math inline">\(T(n^2- n)\)</span></strong></li>
</ol>
<p>所以<strong>最坏情况下的时间复杂度是$ O(n^2)$。</strong></p>
<p>平均情况：</p>
<ol type="1">
<li>在平均情况下，可以粗略的认为移动次数和比较次数是最坏情况除以2</li>
<li><strong>所以在平均情况下，时间复杂度也是$ O(n^2)$。</strong></li>
</ol>
<p><strong>空间复杂度分析：</strong></p>
<p>插入排序是一种原地排序算法，不需要占用额外内存空间。空间复杂度是O(1)</p>
<p><strong>稳定性分析：</strong></p>
<p>插入排序显然也是一种稳定的排序算法，因为对于两个相同的元素，我们始终都不会交换它们的相对位置。</p>
<p>注意：如果判断的条件改成<code>arr[j] &gt;= arr[j + 1]</code>，即在前后元素相等时也交换/移动元素，算法就会变成不稳定的。</p>
<hr />
<h2 id="基础排序算法总结">基础排序算法总结</h2>
<p><strong>选择排序、冒泡排序和插入排序都是基础的排序算法，同样的基于比较而实现，同样的简单直观，同样的原地算法。</strong></p>
<p>这里对它们做一个总结分析：</p>
<ol type="1">
<li><strong>选择排序</strong>在任何情况下时间复杂度都是<span
class="math inline">\(O(n^2)\)</span>，且它是一个不稳定的排序算法。比起作为算法去使用，它更具有教学意义，一般不推荐去使用它。</li>
<li><strong>冒泡排序</strong>和<strong>插入排序</strong>看起来很类似，它们都有最坏和平均情况下<span
class="math inline">\(O(n^2)\)</span>的时间复杂度，都有最优情况下<span
class="math inline">\(O(n)\)</span>的时间复杂度。但<strong>在小数据集或者数据集基本有序的情况下，仍然更推荐使用插入排序。</strong></li>
</ol>
<p>这是因为：</p>
<ol type="1">
<li><strong>插入排序的移动操作比冒泡排序的交换操作效率更高。</strong>在冒泡排序中，每轮冒泡都可能涉及大量交换元素操作，而插入排序用移动操作替代了交换。从指令执行数量上来说，移动操作效率更高。</li>
<li><strong>在数据基本有序的情况下，插入排序往往表现要更好。</strong>这是因为在数据基本有序的情况下，插入排序往往只需要挪动元素很少的次数，而冒泡排序可能还需要，慢慢的一步步的两两交换多次。这里同样存在移动操作和交换操作指令数量上的差异！</li>
</ol>
<hr />
<h2 id="希尔排序">希尔排序</h2>
<h3 id="算法思想-3">算法思想</h3>
<p><strong>希尔排序(Shell
Sort)</strong>是美国计算机科学家，<strong>唐纳德·希尔</strong>在1959年提出的排序算法。</p>
<p>希尔排序是插入排序的一种改进和扩展，它基于插入排序的两个特点来进行改进：</p>
<ol type="1">
<li>插入排序的缺点就是当较小元素处于末尾时，需要移动元素的次数过多，希尔排序通过比较和交换不相邻的元素来改进插入排序，可以一次性将后面的小元素向前面移动多个位置，从而提高效率。</li>
<li>插入排序在排序基本有序的序列时，效率很高。<strong>可以将希尔排序理解成——先通过几次分组的、较小的组间插入排序将原数组变得有序，最后再进行一次序列基本有序的完整插入排序。</strong></li>
</ol>
<p>整个希尔排序的过程，可以看成多个人轮流抓牌 –&gt; 整理手牌 –&gt;
抓牌，然后再把手牌合并变成更少的人抓牌，直到回归一个人抓牌(直到变成插入排序)。</p>
<h3 id="代码实现-3">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">希尔排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j ) &#123;      \
    int tmp = arr[i];           \
    arr[i] = arr[j];            \
    arr[j] = tmp;               \
&#125;
void print_arr(int arr[], int len) &#123;
    for (int i = 0; i < len; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 希尔排序: 缩小增量排序, 其实就是多人摸牌, 逐渐减少摸牌人数
// 希尔排序中, 增量序列的设计非常重要,这里采取简单的gap序列: 长度减半..一直减半,直到为1
// gap为1时就是一个在数组元素基本有序情况下的,插入排序
void shell_sort(int arr[], int len) &#123;
    // 第一个元素是第一个人的初始手牌,一直到第gap个元素都是初始手牌
    int gap = len >> 1;
    while (gap > 0) &#123;
        // 外层for的i仍然代表新摸到的手牌的下标,i从gap开始,直到摸完整个数组元素
        for (int i = gap; i < len; i++) &#123;
            // 先记录一下新手牌的值, 便于后续的插入操作
            int tmp = arr[i];
            int j = i - gap;    // 代表每一个人旧手牌的最后一张牌
            for (; j >= 0; j -= gap) &#123;
                // 内层for代表 每个人每摸到一张新手牌,都会和原本的旧手牌比较,但由于gap存在,所以需要减去gap
                if (arr[j] > tmp) &#123; // 注意:不能加=,加了就不稳定了
                    arr[j + gap] = arr[j];  // 将旧手牌中大于新手牌的所有牌都向后移
                &#125;
                else
                &#123;
                    break;  // 只要发现一张旧手牌更小或相等, 就说明已经找到新手牌的插入位置了
                &#125;
            &#125;
            arr[j + gap] = tmp;
        &#125;
        print_arr(arr, len);    // 每一轮希尔排序后查看数组排序结果
        gap >>= 1; // 每一轮希尔排序,增量都减半
    &#125;
&#125;
int main(void) &#123;
    // 测试希尔排序
    int arr[] = &#123; 16, 1, 45, 23, 99, 2, 18, 67, 42, 10 &#125;;
    int len = ARR_LEN(arr);
    shell_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-3">性能分析</h3>
<p><strong>时间复杂度：</strong></p>
<p>希尔排序的时间复杂度，和选择的增量序列有密切的关联：</p>
<p>若使用希尔本人提出的减半序列，时间复杂度通常会小于<span
class="math inline">\(O(n^2)\)</span>，但在最坏情况也会接近<span
class="math inline">\(O(n^2)\)</span>。</p>
<p><strong>空间复杂度分析：</strong></p>
<p>希尔排序是一种原地排序算法，不需要占用额外内存空间。空间复杂度是O(1)。</p>
<p><strong>稳定性分析：</strong></p>
<p>希尔排序显然不是一种稳定的排序算法，因为它先分组再插入排序的方式，使得相同元素可能会由于分组不同改变位置。</p>
<p>比如：</p>
<p>假设我们有一个数组 [4a, 3, 4b, 2, 1]，选择的增量是3…1</p>
<p>那么第一轮希尔排序后的结果就是：[2, 1, 4b, 4a,
3]，很明显这不是稳定的排序算法。</p>
<blockquote>
<p><strong>希尔排序的地位如何？</strong></p>
<p>希尔排序的实现比起插入排序更加复杂，思路更加不直观，并且还牺牲了算法的稳定性，从而换取了一定的性能提升。</p>
<p>但总得来说，希尔排序处在一共尴尬的境地：在小数据集的情况下，插入排序的性能和希尔排序相当甚至会更优。</p>
<p>在大数据集的情况下，希尔排序的性能又不及归并、快排等高级排序算法。希尔排序更像是一个介于简单排序算法和高级排序算法之间的一个桥梁，不需要作为重点去学习。</p>
</blockquote>
<hr />
<h2 id="归并排序">归并排序</h2>
<h3 id="算法思想-4">算法思想</h3>
<p>归并排序的分治策略思路大体上如下：</p>
<ol type="1">
<li>分解大问题：将一个大数组分解成两个或更多的子数组，直到每个子数组足够小，通常是直到每个子数组只包含一个元素或者是空数组。</li>
<li>解决子问题：数组小到只有一个元素或者没有元素，那自然是”有序数组”，所以这些子问题可以视为被解决了。</li>
<li>合并：归并排序的核心在于合并步骤，也可以叫”归并”操作，它会将两个有序的子数组合并成一个大的有序数组。这个过程通常需要反复比较元素，比较复杂。</li>
</ol>
<p><strong>分解过程：</strong></p>
<p>可以采用递归作为手段来实现分治的过程。首先存在一个递归分解的过程，递归的思路参考如下：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312151131058.png" alt="归并排序-递归过程" style="zoom: 40%;" />
</div>
<p>那么这个递归的递归体和递归的出口是什么呢？</p>
<p>很明显，递归分解的过程会不停地将大数组分解成两个小的子数组，这个分解的过程会根据大数组的左右界限求一个中间索引，然后将大数组尽量等分为两份。所以，递归分解的函数，至少需要三个参数：</p>
<ol type="1">
<li>递归分解的数组arr</li>
<li>数组分解的左下标left</li>
<li>数组分解的右下标right</li>
</ol>
<p>此递归分解的函数会将arr数组的[left, right]区间分解成两个小数组。</p>
<p><strong>于是递归的出口就很明显了是：left &gt;=
right，这表示子数组缩小到只包含一个元素或没有元素时，递归将停止。</strong></p>
<p>在计算中索引时，我们将采用一种优化的方案：</p>
<ol type="1">
<li>一般情况下，可以直接使用 “(left + right) &gt;&gt; 1”
来直接求中间索引。</li>
<li>但C语言中int类型可能只占2个字节，此时int类型取值范围较小，上面的表达式可能会出现数据溢出失真。为避免这种情况发生，我们可以采用表达式<strong>“left
+ (right - left &gt;&gt; 1)”</strong>去求中间索引。</li>
</ol>
<p><strong>合并过程：</strong></p>
<p>合并操作的思路是：</p>
<ol type="1">
<li>从左到右轮流比较待合并子数组中的元素，把比较过程中的较小元素存入临时数组中，直到某个子数组元素为空。</li>
<li>然后再将存在剩余元素的子数组中的所有元素，轮流放入临时数组中。</li>
<li>最后把临时数组中的元素，复制回原数组。</li>
</ol>
<p>注：临时数组的长度和原数组是一致的，且合并过程共有同一套下标索引。</p>
<h3 id="代码实现-4">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">归并排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define ARR_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
// 打印数组的函数
void print_arr(int arr[], int left, int right) &#123;
    for (int i = left; i <= right; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
/*
* 合并的思路:
* 1.把左右子数组中元素按照顺序合并到临时数组中,过程类似"穿针引线"
* 2.将排好序的临时数组元素按照下标赋值给原数组
* 注：临时数组和原数组共有一套下标
* 传入函数逻辑上的左右子数组是有序的,相当于合并两个有序的左右子数组
*/
static void merge(int arr[], int left, int mid, int right, int* temp) &#123;
    /*
    * tmp_idx: 用于存放合并结果的临时数组的开始下标
    * left_idx: 左子数组的开始下标
    * right_idx: 右子数组的开始下标
    */
    int temp_idx = left, left_idx = left, right_idx = mid + 1;
    // 只要左右子数组同时还有元素
    while (left_idx <= mid && right_idx <= right) &#123;
        // 逐对比较左右子数组的元素, 按照从小到大放入临时数组
        // <=判断不会改变相同元素的相对位置,是稳定算法。反之则不是稳定算法
        if (arr[left_idx]<=arr[right_idx])
        &#123;
            temp[temp_idx++] = arr[left_idx++];
        &#125;
        else
        &#123;
            temp[temp_idx++] = arr[right_idx++];
        &#125;
    &#125;
    // while结束时，左右子数组必然有一个没有元素了,此时另一个数组必然还有元素
    // 也就是说只会有一个数组是空的
    // 但我们无法确定是哪个数组没有元素了
    // 所以我们都判断一下将左右子数组还剩余的元素取出来
    while (left_idx <= mid) &#123;
        temp[temp_idx++] = arr[left_idx++];
    &#125;
    while (right_idx <= right) &#123;
        temp[temp_idx++] = arr[right_idx++];
    &#125;
    // 将临时数组中已排序好的元素复制到原始数组中
    for (int i = left; i <= right; i++)
    &#123;
        arr[i] = temp[i];
    &#125;
    // 打印此一轮归并排序的元素
    print_arr(arr, left, right);
&#125;
/*
* 辅助函数,实现对[left, right]范围内的数组递归分解合并
* left表示递归分解的区间起点,right表示递归分解区间的终点,是一个闭区间
* 递归分解的思路是:
* 对[left, right]区间元素的排序,可以分解成:
* [left, mid]区间,和[mid + 1, right]区间的排序合并
* 递归的出口是:
* 如果区间仅有一个元素或没有元素,递归结束
*/
static void divide_merge(int arr[], int left, int right, int* temp) &#123;
    // 递归的出口
    if (left>=right)
    &#123;
        return;
    &#125;
    // 递归体
    // 计算中间索引
    int mid = left + (right - left >> 1);
    divide_merge(arr, left, mid, temp);
    divide_merge(arr, mid + 1, right, temp);
    /*
     * 归并，归并排序的核心操作
     * 需要一个临时数组完成此操作
     * 这个临时数组至少要和原先的数组一般大
     * 有两种方案：
     * 1.用全局变量数组或局部变量,该方式简洁易实现,无需考虑内存回收
     *   但缺点是
     *   a.必须编译时期确定数组长度,无法运行时期动态分配
     *   b.栈区和数据段都无法创建长数组,在大数据集下容易产生溢出错误
     * 为了解决这两个缺点,我们可以在堆上动态分配数组
     *   但同样也有缺点:
     *   a.内存管理风险
     *   b.动态分配数组会带来额外性能开销
    */
    merge(arr,left,mid,right,temp);
&#125;
// 归并排序
void merge_sort(int arr[], int len) &#123;
    int* temp = calloc(len, sizeof(int));
    if (temp==NULL)
    &#123;
        printf("Error: malloc failed in merge_sort.\n");
        exit(1);
    &#125;
    // 将整个数组进行递归分解合并,即完成归并排序
    divide_merge(arr, 0, len - 1, temp);
    // 不要忘记free释放资源
    free(temp);
&#125;
int main(void) &#123;
    // 测试归并排序
    int arr[] = &#123; 8, 3, 2, 6, 9, 7, 1, 0, 4, 5 &#125;;
    int len = ARR_LEN(arr);
    merge_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-4">性能分析</h3>
<p><strong>时间复杂度：</strong></p>
<p>无论原始数组处在什么状态，归并排序都会按照既定步骤分解、合并。所以<strong>在最好，最坏，平均情况下，归并排序的时间复杂度都是一样的，都是<span
class="math inline">\(O(nlogn)\)</span>。</strong></p>
<p>归并排序的时间复杂度分析需要考虑它的两个主要操作，分解和合并：</p>
<ol type="1">
<li>分解过程也就是递归调用的过程，这个过程大概分解了<span
class="math inline">\(log_2{n}\)</span>次（每次都将数组折半，也就是递归的深度）</li>
<li>在合并的过程中，需要遍历并比较子数组的元素，然后将它们按顺序复制回原数组。每次合并操作的时间复杂度都是O(n)，因为它涉及到整个数组的遍历。合并的次数和分解的次数是一样的，都是log2n次，所以对于合并操作，总的时间复杂度是<span
class="math inline">\(O(nlogn)\)</span>。</li>
</ol>
<p>综合起来，时间复杂度就是<span
class="math inline">\(O(nlogn)\)</span>。</p>
<p><strong>空间复杂度：</strong></p>
<p>归并排序显然不是一个原地算法。它需要额外的内存空间：</p>
<ol type="1">
<li>需要一个与原始数组大小相同的，长度是n的辅助数组来进行合并操作。</li>
<li>递归调用，占用额外的栈空间。因为每次递归调用都会将数组分为两个大致相等的部分，所以每次都将问题的规模减半。递归深度大致是<strong><span
class="math inline">\(log_2{n}\)</span></strong>。</li>
</ol>
<p><strong>所以空间复杂度是O(n)。</strong></p>
<p><strong>稳定性：</strong></p>
<p><strong>归并排序是稳定的排序算法。</strong>这是因为如果两个元素相等，归并排序不会改变它们的相对顺序。</p>
<hr />
<h2 id="快速排序">快速排序</h2>
<p><strong>快速排序(Quick
Sort)</strong>是一种建立在<strong>分区(partition)操作</strong>上的，非常高效的排序算法，由托尼·霍尔在1960年代提出。快速排序同样是分治思想的典型应用，由于其优秀的性能和较为简单的实现，它通常是实际应用中，<strong>大数据集下</strong>首选的排序算法。</p>
<p>通过分区，快速排序实现了对数组的分解，大体思路是：</p>
<ol type="1">
<li>分解大问题：挑选一个基准值(pivot)，然后通过一轮遍历将数组分成两个子数组：一个包含所有小于等于基准的元素，另一个包含所有大于基准的元素。这个过程就是分区操作，该过程结束后，基准值一定位于其排序最终位置上。</li>
<li>解决子问题：递归地对两个子数组进行快速排序。由于这两个子数组都比原始数组小，这就是解决子问题的过程。如果子数组足够小，可以直接认定它就是有序的。</li>
<li>合并：快速排序的操作都是在原数组上直接进行的，所以快速排序的合并步骤实际上并不需要做任何操作，只有解决子问题，原数组就是直接排好序的。</li>
</ol>
<p>在具体到实现时，快速排序根据分区操作的不同，可以分为两种：</p>
<ol type="1">
<li>单向分区</li>
<li>双向分区</li>
</ol>
<p>其中双向分区泛用性最强，也最常用。</p>
<h3 id="单向分区">单向分区</h3>
<p><strong>所谓单向分区，指的是快速排序算法在分区的过程中，元素比较和交换的操作是单向进行的，也就是从数组的一端进行到另外一端。</strong></p>
<p>单向分区快速排序算法，具体而言，它的思路是：</p>
<ol type="1">
<li>选择一个基准值（pivot），可以是随机选择，也可以是直接选首尾元素。选定基准值后，一般会将pivot交换到数组末尾，这样做可以简化分区操作。</li>
<li>设置一个索引(比如叫idx)来追踪小于基准值的元素应该插入的位置，一开始idx索引指向数组的首元素。</li>
<li><strong>遍历数组进行分区操作：</strong>
<ol type="1">
<li>从数组首元素开始遍历整个数组</li>
<li>如果元素小于基准值，则将该元素与idx位置的元素交换，idx索引加1。</li>
<li>如果元素大于或等于基准值，则不做任何操作，继续遍历下一个元素。</li>
</ol></li>
<li>当遍历到最后一个元素，也就是pivot时，遍历结束：
<ol type="1">
<li>最后将pivot元素和此时idx索引元素进行交换，完成这一轮分区操作。</li>
<li>此时pivot左侧的元素一定都是小于基准值的。</li>
<li>pivot右侧的元素一定都是大于等于基准值的。</li>
</ol></li>
<li>对基准值左右两边的子数组递归地执行以上步骤，直到每个子数组的大小减少到1或0，此时数组就被完全排序了。</li>
</ol>
<h3 id="双向分区">双向分区</h3>
<p>比起单向分区，双向分区是更常用的快排分区策略，<strong>一般而言当提起快速排序，指的都是双向分区策略的快速排序。</strong></p>
<p><strong>所谓双向分区，指的是在分区过程中，元素比较和交换操作的方向是，同时从数组的两端向中间逼近的。</strong></p>
<p>双向分区快速排序算法，具体而言，它的思路是：</p>
<ol type="1">
<li><p>选择基准值pivot，基准值可以是一个随机元素，也可以选择一个固定元素。然后将基准值元素和首元素交换，这样做的目的是为了将交换元素操作优化成一个赋值操作。<strong>并且要将基准值存储起来。</strong></p></li>
<li><p>设置两个索引 low 和 high ：</p>
<ol type="1">
<li><p>索引 low
一开始指向数组首元素，它的含义是指示小于基准值的元素应该置于的位置。</p></li>
<li><p>索引 high
一开始指向数组尾元素，它的含义是指示大于等于基准值的元素应该置于的位置。</p></li>
</ol></li>
<li><p>率先移动索引high，它从尾元素开始向左移动，目标是找到第一个小于基准值的元素：</p>
<ol type="1">
<li><p>找到该元素后，直接将该元素赋值给low索引位置，也就是覆盖掉基准值。</p></li>
<li><p><strong>赋值结束后，low索引和high索引都不需要移动。</strong></p></li>
</ol></li>
<li><p>然后向右移动索引 low，找到第一个大于等于基准值的元素：</p>
<ol type="1">
<li><p>找到该元素后，直接将该元素赋值给high索引位置</p></li>
<li><p><strong>赋值结束后，low索引和high索引都不需要移动。</strong></p></li>
</ol></li>
<li><p>重复过程3和4，直到索引high和low相遇。最后将基准值放入它们相遇的位置。</p></li>
<li><p>于是分区就结束了，基准值到达了排序的最终位置，基准值左边都是小于基准值的元素，右边都是大于等于基准值的元素。</p></li>
<li><p>对基准值左右两边的子数组递归地执行以上步骤，直到每个子数组的大小减少到1或0，此时数组就被完全排序了。</p></li>
</ol>
<h3 id="代码实现-5">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">快速排序算法单向分区C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#define ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP(arr, i, j) &#123;   \
    int tmp = arr[i];       \
    arr[i] = arr[j];        \
    arr[j] = tmp;           \
&#125;
// 打印数组的函数
void print_arr(int arr[], int left, int right) &#123;
    for (int i = left; i <= right; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 分区核心操作实现,返回一轮快排选择的pivot的下标
int partition(int arr[], int left, int right) &#123;
    // 1.随机选择一个基准值,然后把它先放到数组末尾
    int pivot_idx = left + rand() % (right - left + 1); // 得到一个[left, right]范围内的随机索引
    int pivot = arr[pivot_idx];
    SWAP(arr, pivot_idx, right);
    // 2.设置一个partition_idx索引,指示小于pivot的元素应该插入的位置
    // 同时该索引最终表示分区的界限索引,所以命名为partition_idx
    int partition_idx = left;
    // 3.遍历整个数组,当元素小于pivot时,将它和partition_idx位置元素交换,partition_idx加1
    // 希望遍历结束时，i指向数组末尾的pivot，所以i < right
    for (int i = left; i < right; i++) &#123;
        if (arr[i] < pivot) &#123;
            SWAP(arr, i, partition_idx);
            partition_idx++;
        &#125;
    &#125;
    // 4.遍历结束后,将pivot元素(最后一个元素)交换到partition_idx位置
    SWAP(arr, right, partition_idx);
    printf("此一轮分区操作,选择的pivot是: %d\n分区结束后的数组是: ", pivot);
    print_arr(arr, left, right);
    // 5.返回基准值的位置索引
    return partition_idx;
&#125;
/*
* 辅助函数
* 用于对对[left, right]区间中的元素进行递归分区操作
*/
void partition_recursion(int arr[], int left, int right) &#123;
    // 递归出口
    if (left >= right) &#123;
        return;
    &#125;
    // 递归体
    int idx = partition(arr, left, right);  // 分区操作,找到pivot元素的下标位置
    partition_recursion(arr, left, idx - 1);
    partition_recursion(arr, idx + 1, right);
&#125;
void quick_sort_one_way(int arr[], int len) &#123;
    // 初始化随机数生成器,time(NULL)获取当前时间戳
    // 用于生成随机索引
    srand(time(NULL));
    // 调用辅助函数进行递归分解
    partition_recursion(arr, 0, len - 1);
&#125;
int main(void) &#123;
    // 测试单向分区快速排序
    int arr[] = &#123; 8,3,2,6,9,5 &#125;;
    int len = ARR_SIZE(arr);
    quick_sort_one_way(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<details>
<summary>
<font size="4" color="orange">快速排序算法双向分区C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#define ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
// 打印数组的函数
void print_arr(int arr[], int left, int right) &#123;
    for (int i = left; i <= right; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 快速排序的核心操作: 双向分区, 也就是确定pivot的最终位置
// 挑选一个基准值,通过双向分区操作,决定最终的位置,最终位置就是基准值排好序的位置
static int partition(int arr[], int left, int right) &#123;
    // 1.为了简化实现,直接挑选首元素为基准值(因为基准值要交换到开头,所以直接挑选首元素作为基准值,可以减少一步交换)
    int pivot = arr[left];
    // 2.初始化两个索引low和high,分别指向数组两端
    int low = left, high = right;
    // 3.循环遍历这个数组区间
    while (low < high) &#123;    // 两个索引没有相遇就继续循环
        // 在两个索引没有相遇的情况下,high索引用于寻找比基准值小的元素
        while (low < high && arr[high] >= pivot) &#123;
            high--;
        &#125;   // while循环结束时,要么两个索引相遇了,要么high索引已经找到了一个比基准值小的元素
        arr[low] = arr[high];   // 将这个比基准值小的元素覆盖到low位置
        //low++;    该行语句不能加，因为若此时两个索引相遇结束while，low++将导致相遇的索引不再相遇
        //
        // 在两个索引没有相遇的情况下,low索引用于寻找比基准值大和相等的元素
        while (low < high && arr[low] < pivot) &#123;
            low++;
        &#125;   // while循环结束时,要么两个索引相遇了,要么low索引已经找到了一个比基准值大或相等的元素
        arr[high] = arr[low];   // 将这个比基准值大或相等的元素覆盖到high位置
        //high--;   该行语句不能加，因为若此时两个索引相遇结束while，high--将导致相遇的索引不再相遇
        //
    &#125;   // while循环结束时,说明low和high索引相遇,此时该位置就是pivot应该放置的位置
    arr[low] = pivot;
    printf("此一轮分区操作选择的pivot = %d\n", pivot);
    print_arr(arr, left, right);
    return low;
&#125;
// 对[left, right]区间进行递归分区操作
void partition_recursion(int arr[], int left, int right) &#123;
    // 递归出口
    if (left >= right) &#123;
        return;
    &#125;
    // 递归体
    int idx = partition(arr, left, right);  // 分区操作,找到pivot下标位置
    partition_recursion(arr, left, idx - 1);
    partition_recursion(arr, idx + 1, right);
&#125;
void quick_sort_two_way(int arr[], int len) &#123;
    partition_recursion(arr, 0, len - 1);
&#125;
int main(void) &#123;
    int arr[] = &#123; 8,3,2,6,9,5 &#125;;
    int len = ARR_SIZE(arr);
    // 测试双向分区-快速排序
    quick_sort_two_way(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-5">性能分析</h3>
<p><strong>时间复杂度：</strong></p>
<p>一般提起快速排序算法，不管采取单双向哪一种分区策略，都只会说它的时间复杂度是O(nlogn)级别。</p>
<p><strong>空间复杂度：</strong></p>
<p>快速排序，无论什么分区策略，都不需要额外的数组空间来辅助排序，但考虑到需要使用递归来实现算法。</p>
<p><strong>在最佳和平均情况下，递归深度大约是<span
class="math inline">\(log_2{n}\)</span>，空间复杂度是<span
class="math inline">\(O(logn)\)</span></strong></p>
<p>但如果是在最坏情况下，递归深度接近n，此时空间复杂度为<span
class="math inline">\(O(n)\)</span></p>
<p><strong>稳定性：</strong></p>
<p>快速排序是一种不稳定的排序算法，无论选取什么分区方案，快速排序都有可能改变两个相同元素的相对位置。</p>
<hr />
<h2 id="堆排序">堆排序</h2>
<p><strong>堆排序(HeapSort)</strong>是一种高效的排序算法，它利用了堆这种数据结构来实现排序。</p>
<p>堆是一种特殊的完全二叉树，它满足以下性质：</p>
<ol type="1">
<li>大顶堆(最大堆)：每个父节点的值都大于或等于其子节点的值<strong>(递归定义)</strong>。这意味着树的根节点（堆顶）是所有节点中的最大值。</li>
<li>小顶堆(最小堆)：每个父节点的值都小于或等于其子节点的值<strong>(递归定义)</strong>。这意味着树的根节点（堆顶）是所有节点中的最小值。</li>
</ol>
<p>在实现堆排序时，一般选择使用大顶堆。</p>
<h3 id="算法思想-5">算法思想</h3>
<p>堆排序的过程可以分为两个主要步骤：</p>
<ol type="1">
<li>构建一个大顶堆</li>
<li>堆排序过程</li>
</ol>
<p>下面分别解释一下这两个过程：</p>
<h4 id="步骤一构建一个大顶堆">步骤一：构建一个大顶堆</h4>
<p>首先，堆排序基于一个大顶堆来实现排序并不意味着需要借助额外的数据结构，而是只需要把原数组在逻辑上看成是一个大顶堆即可。</p>
<p>在这个过程中，数组首元素(下标为0的元素)就是完全二叉树的根结点，而一个下标为i的元素，它的两个子结点是：</p>
<ol type="1">
<li><strong>2i + 1</strong></li>
<li><strong>2i + 2</strong></li>
</ol>
<p>比如：根结点元素下标为0，它的两个子结点就是下标为1和2的元素。而下标为1的元素，它的两个子结点就是下标为3和4的元素。</p>
<p>以数组[4, 10, 3, 5,
1]为例，这个数组可以构建下面一棵完全二叉树<strong>(还不是大顶堆，因为结点数据大小关系不对)</strong>：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312121727197.png" alt="数组-构建完全二叉树" style="zoom: 33%;" />
</div>
<p>构建好这样一棵完全二叉树后，就需要调整元素的位置，使得它成为一个大顶堆。具体来说需要这么做：</p>
<p>从数组尾元素开始，找到第一个非叶子结点<strong>（因为叶子结点可以视为已经是大顶堆了）</strong>。遍历这个非叶子结点的左右子树，比较元素的大小关系，以决定是否需要调整元素位置。这个过程会自下而上的将一棵完全二叉树调整成为一个大顶堆，这个过程就是<strong>堆化(heapify)</strong></p>
<p><strong>注意：在堆化的过程中，一旦进行了子树结点和父节点的交换操作以后，就需要再判断以该子树结点为父节点的二叉树是否为大顶堆，从而决定是否再次进行调整！！！</strong></p>
<p>那么哪一个元素是这棵树的最后一个非叶子结点（从尾元素开始的第一个非叶子结点）？</p>
<p>我们可以假设最后一个非叶子结点的下标是<code>i</code>，它一定有左子树，且左子树的下标是<code>2i + 1</code>，这个下标不能超出数组的索引界限，假如数组长度是<code>len</code>，下标最大是<code>len-1</code></p>
<p>计算过程如下：</p>
<p><code>2i + 1 &lt;= len - 1 i &lt;= (len - 2) / 2</code></p>
<p>最后一个非叶子结点就是取等号的位置，也就是<code>(len - 2 ) / 2</code>索引位置就是数组这棵树的最后一个结点。</p>
<p>比如在本案例中：</p>
<ol type="1">
<li>第一个非叶子结点是下标为1的元素10，遍历它的左右子树即下标为3和4的结点，发现符合大顶堆的定义。此父结点不需要调整。</li>
<li>第二个非叶子结点就是根结点，下标为0的元素4，遍历它的左右子树即下标为1和2的结点，发现左子树的10比4大，于是交换它们。这样交换后的数组就变成了：[10,
4, 3, 5, 1]。</li>
<li>但这样不算完，下标为0的父节点和下标为1的左子树交换了元素，所以就需要再次判断下标为1的左子树是否还符合大顶堆定义，此时发现已经不符合了。所以再次调整，交换元素4和5。此时被交换元素的结点已经是叶子结点了，没有左右子树，这样整个数组才完全构建成了一个大顶堆。数组堆化结束最终为：[10,
5, 3, 4, 1]</li>
</ol>
<p>经过上述调整，此时该数组就可以在逻辑上看成一个大顶堆。如下图所示：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312122153960.png" alt="数组-构建大顶堆过程示意图" style="zoom: 40%;" />
</div>
<p>这样第一步，构建大顶堆就完成了。</p>
<h4 id="步骤二堆排序过程">步骤二：堆排序过程</h4>
<p>基于一个大顶堆，知道此时数组的首元素(也就是堆顶元素)，一定是此数组的最大值，那这就好办了。</p>
<p>所谓堆排序的过程，也就是通过不断将堆顶元素移动到数组末尾，再重构大顶堆(重新堆化)，再移动堆顶元素….重复的过程。</p>
<p>具体来说步骤就是：</p>
<ol type="1">
<li>将堆顶元素和堆末尾的元素交换，第一次也就是数组的首尾元素进行交换，这样数组的最大值就到了数组的末尾。于是数组就变成了[1,
5, 3, 4, 10]</li>
<li>将堆的逻辑大小减少1，数组就变成[1, 5, 3, 4]</li>
<li>重构大顶堆(重新堆化)。
<ol type="1">
<li>在上述过程中，数组末尾元素被去掉了，首元素是新赋值的。所以如果新数组逻辑上不是一个大顶堆，只可能是首元素违反了规则。</li>
<li>此时只需要比较首元素和左右子树结点的大小，然后进行调整就可以重新堆化。</li>
<li><strong>不要忘记上述过程如果出现了元素交换，那么就需要去判断被交换的左右子树是否还符合大顶堆的规则。</strong></li>
<li>在本案例中，首先需要将元素5和元素1交换，将1交换到左子树后发现左子树不再是一个大顶堆，于是就继续交换元素1和4。最终数组重新堆化，变成了[5,
4, 3, 1]</li>
</ol></li>
<li>重复过程1~3，直到堆的大小减少为1，堆排序结束。</li>
</ol>
<p>这一过程，可以用下图来描述：</p>
<div data-align="center">
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/202312122257230.png" alt="堆排序过程示意-图" style="zoom: 33%;" />
</div>
<p><strong>于是第二步堆排序过程就完成了，最终就在原地得到了一个排序好的数组。</strong></p>
<p>以上两个步骤合起来，就是一个完整的堆排序过程，下面就可以基于这个思路来实现堆排序。</p>
<h3 id="实现思路">实现思路</h3>
<p>上述堆排序算法在具体实现时，要分为两个步骤：</p>
<ol type="1">
<li>将待排序的原始数组，在逻辑上进行第一次堆化的操作</li>
<li>将大顶堆的根结点元素移到数组末尾，交换首尾元素，逻辑上堆大小减1，以新的根结点进行堆化操作。</li>
</ol>
<p>这两个步骤中的核心操作逻辑都是——堆化。</p>
<p>于是我们把堆化这个操作，提取出一个函数，那么这个函数应该给什么参数呢？怎么写呢？</p>
<p>堆化的过程，其实就是自父结点开始，向下检查左右子树和这个父结点大小关系的过程：</p>
<ol type="1">
<li>如果左子树大于父结点，那么交换左子树和父结点</li>
<li>如果右子树大于父结点，那么交换右子树和父结点</li>
<li><strong>如果出现了交换，那么被交换的左子树或右子树就要重新进行堆化操作。</strong></li>
<li>如果根结点已经是最大值(相等的最大值也算)，没有交换，那么堆化结束。</li>
</ol>
<p>为什么这么设计堆化函数呢？为了让堆排序两个过程，都能复用这个函数：</p>
<ol type="1">
<li>在第一个步骤中，我们只需要从原数组的最后一个非叶子结点开始，将每一个非叶子结点作为父结点，逐一堆化。最终将根结点作为父结点传入，完成整个堆化过程。</li>
<li>在第二个步骤中，会将已生成的大顶堆的首尾元素交换，并将尾元素(最大值)移除，堆结点数量减1。此时如果这个堆不是大顶堆了，只可能是首元素(原本的尾元素)影响了大顶堆的性质。于是我们就以这个首元素为父结点，重新进行堆化。</li>
</ol>
<p>那么这个堆化函数的声明就应该如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> heap_len, <span class="type">int</span> idx)</span>;</span><br></pre></td></tr></table></figure>
<p>解释一下：</p>
<ol type="1">
<li><strong>arr参数：</strong>待堆化的原数组</li>
<li><strong>heap_len参数：</strong>逻辑上堆结点的数量。
<ol type="1">
<li>一开始它就是数组的长度</li>
<li>每一轮堆排序会去掉一个最大值，逐渐减少</li>
<li>直到堆的逻辑大小减少为1，堆排序就结束了，原数组排序完成。</li>
</ol></li>
<li><strong>idx参数：</strong>可能违反大顶堆规则的父结点的下标。</li>
</ol>
<p>把这个核心逻辑函数分析清楚了，代码实现就很容易了。</p>
<h3 id="代码实现-6">代码实现</h3>
<details>
<summary>
<font size="4" color="orange">堆排序算法C语言实现</font>
</summary>
<pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
#define SWAP_ELEMENT(arr, i, j)&#123;    \
    int tmp = arr[i];       \
    arr[i] = arr[j];        \
    arr[j] = tmp;       \
&#125;
void print_arr(int arr[], int n) &#123;
    for (int i = 0; i < n; i++) &#123;
        printf("%d ", arr[i]);
    &#125;
    printf("\n");
&#125;
// 该函数会把以root_idx索引元素为根结点的
// 逻辑长度是tree_len的一棵完全二叉树arr，构建成一个大顶堆
static void heapify(int arr[], int tree_len, int root_idx) &#123;
    /*
        堆化操作必然是需要循环来完成的
        如果对于某个循环,既不清楚循环的次数,循环结束的条件也不太好找到
        那么可以先写一个死循环, 然后具体到代码中再用break,return等结束循环
    */
    while (1) &#123;
        // 根据根节点的下标,先计算出左右子树的下标
        int lchild_idx = (root_idx << 1) + 1;
        int rchild_idx = (root_idx << 1) + 2;
        int max_idx = root_idx;     // 先假设根节点就是最大值
        if (lchild_idx < tree_len && arr[lchild_idx] > arr[max_idx]) &#123;
            // 如果左子树存在且左子树值比假设的最大值要大,那么左子树下标就是新的最大值下标
            max_idx = lchild_idx;
        &#125;
        if (rchild_idx < tree_len && arr[rchild_idx] > arr[max_idx]) &#123;
            // 如果右子树存在且右子树值比假设的最大值要大,那么右子树下标就是新的最大值下标
            max_idx = rchild_idx;
        &#125;
        if (max_idx != root_idx) &#123;
            // 交换左右子树较大者和根节点的值
            SWAP_ELEMENT(arr, max_idx, root_idx);
            // 此时max_idx结点的值就是以前根节点的值,此时由于数据发生了改变,max_idx结点的树就不一定是大顶堆了
            // 所以接下来要以max_idx为根节点,继续构建大顶堆
            root_idx = max_idx;
        &#125;
        else &#123;
            // 不需要交换了,说明以root_idx为根节点的树已经是大顶堆了
            break;
        &#125;
    &#125;
&#125;
// 第一次将数组构建成大顶堆，自下而上将每一个非叶子结点构建大顶堆
static void first_build_heap(int arr[], int len) &#123;
    int last_idx = len - 2 >> 1;    //最后一个非叶子结点的下标
    for (int i = last_idx; i >= 0; i--) &#123;
        heapify(arr, len, i);
    &#125;
    printf("第一次堆化后数组为: \n");
    print_arr(arr, len);
&#125;
void heap_sort(int arr[], int len) &#123;
    // 1.将原arr数组构建成大顶堆，第一次构建大顶堆
    first_build_heap(arr, len);
    // 2.反复移除根结点元素，然后再重建大顶堆
    int heap_len = len; // 堆逻辑上的长度，一开始就是数组长度，随着反复移除重建大顶堆，这个长度会一直减少1
    while (heap_len > 1) &#123;  // 只要堆还有两个元素就需要继续构建移除
        SWAP_ELEMENT(arr, 0, heap_len - 1);
        heap_len--;
        /*
            堆排序的核心操作：
            重新构建大顶堆
        */
        heapify(arr, heap_len, 0);  // 堆排序核心操作：堆化
        printf("重新构建大顶堆后: \n");
        print_arr(arr, heap_len);
    &#125;
&#125;
int main(void) &#123;
    int arr[] = &#123; 4, 10, 3, 5, 1 &#125;;
    int len = ARR_SIZE(arr);
    heap_sort(arr, len);
    system("pause");
    return 0;
&#125;</code>
</pre>
</details>
<h3 id="性能分析-6">性能分析</h3>
<p><strong>时间复杂度：</strong></p>
<p><strong>堆排序在任何情况下，时间复杂度都是<span
class="math inline">\(O(nlogn)\)</span></strong>。</p>
<p><strong>空间复杂度：</strong></p>
<p>堆排序显然是一个原地算法，不需要任何额外内存空间，空间复杂度是O(1)</p>
<p><strong>稳定性：</strong></p>
<p>堆排序是一种不稳定的排序算法，在堆化的过程需要交换父节点和左右子树结点，这个过程非常容易出现改变相同元素位置的情况。</p>
<hr />
<h2 id="排序算法总结">排序算法总结</h2>
<div data-align="center">
<table>
<tr>
<th>
</th>
<th>
</th>
<th>
选择排序
</th>
<th>
冒泡排序
</th>
<th>
插入排序
</th>
<th>
希尔排序
</th>
<th>
归并排序
</th>
<th>
快速排序
</th>
<th>
堆排序
</th>
</tr>
<tr>
<td rowspan="3">
时间复杂度
</td>
<td>
最佳情况
</td>
<td>
O(n^2)
</td>
<td>
<b>O(n)</b>
</td>
<td>
<b>O(n)</b>
</td>
<td>
小于O(n^2)
</td>
<td>
O(nlogn)
</td>
<td>
O(nlogn)
</td>
<td>
O(nlogn)
</td>
</tr>
<tr>
<td>
平均情况
</td>
<td>
O(n^2)
</td>
<td>
O(n^2)
</td>
<td>
O(n^2)
</td>
<td>
小于O(n^2)
</td>
<td>
O(nlogn)
</td>
<td>
O(nlogn)
</td>
<td>
O(nlogn)
</td>
</tr>
<tr>
<td>
最坏情况
</td>
<td>
O(n^2)
</td>
<td>
O(n^2)
</td>
<td>
O(n^2)
</td>
<td>
接近O(n^2)
</td>
<td>
O(nlogn)
</td>
<td>
O(n^2)
</td>
<td>
O(nlogn)
</td>
</tr>
<tr>
<td colspan="2">
空间复杂度
</td>
<td>
O(1)
</td>
<td>
O(1)
</td>
<td>
O(1)
</td>
<td>
O(1)
</td>
<td>
O(n)
</td>
<td>
O(logn)~O(n)
</td>
<td>
<b>O(1)</b>
</td>
</tr>
<tr>
<td colspan="2">
稳定性
</td>
<td>
不稳定
</td>
<td>
稳定
</td>
<td>
稳定
</td>
<td>
不稳定
</td>
<td>
<b>稳定</b>
</td>
<td>
不稳定
</td>
<td>
不稳定
</td>
</tr>
</table>
</div>
<p>对于这七种排序算法，我们同样可以在适用场景上，对它们做一个总结：</p>
<ol type="1">
<li>选择排序：建议任何情况都不用。</li>
<li>冒泡排序：建议任何情况都不用。</li>
<li><strong>插入排序：适合小数据集，尤其当数据已基本有序时非常好用。</strong></li>
<li>希尔排序：一般不使用。</li>
<li><strong>归并排序：大数据集的场景下，需要稳定排序算法时使用。</strong></li>
<li><strong>快速排序：大数据集的场景下，通用的排序算法，效率高，但不稳定。</strong></li>
<li><strong>堆排序：大数据集的场景下，性能均衡的不稳定排序算法，优点是不占用额外内存空间。</strong></li>
</ol>
<p><strong>除此之外，我们还可以总结记忆排序算法的稳定和不稳定性的特点：</strong></p>
<p>只要排序算法涉及到<strong>大范围的、远距离的元素交换</strong>，那么该算法肯定不是稳定算法，因为远距离的数据交换没办法控制元素的相对位置不变。</p>
<p>举例：</p>
<ol type="1">
<li>选择排序：选择最小（或最大）元素放在排序数组的起始位置，涉及远距离交换。</li>
<li><strong>希尔排序</strong>：通过使用间隔序列，它在远距离进行元素比较和交换。</li>
<li><strong>快速排序</strong>：通过分区操作，导致可能出现远距离的元素交换。</li>
<li><strong>堆排序</strong>：可能出现将根结点元素一直交换到叶子结点，这是远距离交换元素。</li>
</ol>
<p>这些排序算法，都是因为存在不相邻元素的远距离交换，所以是不稳定的</p>
<p>而<strong>冒泡排序、插入排序以及归并排序，由于总是交换相邻元素，它们就是稳定的。</strong></p>
]]></content>
      <categories>
        <category>C语言</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之自定义$&#92;LaTeX{}$命令和功能（八）</title>
    <url>/lang-latex/notes-lshort/08-custom/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>如何制作一个简单但像样的毕业论文/书籍/简历模板，每次可以直接套用，而不是再在导言区写一堆代码？</p>
<p>本章的内容将有助于你实现这一个目标，让你能编写可重复利用的模块——宏包和文档类，并在其中自己定义命令和环境。</p>
<span id="more"></span>
<p>不过作为入门手册，这些知识仍是不全面的。如果你不满足于此，需要参考更多资料，比如<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> 和 <a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>。</p>
<hr />
<h2 id="自定义命令和环境">自定义命令和环境</h2>
<h3 id="定义新命令">定义新命令</h3>
<p>使用如下命令可以定义你自己的命令：
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131110507497.png" alt="image-20250131110507497" style="zoom:67%;" />
<code>\newcommand</code> 的基本用法需要两个必选参数，第一个参数
<code>&lt;name&gt;</code> 是要定义的命令名称（带反斜线），第二个参数
<code>&lt;definition&gt;</code> 是命令的具体定义。方括号里的参数
<code>&lt;num&gt;</code> 是可选的，用于指定新命令所需的参数数目（最多 9
个)。如果缺省可选参数，默认就是 0，也就是新定义的命令不带任何参数。</p>
<p>接下来的两个例子有助于理解。第一个例子定义了一个新的命令
<code>\tnss</code>。这个命令是本手册英文名称“The Not So Short
Introduction to ”
的简写。如果需要在文档中多次使用本手册的名称，那么使用这个命令是一个非常方便的办法。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131111926918.png" alt="image-20250131111926918" style="zoom:67%;" /></p>
<p>第二个例子演示了如何定义一个带参数的命令。在命令的定义中，标记
<code>#1</code>代表指定的参数。如果想使用多个参数，可以依次使用
<code>#2</code>、……、<code>#9</code>等标记。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131112252163.png" alt="image-20250131112252163" style="zoom:67%;" /></p>
<p><span class="math inline">\(\LaTeX{}\)</span> 不允许使用
<code>\newcommand</code>
定义一个与现有命令重名的命令。如果需要修改命令定义的话，使用
<code>renewcommand</code> 命令。它使用与命令<code>\newcommand</code>
相同的语法。</p>
<p>在某些情况之下，使用 <code>\providecommand</code>
命令是一种比较理想的方案：在命令未定义时，它相当于
<code>newcommand</code>；在命令已定义时，沿用已有的定义。</p>
<h3 id="定义环境">定义环境</h3>
<p>与 <code>\newcommand</code> 命令类似，可以用
<code>\newenvironment</code> 定义新的环境。它的语法如下所示：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131141432124.png" alt="image-20250131141432124" style="zoom:67%;" /></p>
<p>同样地，<code>\newenvironment</code> 命令有一个可选的参数。在
<code>&lt;before&gt;</code> 中的内容将在此环境包含的文本之前处理，而在
<code>&lt;after&gt;</code> 中的内容将在遇到
<code>\end&#123;&lt;name&gt;&#125;</code> 命令时处理。</p>
<p>下面的例子演示了 <code>\newenvironment</code> 命令的用法：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131142005221.png" alt="image-20250131142005221" style="zoom:67%;" /></p>
<p>参数 <code>&lt;num&gt;</code> 的使用方式与 <code>\newcommand</code>
命令相同。<span class="math inline">\(\LaTeX{}\)</span>
还同样保证你不会不小心新建重名的环境。如果你确实希望改变一个现有的环境，你可以使用命令
<code>\renewenvironment</code>，它使用和命令
<code>\newenvironment</code> 相同的语法。</p>
<h3 id="xparse-宏包简介"><code>xparse</code> 宏包简介</h3>
<p>通过 <code>\newcommand</code> 和 <code>\newenvironment</code>
定义的命令或环境格式比较固定。如果需要定义带有多个可选参数、或者带星号的命令或环境，可以使用
<code>xparse</code> 宏包，它提供了 <code>\NewDocumentCommand</code> 和
<code>\NewDocumentEnvironment</code> 等命令，具体语法如下：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131142701900.png" alt="image-20250131142701900" style="zoom:67%;" /></p>
<p>相比 <code>\newcommand</code> 和
<code>\newenvironment</code>，<code>xparse</code>
通过<code>&#123;&lt;arg spec&gt;&#125;</code>
来指定参数的个数和格式。基本的参数格式见下表。注意<code>&#123;&lt;arg spec&gt;&#125;</code>
中的空格可以忽略。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131142942039.png" alt="image-20250131142942039" style="zoom:67%;" /></p>
<p>不同输入值在解析后的结果可以见 下表 中的示例。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131143046148.png" alt="image-20250131143046148" style="zoom:67%;" /></p>
<p><span class="math inline">\(\texttt{-NoValue-}\)</span> 标记可以用
<code>\IfNoValueTF</code> 等命令来判断：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131143150139.png" alt="image-20250131143150139" style="zoom:67%;" /></p>
<p>举例如下：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131143225242.png" alt="image-20250131143225242" style="zoom:67%;" /></p>
<p><code>\BooleanTrue</code> 和 <code>\BooleanFalse</code> 则可以用
<code>\IfBooleanTF</code> 等命令来判断：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131143936824.png" alt="image-20250131143936824" style="zoom:67%;" /></p>
<p>举例如下：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250131143954655.png" alt="image-20250131143954655" style="zoom:67%;" /></p>
<p>需要注意的是，与命令不同，环境在定义时名字里面可以包含
<code>*</code>：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\NewDocumentEnvironment</span> &#123;mytabular&#125;  &#123; o +m &#125; &#123;...&#125; &#123;...&#125;</span><br><span class="line"><span class="keyword">\NewDocumentEnvironment</span> &#123;mytabular*&#125; &#123; m o +m &#125; &#123;...&#125; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>s</code> 标记的 <code>*</code>
则应该放在<code>\begin&#123;&lt;env&gt;&#125;</code> 的后面：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\NewDocumentEnvironment</span> &#123; envstar &#125; &#123; s &#125;</span><br><span class="line">  &#123;<span class="keyword">\IfBooleanTF</span> &#123;<span class="params">#1</span>&#125; &#123;star&#125; &#123;no star&#125;&#125; &#123;&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;envstar&#125;*</span><br><span class="line"><span class="keyword">\end</span>&#123;envstar&#125;</span><br></pre></td></tr></table></figure>
<p>与 <code>\renewcommand</code>、<code>\providecommand</code>
等命令类似，<code>xparse</code>
宏包也允许在命令或环境已有定义时做出相应的处理，具体见 下表。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250206211617053.png" alt="image-20250206211617053" style="zoom:67%;" /></p>
<hr />
<h2 id="编写自己的宏包和文档类">编写自己的宏包和文档类</h2>
<h3 id="编写简单的宏包">编写简单的宏包</h3>
<p>如果定义了很多新的环境和命令，文档的导言区将变得很长，在这种情况下，可以建立一个新的
<span class="math inline">\(\LaTeX{}\)</span>
宏包来存放所有你自己定义的命令和环境，然后在文档中使用
<code>\usepackage</code> 命令来调用自定义的宏包。</p>
<p>写一个宏包的基本工作就是将原本在文档导言区里很长的内容拷贝到另一个文件中去，这个文件需要以
<span class="math inline">\(\texttt{.sty}\)</span>
作扩展名。还需要加入一个宏包专用的命令：</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250207202115559.png" alt="image-20250207202115559" style="zoom:67%;" /></p>
<p>这个命令应该放在你的宏包的最前面，并且一定要注意：<code>&lt;package name&gt;</code>
需要和宏包的文件名一致。<code>\ProvidesPackage</code> 是 LaTeX
中用于声明宏包名称和版本信息的命令，通常放在宏包文件的顶部。它的作用是：</p>
<ol type="1">
<li><strong>声明宏包名称</strong>：告诉 LaTeX 当前文件的宏包名称。</li>
<li><strong>版本信息</strong>：提供宏包的版本号和日期，便于用户了解更新情况。</li>
<li><strong>避免重复加载</strong>：LaTeX
会检查宏包是否已加载，防止重复加载。</li>
</ol>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ProvidesPackage</span>&#123;&lt;宏包名称&gt;&#125;[&lt;版本信息&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;宏包名称&gt;</code>：宏包的名字，通常与文件名一致。</li>
<li><code>&lt;版本信息&gt;</code>：可选，包含版本号和日期。</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ProvidesPackage</span>&#123;mypackage&#125;[2023/10/01 v1.0 My custom package]</span><br></pre></td></tr></table></figure>
<p>这表示宏包 <code>mypackage</code> 的版本是 1.0，发布于 2023 年 10 月
1 日。</p>
<p>下面的源代码
给出了一个小的宏包示例，其中包含了之前定义的一些命令。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Demo Package by Tobias Oetiker</span></span><br><span class="line"><span class="keyword">\ProvidesPackage</span>&#123;demopack&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\tnss</span>&#125;&#123;The not so Short Introduction</span><br><span class="line">                   to <span class="keyword">\LaTeXe</span>&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\txsit</span>&#125;[1]&#123;The <span class="keyword">\emph</span>&#123;<span class="params">#1</span>&#125; Short</span><br><span class="line">                       Introduction to <span class="keyword">\LaTeXe</span>&#125;</span><br><span class="line"><span class="keyword">\newenvironment</span>&#123;king&#125;&#123;<span class="keyword">\begin</span>&#123;quote&#125;&#125;&#123;<span class="keyword">\end</span>&#123;quote&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在宏包中调用其它宏包">在宏包中调用其它宏包</h3>
<p>如果想进一步把各种宏包的功能汇总到一个文件里，而不是在文档的导言区罗列一大堆宏包的话，<span
class="math inline">\(\LaTeX{}\)</span>
允许你在自己编写的宏包中调用其它宏包，命令为
<code>\RequirePackage</code>，用法和 <code>\usepackage</code>一致：
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250207204212557.png" alt="image-20250207204212557" style="zoom:67%;" /></p>
<h3 id="编写自己的文档类">编写自己的文档类</h3>
<p>当你更进一步，需要编写自己的文档类，如论文模板等，问题就稍稍麻烦了一些。首先，自己的文档类以
<span class="math inline">\(\texttt{.cls}\)</span> 作扩展名，开头使用
<code>\ProvidesClass</code> 命令：
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250207210745704.png" alt="image-20250207210745704" style="zoom:67%;" />
<code>&#123;&lt;class name&gt;&#125;</code>也需要和文档类的文件名一致。</p>
<p>但是有了上述命令和和你之前学到的 <code>\newcommand</code>
等，还并不能完成一个文档类的编写，因为诸如
<code>\chapter</code>、<code>\section</code>
等等许多常用的命令都是在文档类中定义的。事实上，许多时候我们只需要像调用宏包那样调用一个基本的文档类，省去许多不必要的麻烦。在你的文档类中调用其它文档类的命令是
<code>\LoadClass</code>，用法和 <code>\documentclass</code> 十分相像：
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250207211020811.png" alt="image-20250207211020811" style="zoom:67%;" /></p>
<h2 id="计数器">计数器</h2>
<p>我们早就见识到了 <span class="math inline">\(\LaTeX{}\)</span>
对文档元素自动计数的能力：章节符号、列表、图表……它们都是依靠 <span
class="math inline">\(\LaTeX{}\)</span> 提供的计数器功能完成的。</p>
<h3 id="定义和修改计数器">定义和修改计数器</h3>
<p>定义一个计数器的方法为：
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250207214349670.png" alt="image-20250207214349670" style="zoom:67%;" /></p>
<p><code>&#123;&lt;counter name&gt;&#125;</code>
为计数器的名称。计数器可以有上下级的关系，可选参数
<code>[&lt;parent counter name&gt;]</code> 定义为
<code>&#123;&lt;counter name&gt;&#125;</code> 的上级计数器。</p>
<p>以下命令修改计数器的数值，<code>\setcounter</code> 将数值设为
<code>&lt;number&gt;</code>；<code>\addtocounter</code> 将数值加上
<code>&lt;number&gt;</code>；<code>\stepcounter</code>
将数值加一，并<span
class="math inline">\(\textbf{将所有下级计数器归零}\)</span>。
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250207220543336.png" alt="image-20250207220543336" style="zoom:67%;" /></p>
<h3 id="计数器的输出格式">计数器的输出格式</h3>
<p>计数器<code>&lt;counter&gt;</code> 的输出格式由
<code>\the&lt;counter&gt;</code>
表示。这个值默认以阿拉伯数字形式输出，如果想改成其它形式，需要重定义
<code>\the&lt;counter&gt;</code>，如将 equation
计数器的格式定义为大写字母：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\theequation</span>&#123;<span class="keyword">\Alph</span>&#123;equation&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>命令 <code>\Alph</code> 控制计数器 <code>&lt;counter&gt;</code>
的值以大写字母形式显示。下表列出所有可用于修改计数器格式的命令。注意：这些命令<span
class="math inline">\(\textbf{只能用于计数器，不能直接用于数字}\)</span>，如<code>\roman&#123;1&#125;</code>
这样的命令会出错。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250207223910065.png" alt="image-20250207223910065" style="zoom:67%;" /></p>
<p>计数器的输出格式还可以利用其它字符，甚至其它计数器的输出格式与之组合。如标准文档类里对
<code>\subsection</code> 相关的计数器的输出格式的定义相当于：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\thesubsection</span>&#123;<span class="keyword">\thesection</span>.<span class="keyword">\arabic</span>&#123;subsection&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="latex-中的计数器"><span class="math inline">\(\LaTeX{}\)</span>
中的计数器</h3>
<ul>
<li>所有章节命令 <code>\chapter</code>、<code>\section</code>
等分别对应计数器 <span
class="math inline">\(\textrm{chapter}\)</span>、<span
class="math inline">\(\textrm{section}\)</span>
等等，而且有上下级的关系。而计数器 part 是独立的。</li>
<li>有序列表 <span class="math inline">\(\texttt{enumerate}\)</span>
的各级计数器为 <span class="math inline">\(\textrm{enumi}\)</span>,
<span class="math inline">\(\textrm{enumii}\)</span>, <span
class="math inline">\(\textrm{enumiii}\)</span>, <span
class="math inline">\(\textrm{enumiv}\)</span>，也有上下级的关系。</li>
<li>图表浮动体的计数器就是 <span
class="math inline">\(\textrm{table}\)</span> 和 <span
class="math inline">\(\textrm{figure}\)</span>；公式的计数器为 <span
class="math inline">\(\textrm{equation}\)</span>。这些计数器在 <span
class="math inline">\(\textrm{article}\)</span>
文档类中是独立的，而在<span
class="math inline">\(\textrm{report}\)</span> 和<span
class="math inline">\(\textrm{book}\)</span> 中以<span
class="math inline">\(\textrm{chapter}\)</span> 为上级计数器。</li>
<li>页码、脚注的计数器分别是 <span
class="math inline">\(\textrm{page}\)</span>和 <span
class="math inline">\(\textrm{footnote}\)</span>。</li>
</ul>
<p>我们可以利用前面介绍过的命令，修改计数器的样式以达到想要的效果，比如把页码修改成大写罗马数字，左右加横线，或是给脚注加上方括号：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\thepage</span>&#123;--~<span class="keyword">\Roman</span>&#123;page&#125;~--&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\thefootnote</span>&#123;[<span class="keyword">\arabic</span>&#123;footnote&#125;]&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;verbatim&#125;</span><br></pre></td></tr></table></figure>
<p>最后介绍两个有用的计数器：</p>
<h4 id="textbfsecnumdepth"><span
class="math inline">\(\textbf{secnumdepth}\)</span></h4>
<p><span class="math inline">\(\LaTeX{}\)</span>
标准文档类对章节划分了层级：</p>
<ul>
<li>在 <span class="math inline">\(\textrm{article}\)</span> 文档类里
<span class="math inline">\(\textrm{part}\)</span> 为 0，<span
class="math inline">\(\textrm{section}\)</span> 为 1，依此类推；</li>
<li><span class="math inline">\(\textrm{report}\)</span> 和 <span
class="math inline">\(\textrm{book}\)</span> 文档类里<span
class="math inline">\(\textrm{part}\)</span>为 -1，<span
class="math inline">\(\textrm{chapter}\)</span> 为 0，<span
class="math inline">\(\textrm{section}\)</span> 为 1，等等。</li>
</ul>
<p><span class="math inline">\(\textrm{secnumdepth}\)</span>
计数器控制章节编号的深度，如果章节的层级大于 <span
class="math inline">\(\textbf{secnumdepth}\)</span>，那么章节的标题、在目录和页眉页脚的标题都不编号（照常生成目录和页眉页脚），章节计数器也不计数。</p>
<p>可以用 <code>\setcounter</code> 命令设置 <span
class="math inline">\(\textrm{secnumdepth}\)</span>
为较大的数使得层级比较深的章节也编号，如设置为 4 令
<code>\paragraph</code> 也编号；或者设置一个较小的数以取消编号，如设置为
-1 令 <code>\chapter</code>
不编号。后者是生成不编号的章节的一个妙招，免去了手动使用
<code>\addcontentsline</code> 和 <code>\markboth</code> 的麻烦。</p>
<p><span class="math inline">\(\textrm{secnumdepth}\)</span> 计数器在
<span class="math inline">\(\textrm{article}\)</span> 文档类里默认为
3（<span class="math inline">\(\textrm{subsubsection}\)</span>
一级）；在 <span class="math inline">\(\textrm{report}\)</span> 和 <span
class="math inline">\(\textrm{book}\)</span> 文档类里默认为 2（<span
class="math inline">\(\textrm{subsection}\)</span> 一级）。</p>
<h4 id="textbftocdepth"><span
class="math inline">\(\textbf{tocdepth}\)</span></h4>
<p><span class="math inline">\(\texttt{tocdepth}\)</span>
计数器控制目录的深度，如果章节的层级大于 <span
class="math inline">\(\texttt{tocdepth}\)</span>，那么章节将不会自动写入目录项。默认值同
<span class="math inline">\(\textrm{secnumdepth}\)</span>。</p>
<hr />
<h2 id="latex-可定制的一些命令和参数"><span
class="math inline">\(LaTeX{}\)</span> 可定制的一些命令和参数</h2>
<p><span class="math inline">\(\LaTeX{}\)</span>
事实上有相当一些可以定制的命令和参数，不过对于修改样式或者开发宏包来说，这些定制项还远远不够。</p>
<p>对于用户来讲，容易定制的是这一些项目：</p>
<ul>
<li><p>标题名称/前后缀等。 下表 列出了标准文档类里可定制的项目，
表中所有的 <span class="math inline">\(\LaTeX{}\)</span> 命令都可以用
<code>\renewcommand</code> 来修改。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250208210859903.png" alt="image-20250208210859903" style="zoom:67%;" /></p></li>
<li><p>长度。前文在叙述各种排版元素时已经介绍过一些，现归纳于
下表。表中所有的长度命令可用 <code>\setlength</code> 来修改。</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250208211426192.png" alt="image-20250208211426192" style="zoom:67%;" /></p></li>
</ul>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Frank Mittelbach, Michel Goossens, Johannes Braams,
David Carlisle, Chris Rowley. The LATEX Companion, 2nd edition.
Addison-Wesley, Reading, Massachusetts, 2004, ISBN 0-201-36299-6.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>LATEX Project Team. LATEX 2 for class and package
writers. <code>CTAN://macros/latex/base/clsguide.pdf</code>
(<strong>texdoc clsguide</strong>)<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之安装TEX发行版（九）</title>
    <url>/lang-latex/notes-lshort/09-install/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>本章会简单介绍如何安装 <span class="math inline">\(\TeX{}\)</span>
发行版，以及保持发行版的内容紧跟最新。后者非常重要，因为 <span
class="math inline">\(\LaTeX{}\)</span> 宏包是不断更新换代的。</p>
<span id="more"></span>
<hr />
<h2 id="tex-发行版简介"><span class="math inline">\(\TeX{}\)</span>
发行版简介</h2>
<p>一个 <strong><span class="math inline">\(\TeX{}\)</span>
发行版</strong> 是 <span class="math inline">\(\TeX{}\)</span>
排版引擎、支持排版的文件（基本格式、<span
class="math inline">\(\LaTeX{}\)</span>
宏包、字体等）以及一些辅助工具的集合。各式各样的 <span
class="math inline">\(\TeX{}\)</span>
发行版经过十多年的发展，大浪淘沙，现今的两个主流发行版为：</p>
<ul>
<li><p><span class="math inline">\(\textbf{TeX Live}\)</span> <span
class="math inline">\(\textrm{TeX Live}\)</span> 由类 UNIX 系统上的
<span class="math inline">\(\textrm{teTEX}\)</span>
发展并取而代之，最终成为跨平台的 <span
class="math inline">\(\TeX{}\)</span> 发行版。<span
class="math inline">\(\textrm{TeX Live}\)</span> 自 2011
年起以年份作为发行版的版本号，保持了一年一更的频率。</p>
<p><span class="math inline">\(\textrm{MacTeX}\)</span> 是 macOS（OS
X）系统下的一个定制化的 <span class="math inline">\(\textrm{TeX
Live}\)</span> 版本，与 <span class="math inline">\(\textrm{TeX
Live}\)</span> 同步更新。</p></li>
<li><p><span class="math inline">\(\textbf{MiKTeX}\)</span> <span
class="math inline">\(\textrm{MiKTeX}\)</span> 是主要用于 Windows
平台的一个稳定发展的 <span class="math inline">\(\TeX{}\)</span>
发行版。在中国大陆曾经发行过“<span
class="math inline">\(\textrm{CTeX}\)</span>
套装”，它是一个经过本地化配置的 <span
class="math inline">\(\textrm{MiKTeX}\)</span>，不过其配置较为过时，也不再有更新支持，使用起来可能有诸多问题，现已不推荐使用。</p></li>
</ul>
<p><span class="math inline">\(\textrm{TeX Live}\)</span> 和 <span
class="math inline">\(\textrm{MiKTeX}\)</span> 都集成了一个简单的 <span
class="math inline">\(\LaTeX{}\)</span> 源代码编辑器
<strong>TeXworks</strong>（<span
class="math inline">\(\textrm{MacTeX}\)</span> 则集成了类似的
TeXShop）。用户在安装完毕后，可直接使用 TeXworks 编写和编译 <span
class="math inline">\(\LaTeX{}\)</span> 源代码。</p>
<h3 id="安装发行版">安装发行版</h3>
<h4 id="textbftex-live"><span class="math inline">\(\textbf{TeX
Live}\)</span></h4>
<p><span class="math inline">\(\textrm{TeX Live}\)</span>
的安装和使用指南可参考<span class="exturl" data-url="aHR0cHM6Ly93d3cudHVnLm9yZy90ZXhsaXZlL2RvYy90ZXhsaXZlLXpoLWNuL3RleGxpdmUtemgtY24ucGRm">文档<i class="fa fa-external-link-alt"></i></span>,
可用 <code>texdoc texlive-zh-cn</code> 在本地打开。</p>
<p><span class="math inline">\(\textrm{TeX Live}\)</span>
的光盘镜像发布于 <span class="exturl" data-url="aHR0cHM6Ly93d3cudHVnLm9yZy90ZXhsaXZlLw==">texlive官网<i class="fa fa-external-link-alt"></i></span>，下载镜像到本地，挂载到虚拟光驱，或者用压缩工具解压后，在其根目录有几个用于安装的脚本：</p>
<ul>
<li><p>用于 <strong>Windows</strong> 的批处理文件：</p>
<ul>
<li><p><span
class="math inline">\(\texttt{install-tl-windows.bat}\)</span>
双击启动图形界面安装程序，可以在图形安装界面的 Advanced
选项中定制安装；</p></li>
<li><p>在命令提示符中输入 <span
class="math inline">\(\texttt{install-tl-windows.bat -no-gui}\)</span>
启动文本界面安装程序。</p></li>
</ul></li>
<li><p>用于 <strong>Linux</strong> 的 Perl 脚本 <span
class="math inline">\(\texttt{install-tl}\)</span> ：</p>
<ul>
<li><p><span class="math inline">\(\texttt{install-tl}\)</span>
启动文本界面安装程序；</p></li>
<li><p><span class="math inline">\(\texttt{install-tl -gui}\)</span>
启动图形界面安装程序。</p></li>
</ul></li>
</ul>
<p>另外也可以下载在线安装程序 <span
class="math inline">\(\texttt{install-tl.zip}\)</span>，包含以上所有安装脚本。安装过程中会从
CTAN 软件源下载所有组件。</p>
<p>Linux 下 <span class="math inline">\(\textrm{TeX Live}\)</span>
安装完毕后，一般还需要在 root 权限下进行以下操作，使得 <span
class="math inline">\(\textrm{XeLaTeX}\)</span> 能正确通过
<code>fontspec</code>等宏包使用字体：</p>
<ol type="1">
<li>将 <span
class="math inline">\(\texttt{texlive-fontconfig.conf}\)</span>
文件复制到 <span
class="math inline">\(\texttt{/etc/fonts/conf.d/09-texlive.conf}\)</span>。</li>
<li>运行 <span class="math inline">\(\texttt{fc-cache
-fsv}\)</span>。</li>
</ol>
<h4 id="textbfmiktex"><span
class="math inline">\(\textbf{MiKTeX}\)</span></h4>
<p>从 <span class="math inline">\(\textrm{MiKTeX}\)</span> <span class="exturl" data-url="aHR0cHM6Ly93d3cubWlrdGV4Lm9yZy8=">官网<i class="fa fa-external-link-alt"></i></span> 下载名为 <span
class="math inline">\(\texttt{basic-miktex-***.exe}\)</span> 的 Windows
安装包。下载后直接双击打开，按照程序的提示进行安装即可。</p>
<hr />
<h2 id="安装和更新宏包">安装和更新宏包</h2>
<p><span class="math inline">\(\textrm{TeX Live}\)</span> 和 <span
class="math inline">\(\textrm{MiKTeX}\)</span>
分别提供了图形界面的宏包管理器 <span class="math inline">\(\textrm{TEX
Live Manager}\)</span> 和 <span class="math inline">\(\textrm{MiKTeX
Package
Manager}\)</span>，用于安装、管理和更新宏包。一般情况下，直接在图形界面的工具下按提示操作即可（<span
class="math inline">\(\textrm{MiKTeX Package Manager}\)</span>
有普通权限和管理员权限的版本，建议<strong>总是使用管理员权限</strong>的版本）。</p>
<p>两者也可以通过各自的命令行工具安装和更新宏包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% TeX Live 命令行工具 tlmgr 的使用示例</span><br><span class="line">% 安装/卸载宏包</span><br><span class="line">tlmgr install &lt;package-name&gt;</span><br><span class="line">tlmgr remove &lt;package-name&gt;</span><br><span class="line">% 更新所有宏包（包括 tlmgr 本身）</span><br><span class="line">tlmgr update --all --self</span><br><span class="line">% 列出所有可更新的宏包</span><br><span class="line">tlmgr update --list</span><br><span class="line">% 指定更新源地址</span><br><span class="line">% &lt;CTAN mirrors&gt; 形如 https://mirrors.tuna.tsinghua.edu.cn/CTAN</span><br><span class="line">tlmgr repository <span class="built_in">set</span> &lt;CTAN mirrors&gt;/systems/texlive/tlnet</span><br><span class="line">% 查看宏包信息，加 --list 参数可列出宏包的所有文件</span><br><span class="line">tlmgr info &lt;package-name&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% MiKTeX 命令行工具 mpm 的使用示例</span><br><span class="line">% 建议始终加 --admin 参数使用</span><br><span class="line">% 安装/卸载宏包</span><br><span class="line">mpm --admin --install &lt;package-name&gt;</span><br><span class="line">mpm --admin --uninstall &lt;package-name&gt;</span><br><span class="line">% 更新所有宏包</span><br><span class="line">mpm --admin --update</span><br><span class="line">% 列出所有可更新的宏包</span><br><span class="line">mpm --admin --find-updates</span><br><span class="line">% 指定更新源地址</span><br><span class="line">mpm --admin --set-repository=&lt;CTAN mirrors&gt;/systems/win32/miktex/tm/packages</span><br><span class="line">% 查看宏包信息</span><br><span class="line">mpm --admin --print-package-info &lt;package-name&gt;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(\textrm{TeX Live}\)</span>
默认安装所有宏包， <span class="math inline">\(\textrm{MiKTeX}\)</span>
的安装程序只包含了 <span class="math inline">\(\LaTeX{}\)</span>
的一些基本宏包。从 <span class="math inline">\(\textrm{TeX
Live}\)</span> 的光盘镜像和 <span
class="math inline">\(\textrm{MiKTeX}\)</span> 的安装包体积可见一斑。
默认情况下，编译过程中如果遇到宏包未安装而报错的情况下，<span
class="math inline">\(\textrm{MiKTeX}\)</span>
会弹出一个对话框，让用户可以选择临时安装宏包，安装成功后继续编译。</p>
<h3 id="手动安装宏包">手动安装宏包</h3>
<p><span
class="math inline">\(\textcolor{red}{如非万不得已，尽量不要手动安装宏包}\)</span>。绝大多数宏包都已打包到
<span class="math inline">\(\textrm{TeX Live}\)</span> 和 <span
class="math inline">\(\textrm{MiKTeX}\)</span>
两大发行版的安装源，可用宏包管理器安装。如果用户知道某个宏包的名称，但不确定是否在发行版中已打包，可在
<span class="math inline">\(\textrm{CTAN}\)</span> 中搜索。</p>
<p>如果确实有手动安装宏包的需要，本小节的内容将有所帮助。在手动安装之前，有必要了解一下
<span class="math inline">\(\TeX{}\)</span> 目录结构（<span
class="math inline">\(\TeX{}\)</span> Directory Structure, TDS）。它是
<span class="math inline">\(\TeX{}\)</span>
发行版中宏包、字体、帮助文档等文件的组织结构。TDS 有时也称为 <span
class="math inline">\(\textrm{TEXMF}\)</span> 树，取 <span
class="math inline">\(\TeX+\textrm{METAFONT}\)</span> 之意。</p>
<p>以 <span class="math inline">\(\textrm{TeX Live}\)</span>
为例，假设系统的 <span class="math inline">\(\textrm{TEXMF}\)</span>
树根目录为 <span
class="math inline">\(\textrm{C:\\texlive\\2020\\texmf-dist}\)</span>，其下有很多子目录，仅举几例：</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;"><span
class="math inline">\(\texttt{tex/latex}\)</span></th>
<th style="text-align: left;"><span
class="math inline">\(\LaTeX{}\)</span> 宏包</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{doc/latex}\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\LaTeX{}\)</span> 宏包的帮助文档</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{source/latex}\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\LaTeX{}\)</span> 宏包的源代码</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{bibtex}\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\textrm{BibTeX}\)</span>
工具相关文件，许多宏包配套的 <span
class="math inline">\(\textrm{BibTeX}\)</span> 格式文件位于子目录 <span
class="math inline">\(\texttt{bst}\)</span> 中</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{fonts/tfm}\)</span></td>
<td style="text-align: left;">$ $ 使用的字体文件，<span
class="math inline">\(\textrm{TFM}\)</span> 格式</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{fonts/type1}\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\textrm{PostScript}\)</span> 字体文件（<span
class="math inline">\(\textrm{Type1}\)</span>），<span
class="math inline">\(\textrm{PFB}\)</span> 格式</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{fonts/opentype}\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\textrm{OpenType}\)</span> 格式的字体文件</td>
</tr>
</tbody>
</table>
<p>需要手动安装的宏包，一般已经按照上述目录结构打包完成。手动安装时，尽量不要拷贝到系统的
<span class="math inline">\(\textrm{TEXMF}\)</span>
树，而是拷贝到发行版提供的用户 <span
class="math inline">\(\textrm{TEXMF}\)</span> 树，如 <span
class="math inline">\(\textrm{TeX Live}\)</span> 的 <span
class="math inline">\(\textrm{C:\\texlive\\texmf-local}\)</span>。安装完成后，还需<strong>刷新
<span class="math inline">\(\TeX{}\)</span>
发行版的文件名数据库</strong>，令新安装的宏包文件能够被系统找到。<span
class="math inline">\(\textrm{TeX Live}\)</span> 用户须在 Windows
命令行或者 Linux 终端执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mktexlsr</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(\textrm{MiKTeX}\)</span>
用户的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">initexmf --update-fndb</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$编译运行常见报错及解决方案</title>
    <url>/lang-latex/usage-skills/latex-compile-error-solutions/</url>
    <content><![CDATA[<p>本文总结了 <span class="math inline">\(\LaTeX{}\)</span>
编译运行时常见的报错和解决方案。</p>
<span id="more"></span>
<hr />
<h2 id="常见问题及解决方案">常见问题及解决方案</h2>
<h3 id="环境变量">环境变量</h3>
<p>首先查看系统环境变量Path是否正常，以下为常用值，最后texlive为你本地的安装路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32</span><br><span class="line">C:\Windows</span><br><span class="line">C:\Windows\System32\Wbem</span><br><span class="line">C:\Windows\System32\WindowsPowerShell\v1.0\</span><br><span class="line">C:\Windows\System32\OpenSSH\</span><br><span class="line">C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common</span><br><span class="line">D:\install\texlive\2024\bin\windows</span><br></pre></td></tr></table></figure>
<h3 id="latex-error-file-picins.sty-not-found">LaTeX Error: File
`picins.sty’ not found</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240905124943012.png" alt="image-20240905124943012" style="zoom:50%;" /></p>
<p><strong>原因：</strong>picins.sty宏包缺失。</p>
<p><strong>解决方法：</strong>添加picins.sty宏包。</p>
<p><strong>步骤：</strong></p>
<ol type="1">
<li><p>从<span class="exturl" data-url="aHR0cHM6Ly9jdGFuLm9yZy8=">https://ctan.org/<i class="fa fa-external-link-alt"></i></span>
下载宏包；
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240905153702004.png" alt="image-20240905153702004" style="zoom: 25%;" /></p></li>
<li><p>解压到<strong>\</strong>目录下，并打开64miktex-console_admin.exe，点击<strong>任务-刷新文件名数据库</strong>，更新宏包库（相当于激活该宏包）；</p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240905155622980.png" alt="image-20240905155622980" style="zoom:50%;" /></p></li>
</ol>
<h3
id="winedt编译提示pdf文件打不开cannot-run-pdf">WinEdt编译提示pdf文件打不开，Cannot
Run pdf</h3>
<p><strong>原因：</strong>遇到这个问题是因为其他的PDF阅读器强制占用了winedt的pdf打开程序。</p>
<p><strong>解决方法：</strong>重新添加阅读器SumatraPDF。</p>
<p><strong>步骤：</strong></p>
<ol type="1">
<li>在安装CTEX的文件夹搜索SumatraPDF.exe，一般在D:Files
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240901105058347.png" alt="image-20240901105058347" style="zoom:50%;" /></li>
<li>复制路径，D:Files.exe，注意要加上SumatraPDF.exe。</li>
<li>打开WinEdt，option-&gt;execution modes-&gt;pdf
viewer，修改路径后确认一下</li>
</ol>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240901105515360.png" alt="image-20240901105515360" style="zoom:50%;" /></p>
<h3
id="应用程序无法正常启动0xc000007b">应用程序无法正常启动0xc000007b</h3>
<p><strong>原因：</strong>缺少c++文件或者系统dll文件缺失</p>
<p><strong>解决方法：</strong><span class="exturl" data-url="aHR0cDovL3d3dy56amt3ZWlxaS5jbi9uZXdzLzU4MTEyLmh0bWw=">http://www.zjkweiqi.cn/news/58112.html<i class="fa fa-external-link-alt"></i></span></p>
<ol type="1">
<li>命令行c:&gt;后边输入【sfc
/scannow】（中间有空格），然后点击键盘上的回车（enter键），就会“开始系统扫描”。</li>
<li>电脑通过下载DirectX Repair修复工具来检测并修复。</li>
</ol>
<h3
id="miktex更新后无法打开报错this-application-failed-to-start-because-no-qt-platform-plugin-could-be-initialized.-reinstalling-the-application-may-fix-this-problem">miktex更新后无法打开，报错：This
application failed to start because no Qt platform plugin could be
initialized. Reinstalling the application may fix this problem</h3>
<p><strong>解决方法：</strong>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V0aW5jZWxsZS9hcnRpY2xlL2RldGFpbHMvMTQwMDI1Mjgw">https://blog.csdn.net/Etincelle/article/details/140025280<i class="fa fa-external-link-alt"></i></span></p>
<ol type="1">
<li><p>点击<span class="exturl" data-url="aHR0cHM6Ly9jdGFuLm5ldC9zeXN0ZW1zL3dpbjMyL21pa3RleC90bS9wYWNrYWdlcy8=">链接<i class="fa fa-external-link-alt"></i></span>，下载miktex-qt6-bin-x64.tar.lzma</p>
<p>（该文件Windows下不容易解压，已将其中的x64文件夹转换为windows下容易解压的rar格式）链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVpBYjBydEJ2RVVGM1BQYU1VWElzVXc/cHdkPWM3b2M=">https://pan.baidu.com/s/1ZAb0rtBvEUF3PPaMUXIsUw?pwd=c7oc<i class="fa fa-external-link-alt"></i></span>
提取码：c7oc</p></li>
<li><p>解压程序包后，进入此文件夹，找到</p></li>
<li><p>找到MikTeX安装文件夹，进入，将步骤2的x64文件夹替换步骤3的x64文件夹</p></li>
</ol>
<h3 id="中文用户名-卡在狮子页面不动">中文用户名 卡在狮子页面不动</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250417145624162.png" alt="image-20250417145624162" style="zoom:50%;" /></p>
<p><strong>解决方法：</strong></p>
<ol type="1">
<li><p>右击电脑- -&gt;属性- -&gt; 高级系统设置- -&gt;在[高级]下点击<a
href="#环境变量">环境变量</a>，</p></li>
<li><p>在<strong>用户变量</strong>和<strong>系统变量</strong>栏里，
找到TEMP与TMP， 分别双击，设置如下：</p>
<p>变量名：TEMP 变量值：%SystemRoot%</p>
<p>变量名：TMP变量值：%SystemRoot%</p></li>
</ol>
<p>注意：若用户和系统变量栏里没有TEMP与TMP，新建即可。</p>
<h3 id="please-ignore-spurious-matches-unrelated-to-tex">Please ignore
spurious matches unrelated to TeX</h3>
<p><strong>问题现象：</strong></p>
<p>Please ignore spurious matches unrelated to TeX. (To omit this check,
set the environment variable TEXLIVE_INSTALL_ENV_NOCHECK.) CCHZPATH=D:
CCPKPATH=D:$d II=D:\2022</p>
<p><strong>解决方案：</strong>设置环境变量</p>
<ol type="1">
<li>打开“控制面板” &gt; “系统和安全” &gt;
“系统”，然后点击左侧的“高级系统设置”。</li>
<li>在“系统属性”窗口中，点击“环境变量”。</li>
<li>在“环境变量”窗口下的“系统变量”部分，点击“新建”。</li>
<li>在“变量名”中输入：<code>TEXLIVE_INSTALL_ENV_NOCHECK</code></li>
<li>在“变量值”中输入：<code>1</code></li>
<li>点击“确定”保存设置。</li>
</ol>
<p>设置完成后，再次运行 TeX Live
安装程序即可。这将避免在安装过程中显示与 TeX
无关的匹配警告，使安装过程更顺畅</p>
<h3
id="vars-expected-but-powershell-不是内部或外部命令也不是可运行的程序-found">‘vars’
expected but ‘powershell’ 不是内部或外部命令，也不是可运行的程序
found</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250102195322647.png" alt="image-20250102195322647" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>添加环境变量Path
<code>C:\Windows\System32\WindowsPowerShell\v1.0\</code></p>
<h3 id="字体问题">字体问题</h3>
<p>kpathsea: Running mktextfm STFangsong/OT The command name is D:\2024
name = STFangsong/OT, rootname = STFangsong/OT, pointsize = mktexmf:
empty or non-existent rootfile! kpathsea: Running mktexmf
STFangsong/OT.mf The command name is D:\2024Cannot find
STFangsong/OT.mf. kpathsea: Appending font creation commands to
missfont.log.</p>
<p><strong>解决方案：</strong>下载对应字体，并选择<strong>为所有用户安装</strong>，（或者尝试在字体命令后加上.ttf）</p>
<h3
id="macos中latex提示没有相关字体怎么办">MacOS中LaTeX提示没有相关字体怎么办</h3>
<p><strong>解决方案：</strong>完全使用Windows那套字体解决方案，避免MacOS字体库管理混乱问题。</p>
<blockquote>
<ol type="1">
<li><p>将别人的整个Windows字体包压缩发送到MacOS，并且解压到<code>~/Library/Fonts_Windows/Fonts</code>文件夹下（可选择其他路径，后续配置需要用）；</p></li>
<li><p>终端通过<code>kpsewhich -var-value TEXMFROOT</code>命令定位TeX
Live
的根目录，比如<code>/usr/local/texlive/2025</code>，打开<code>texmf.cnf</code>文件（需超级用户权限）添加字体路径（上一步解压的路径）<code>OSFONTDIR = /home/user/Library/Fonts_Windows/Fonts//</code>，保存关闭；</p></li>
<li><p>更新字体数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mktexlsr  <span class="comment"># TeX Live (Linux/macOS)</span></span><br><span class="line">initexmf --update-fndb  <span class="comment"># MiKTeX</span></span><br></pre></td></tr></table></figure></li>
<li><p>在文件开头的<code>\documentclass</code>里面直接加入<code>fontset=windows</code>属性，给编译器指定使用Windows方案的字体编译。</p></li>
<li><p>如果后续编译报找不到<code>.ttc</code>后缀的字体，把<code>.ttf</code>的后缀直接改成<code>.ttc</code>即可。</p>
<p>如果编译之后的pdf显示有问题，可以双击下载的三个字体进行安装。用于MacOS系统显示效果用。</p></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>使用技巧</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之排除错误和寻求帮助（十）</title>
    <url>/lang-latex/notes-lshort/10-error-help/</url>
    <content><![CDATA[<p>本文主体内容来自 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p><span class="math inline">\(\LaTeX{}\)</span>
入门用户总会为两大问题头疼：我写的代码到底哪里出错了？如果想要实现某种用法该怎么办？本章首先总结了常见的
<span class="math inline">\(\LaTeX{}\)</span>
错误及应对办法，然后介绍了查找帮助文档的一些方法，最后简单总结了一些常用的宏包。</p>
<span id="more"></span>
<hr />
<h2 id="latex-错误"><span class="math inline">\(\LaTeX{}\)</span>
错误</h2>
<p>当用排版引擎编译 <span class="math inline">\(\LaTeX{}\)</span>
代码时，命令行的窗口（终端）会显示大量信息（TeXworks
等编辑器会有一个区域显示这些信息）。
当编译过程中出现错误时，信息将会停止在出错的地方，等待我们接下来的操作。</p>
<p>比如说我们有一个明显出错的例子：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">Test <span class="keyword">\LaTEx</span>&#123;&#125; and it&#x27;s friends.</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>编译过程中遇到这个错误将会停顿下来，提示错误，并等待用户输入指令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">! Undefined control sequence.</span><br><span class="line">l.3 Test <span class="keyword">\LaTEx</span></span><br><span class="line">             &#123;&#125; and it&#x27;s friends.</span><br></pre></td></tr></table></figure>
<p>这种错误信息分两部分，前一部分提示了错误的信息，后一部分指出了错误发生的行号，以及通过错落的文字告知发生错误的命令所在位置。如上错误显示
<code>\LaTEx</code> 位置发生了错误，错误信息是“未定义的控制序列”，意思是
<code>\LaTEx</code> 是 <span class="math inline">\(\TeX{}\)</span>
编译器无法识别的一个命令，很显然是把 <code>\LaTeX</code>
的大小写写错了。</p>
<h3 id="处理方式">处理方式</h3>
<p>出现错误时，编译过程将暂停，等待用户输入命令。用户可以直接敲回车跳过当前的错误，继续编译，相当于丢掉了写错的命令，将“Test
and it’s
friends.”排版出来。但这个例子过于简单，有些复杂的代码中，有可能会由于一个小问题导致一连串的错误。此时可以选择按
<span class="math inline">\(\textbf{S/R/Q}\)</span>
选择跳过接下来的所有错误，或者按 <span
class="math inline">\(\textbf{X}\)</span>
直接退出编译，将源代码中的错误修改后重新编译。</p>
<h3 id="常见的-latex-错误信息">常见的 <span
class="math inline">\(\LaTeX{}\)</span> 错误信息</h3>
<p>在此总结一些经常发生、问题比较明确的 <span
class="math inline">\(\LaTeX{}\)</span> 错误：</p>
<ul>
<li><p><span style="color:red;">! Undefined control
sequences.</span></p>
<p>使用了未定义的命令。拼写错误是原因之一（标点符号中英文不匹配）。也有可能是没有调用某个宏包，但用了该宏包定义的命令。</p></li>
<li><p><span style="color:red;">! LaTeX error: Environment …
undefined.</span></p>
<p>使用了未定义的环境。</p></li>
<li><p><span style="color:red;">! Missing $ inserted.</span></p>
<p>缺少数学环境的符号 <span
class="math inline">\(\texttt\$\)</span>。多由于将数学符号用在公式之外而导致。</p></li>
<li><p><span style="color:red;">Runaway argument? </span></p>
<p><span style="color:red;"> ! Paragraph ended before … was
complete.</span></p></li>
<li><p><span style="color:red;">! File ended while scanning
definition/use of …</span></p>
<p>这两个错误主要是由于漏写了包裹命令参数的花括号，导致识别参数时出现错误。许多编辑器的括号配对功能有助于检查和消除这类错误。</p>
<p>这类错误还有可能是由于前一次编译中断导致 <span
class="math inline">\(\texttt{.aux}\)</span>
等辅助文件不完整，再次编译读入不完整的文件产生错误。解决办法是删除辅助文件并重新编译。</p></li>
<li><p><span style="color:red;">! Extra alignment tab has been changed
to .</span></p></li>
<li><p><span style="color:red;">! Misplaced .</span></p>
<p>两个错误信息都与表格有关。</p>
<ul>
<li>前者的字面意义是“一行中使用的列分隔符 <span
class="math inline">\(\texttt\&amp;\)</span> 太多”，有时可能确实是 <span
class="math inline">\(\texttt\&amp;\)</span>
的个数和列格式不匹配，但多数情况是漏掉了行尾的 <code>\\</code>
命令。</li>
<li>后者常出现于漏掉了行尾的 <code>\\</code> 命令而接着使用
<code>\hline</code> 命令画横线的时候。</li>
</ul></li>
<li><p><span style="color:red;">! LaTeX Error: Lonely \item – perhaps a
missing list environment.</span></p></li>
<li><p><span style="color:red;">! LaTeX Error: Something’s wrong–perhaps
a missing \item.</span></p>
<p>两个错误信息都与列表环境和 <code>\item</code>
命令有关。前者意味着在没有使用列表环境的情况下用了
<code>\item</code>；后者则相反，是在列表环境中漏了
<code>\item</code>。</p></li>
<li><p><span style="color:red;">! I can’t find file `…’.</span></p></li>
<li><p><span style="color:red;">! LaTeX Error: File `…’ not
found.</span></p>
<p>两个错误都意味着缺少文件。</p>
<ul>
<li>如果使用 <code>\input</code> 或者 <code>\include</code>
命令添加文件，出现上述错误的原因当然是文件不存在或者文件名不对；</li>
<li>如果错误提示里的文件名带 <span
class="math inline">\(\texttt{.sty}\)</span> 或者 <span
class="math inline">\(\texttt{.cls}\)</span> 扩展名，那么很显然，是因为
<strong>没有安装所需的宏包或文档类</strong>。</li>
</ul></li>
<li><p><span style="color:red;">! LaTeX Error: Missing
\begin{document}.</span></p>
<p>字面上是缺少 <code>\begin&#123;document&#125;</code>，实际上往往是由于在
<code>\begin&#123;document&#125;</code>
之前（导言区）输入了文字或某些命令。</p></li>
<li><p><span style="color:red;">! LaTeX Error: Can be used only in
preamble.</span></p>
<p>与上一条相反，由于将必须用于导言区的命令在
<code>\begin&#123;document&#125;</code> 之后使用而产生。</p></li>
<li><p><span style="color:red;">! LaTeX Error:  begin{…} on input line
ended by \end{…}. </span></p>
<p>环境首尾不匹配。比如 <code>\begin&#123;enumerate&#125;</code> 用了
<code>\end&#123;itemize&#125;</code> 结尾。或者也可能是由于漏写了
<code>\begin</code> 或者 <code>\end</code> 命令。</p></li>
<li><p><span style="color:red;">! LaTeX Error: Option clash for package
`…’.</span></p>
<p>以 <strong>不同选项</strong>
重复调用宏包造成冲突。有可能是因为其它宏包内部事先调用了这个宏包，用户再次带选项调用而导致冲突。解决问题的办法是去掉重复调用的宏包。如果宏包允许的话，尽量使用其定义的命令改变设置，减少宏包选项的使用。</p></li>
<li><p><span style="color:red;">! LaTeX Error: Command … already
defined, </span></p>
<p><span style="color:red;">or name \end… illegal … </span></p>
<p>使用 <code>\newcommand</code> 或 <code>\newenvironment</code>
定义已有的命令/环境时产生的错误。如果自己确实作了定义，可考虑用
<code>\renewcommand</code> 或 <code>\renewenvironment</code>
定义；如果是宏包定义的命令产生了这个错误，则属于隐性的宏包冲突。</p>
<p>相比之前的“Option
clash”，隐性宏包冲突是更难以解决的问题，对各种宏包不熟悉的用户，尤其是使用模板的用户而言，往往难以下手。用户可尝试查找引起冲突的宏包的帮助文档。详尽的手册里通常会告知用户这个宏包应当在某个宏包的前面/后面调用，或者不能与某个宏包一起调用。
如果是模板调用了大量宏包导致冲突，可联系模板的作者解决。</p></li>
<li><p><span style="color:red;">! LaTeX Error: Unknown option `…' for
package `…’. </span></p>
<p>调用宏包时指定了不能被其识别的选项。此时应该查找宏包的帮助文档来解决问题。</p></li>
<li><p><span style="color:red;">! Package `…’ error: … </span></p>
<p>宏包或文档类自定义的错误，由于不正确地使用宏包里的命令而导致。此时应该查找宏包的帮助文档来解决问题。</p></li>
</ul>
<hr />
<h2 id="查找帮助文档">查找帮助文档</h2>
<p>无论是 <span class="math inline">\(\textrm{TeX Live}\)</span> 还是
<span
class="math inline">\(\textrm{MiKTeX}\)</span>，都提供了一个命令行模式的程序
<span class="math inline">\(\texttt{texdoc}\)</span>。比如对
<code>fancyhdr</code> 宏包感兴趣，这时在 Windows 命令提示符或者 Linux
终端输入以下命令，则会弹出宏包的帮助文档 <span
class="math inline">\(\texttt{fancyhdr.pdf}\)</span>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">texdoc fancyhdr</span><br></pre></td></tr></table></figure>
<p>除了宏包的帮助文档外，<span class="math inline">\(\TeX{}\)</span>
发行版还包括了各类有用的文档，有一部分在参考文献中给出。</p>
<p>对于初学者，有一个现实而棘手的问题：<strong>某个命令到底是 <span
class="math inline">\(\LaTeX{}\)</span>
自有的，还是哪个宏包提供的？</strong>
很遗憾地说，除了通过慢慢积累、熟悉较多宏包之外，没有很方便的办法解决这个问题，因为
<span class="math inline">\(\LaTeX{}\)</span> 的宏包实在太丰富了。</p>
<p>解决这个问题有几点可行的办法：</p>
<ol type="1">
<li><p>查询一些综述性的资料，如总结所有 <span
class="math inline">\(\LaTeX{}\)</span> 自带命令的文档 <a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>、、<span
class="math inline">\(\LaTeX{}\)</span> 符号大全 <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
等；</p></li>
<li><p>在互联网上搜索自己不清楚的命令；</p></li>
<li><p>在论坛上提问求助有经验的人。</p></li>
</ol>
<hr />
<h2 id="常用宏包简介">常用宏包简介</h2>
<h3 id="文字公式和符号">文字、公式和符号</h3>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">宏包</th>
<th style="text-align: left;">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{amsmath}\)</span></td>
<td style="text-align: left;">AMS 数学公式扩展。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{mathtools}\)</span></td>
<td
style="text-align: left;">数学公式扩展宏包，提供了公式编号定制和更多的符号、矩阵等。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{amsfonts}\)</span></td>
<td style="text-align: left;">AMS 扩展符号的基础字体支持。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{amssymb}\)</span></td>
<td style="text-align: left;">在 <span
class="math inline">\(\texttt{amsfonts}\)</span> 基础上将 AMS
扩展符号定义成命令。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{bm}\)</span></td>
<td style="text-align: left;">提供将数学符号加粗的命令
<code>\bm</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{unicode-math}\)</span></td>
<td style="text-align: left;">使用 Unicode 数学字体。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{nicematrix}\)</span></td>
<td style="text-align: left;">排版复杂矩阵。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{siunitx}\)</span></td>
<td style="text-align: left;">以国际单位规范排版物理量的单位。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{mhchem}\)</span></td>
<td style="text-align: left;">排版化学式和方程式。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{tipa}\)</span></td>
<td style="text-align: left;">排版国际音标。</td>
</tr>
</tbody>
</table>
<h3 id="排版元素">排版元素</h3>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">宏包</th>
<th style="text-align: left;">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{ulem}\)</span></td>
<td style="text-align: left;">提供排版可断行下划线的命令
<code>\uline</code> 以及其它装饰文字的命令。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{endnote}\)</span></td>
<td style="text-align: left;">排版尾注。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{marginnote}\)</span></td>
<td style="text-align: left;">改善的边注排版功能。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{multicol}\)</span></td>
<td style="text-align: left;">提供将内容自由分栏的 <span
class="math inline">\(\texttt{multicols}\)</span> 环境。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{multitoc}\)</span></td>
<td style="text-align: left;">生成多栏排版的目录。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{minitoc}\)</span></td>
<td style="text-align: left;">为章节生成独立的小目录。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{glossaries}\)</span></td>
<td style="text-align: left;">生成词汇表。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{verbatim}\)</span></td>
<td style="text-align: left;">对原始的 <span
class="math inline">\(\texttt{verbatim}\)</span> 环境的改善。提供了命令
<code>\verbatiminput</code> 调用源文件。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{fancyvrb}\)</span></td>
<td style="text-align: left;">提供了代码排版环境 <span
class="math inline">\(\texttt{Verbatim}\)</span>
以及对版式的自定义。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{listings}\)</span></td>
<td style="text-align: left;">提供了排版关键字高亮的代码环境 <span
class="math inline">\(\texttt{lstlisting}\)</span>
以及对版式的自定义。类似宏包有 <span
class="math inline">\(\texttt{minted}\)</span> 等。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{algorithmic}\)</span></td>
<td
style="text-align: left;">一个简单的实现算法排版的宏包。如果要生成浮动体的话，需要搭配
<span class="math inline">\(\texttt{algorithm}\)</span> 宏包使用。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{algorithm2e}\)</span></td>
<td
style="text-align: left;">较为复杂的、可定制的算法排版宏包。类似宏包有
<span class="math inline">\(\texttt{algorithmicx}\)</span> 等。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{amsthm}\)</span></td>
<td style="text-align: left;">定制定理环境。类似宏包包括 <span
class="math inline">\(\texttt{theorem}\)</span>、<span
class="math inline">\(\texttt{ntheorem}\)</span>、<span
class="math inline">\(\texttt{thmtools}\)</span> 等。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{mdframed}\)</span></td>
<td
style="text-align: left;">排版可自动断页的带边框文字段落，提供边框样式的定制功能。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{tcolorbox}\)</span></td>
<td style="text-align: left;">以 <span
class="math inline">\(\texttt{TikZ}\)</span>
为基础提供排版样式丰富的彩色盒子的功能。</td>
</tr>
</tbody>
</table>
<h3 id="图表和浮动体">图表和浮动体</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">宏包</th>
<th style="text-align: left;">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{array}\)</span></td>
<td style="text-align: left;">对表格列格式的扩展。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{booktabs}\)</span></td>
<td style="text-align: left;">排版三线表。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{tabularx}\)</span></td>
<td style="text-align: left;">提供 <span
class="math inline">\(\texttt{tabularx}\)</span>
环境排版定宽表格，支持自动计算宽度的 <span
class="math inline">\(\texttt{X}\)</span> 列格式。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{arydshln}\)</span></td>
<td style="text-align: left;">支持排版虚线表格线。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{colortbl}\)</span></td>
<td style="text-align: left;">支持修改表格的行、列、单元格的颜色。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{multirow}\)</span></td>
<td style="text-align: left;">支持合并多行单元格。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{makecell}\)</span></td>
<td
style="text-align: left;">支持在单元格里排版多行内容（嵌套一个单列的小表格）。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{diagbox}\)</span></td>
<td style="text-align: left;">排版斜线表头。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{longtable}\)</span></td>
<td style="text-align: left;">提供排版跨页长表格的 <span
class="math inline">\(\texttt{longtable}\)</span> 环境。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{ltxtable}\)</span></td>
<td style="text-align: left;">为跨页长表格提供 <span
class="math inline">\(\texttt{tabularx}\)</span> 的 <span
class="math inline">\(\texttt{X}\)</span> 列格式。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{tabularray}\)</span></td>
<td style="text-align: left;">排版复杂表格（基于 <span
class="math inline">\(\LaTeX3\)</span> 实现）。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{graphicx}\)</span></td>
<td style="text-align: left;">支持插图。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{bmpsize}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{latex}
+ \texttt{dvipdfmx}\)</span> 命令下支持 BMP/JPG/PNG 等格式的位图。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{epstopdf}\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\texttt{pdflatex}\)</span> 命令下支持 EPS
格式的矢量图。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{wrapfig}\)</span></td>
<td style="text-align: left;">支持简单的文字在图片周围的绕排。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{caption}\)</span></td>
<td style="text-align: left;">控制浮动体标题的格式。类似宏包有 <span
class="math inline">\(\texttt{keyfloat}\)</span> 等。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{subcaption}\)</span></td>
<td style="text-align: left;">提供子图表和子标题的排版。类似宏包有 <span
class="math inline">\(\texttt{subfigure}\)</span> 和 <span
class="math inline">\(\texttt{subfig}\)</span> 等。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{bicaption}\)</span></td>
<td style="text-align: left;">生成双语浮动体标题。</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\texttt{float}\)</span></td>
<td style="text-align: left;">为浮动体提供不浮动的 <span
class="math inline">\(\texttt{H}\)</span>
模式；提供自定义浮动体结构的功能。</td>
</tr>
</tbody>
</table>
<h3 id="修改版式">修改版式</h3>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr>
<th>宏包</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(\texttt{geometry}\)</span></td>
<td>修改页面尺寸、页边距、页眉页脚等参数。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{fancyhdr}\)</span></td>
<td>修改页眉页脚格式，令页眉页脚可以左对齐、居中、右对齐。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{titlesec}\)</span></td>
<td>修改章节标题 <code>\chapter</code>、<code>\section</code>
等的格式。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{titletoc}\)</span></td>
<td>修改目录中各条目的格式。类似宏包有 <span
class="math inline">\(\texttt{tocloft}\)</span> 等。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{tocbibind}\)</span></td>
<td>支持将目录、参考文献、索引本身写入目录项。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{footmisc}\)</span></td>
<td>修改脚注 <code>\footnote</code> 的格式。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{indentfirst}\)</span></td>
<td>令章节标题后的第一段首行缩进。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{enumerate}\)</span></td>
<td>提供简单的自定义标签格式的 <span
class="math inline">\(\texttt{enumerate}\)</span> 环境。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{enumitem}\)</span></td>
<td>修改列表环境 <span class="math inline">\(\texttt{enumerate}\)</span>
和 <span class="math inline">\(\texttt{itemize}\)</span> 等的格式。</td>
</tr>
<tr>
<td><span class="math inline">\(\texttt{lettrine}\)</span></td>
<td>生成段落首字母大写的效果。</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1] Partl H, Hyna I, Schlegl E. 一份 (不太) 简短的 LATEX2ε 介绍[J].
2024. <code>https://github.com/CTeX-org/lshort-zh-cn</code></p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Karl Berry, Jim Hefferon, Vincent Belaiche. LaTeXe: An
unofficial reference manual. (texdoc latex2e)<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Scott Pakin. The Comprehensive LaTeX Symbol List}.
(texdoc symbols-a4)<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之学习参考书籍（十一）</title>
    <url>/lang-latex/notes-lshort/11-reference-books/</url>
    <content><![CDATA[<p>本文推荐了一些 <span class="math inline">\(\LaTeX{}\)</span>
的经典书籍，供读者参考。</p>
<span id="more"></span>
<hr />
<h3 id="latex-经典书籍"><span class="math inline">\(\LaTeX{}\)</span>
经典书籍</h3>
<p>[1] Leslie Lamport. LaTeX: A Document Preparation System, 2nd
edition. Addison-Wesley, Reading, Massachusetts, 1994,
ISBN~0-201-52983-1.</p>
<p>[2] Frank Mittelbach, Michel Goossens, Johannes Braams, David
Carlisle, Chris Rowley. The LaTeX Companion, 2nd edition.
Addison-Wesley, Reading, Massachusetts, 2004, ISBN~0-201-36299-6.</p>
<p>[3] Michel Goossens, Sebastian Rahtz and Frank Mittelbach. The LaTeX
Graphics Companion, 2nd edition. Addison-Wesley, Reading, Massachusetts,
1997, ISBN~0-301-50892-0.</p>
<p>[4] Helmut Kopka and Patrick~W. Daly, Guide to LaTeX}, 4th edition.
Addison-Wesley, Reading, Massachusetts, 2004, ISBN~0-321-17385-6.</p>
<p>[5] 刘海洋. LaTeX 入门. 电子工业出版社, 北京, 2013,
ISBN~978-7-121-20208-7.</p>
<hr />
<h3
id="tex-经典书籍介绍底层的命令和排版方式有志深入学习-latex-者或参与宏包开发者必读有一些书籍已经开放网络资源"><span
class="math inline">\(\TeX{}\)</span>
经典书籍，介绍底层的命令和排版方式，有志深入学习 <span
class="math inline">\(\LaTeX{}\)</span>
者或参与宏包开发者必读。有一些书籍已经开放网络资源</h3>
<p>[6] Donald~E. Knuth. The TeX book, Volume A of Computers and
Typesetting, 2nd edition. Addison-Wesley, Reading, Massachusetts, 1984,
ISBN~0-201-13448-9.</p>
<p>[7] Paul Abrahams, Kathryn A. Hargreaves, Karl Berry. <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL0NUQU4vaW5mby9pbXBhdGllbnQvYm9vay5wZGY=">TeX
for the impatient, 2nd edition<i class="fa fa-external-link-alt"></i></span>. Addison-Wesley, Reading,
Massachusetts, 1984, ISBN~0-201-51375-7. (<strong>texdoc
impatient</strong>)</p>
<p>[8] Victor Eijkhout. <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL0NUQU4vaW5mby90ZXhieXRvcGljL1RlWGJ5VG9waWMucGRm">TeX
by Topic, A TeX nician’s Reference<i class="fa fa-external-link-alt"></i></span>. Addison-Wesley, Reading,
Massachusetts, 1992, ISBN~0-201-56882-9. (<strong>texdoc
texbytopic</strong>)</p>
<hr />
<h3
id="tex-发行版内置的资源除宏包帮助手册之外的一些文档可以在本地使用-texttttexdoc-命令查找也可以在-ctan-上找到"><span
class="math inline">\(\TeX{}\)</span>
发行版内置的资源（除宏包帮助手册之外的一些文档），可以在本地使用 <span
class="math inline">\(\texttt{texdoc}\)</span> 命令查找，也可以在 CTAN
上找到</h3>
<p>[9] <span class="math inline">\(\LaTeX{}\)</span> Project Team.
LaTeXe for authors.(<strong>texdoc usrguide</strong>)</p>
<p>[10] <span class="math inline">\(\LaTeX{}\)</span> Project Team.
LaTeXe for class and package writers. (<strong>texdoc
clsguide</strong>)</p>
<p>[11] <span class="math inline">\(\LaTeX{}\)</span> Project Team.
LaTeXe font selection. (<strong>texdoc fntguide</strong>)</p>
<p>[12] Karl Berry, Jim Hefferon, Vincent Belaiche. LaTeXe: An
unofficial reference manual. (<strong>texdoc latex2e</strong>)</p>
<p>[13] Jurgen Fenn. An essential guide to LaTeXe usage: Obsolete
commands and packages (English translation). (<strong>texdoc
l2tabuen</strong>)</p>
<p>[14] Scott Pakin. The Comprehensive LaTeX Symbol List.
(<strong>texdoc symbols-a4</strong>)</p>
<p>[15] Winston Chang. LaTeXe Cheat Sheet. (<strong>texdoc
latexcheat</strong>)</p>
<hr />
<h3 id="ctan-上的其它网络资源">CTAN 上的其它网络资源</h3>
<p>[16] Stephen~G. Hartke. <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL0NUQU4vaW5mby9GcmVlX01hdGhfRm9udF9TdXJ2ZXkvc3VydmV5LnBkZg==">A
Survey of Free Math Fonts for TeX and LaTeX<i class="fa fa-external-link-alt"></i></span>.</p>
<hr />
<h3 id="其它网络渠道可获得的资源">其它网络渠道可获得的资源</h3>
<p>[17] The TeX FAQ List. <span class="exturl" data-url="aHR0cHM6Ly90ZXhmYXEub3Jn">The TeX
Frequently Asked Question List<i class="fa fa-external-link-alt"></i></span>.</p>
<p>[18] learnlatex.org. <span class="exturl" data-url="aHR0cHM6Ly93d3cubGVhcm5sYXRleC5vcmc=">Learn LaTeX
online<i class="fa fa-external-link-alt"></i></span>.</p>
<p>[19] Palle Jorgensen. <span class="exturl" data-url="aHR0cHM6Ly90dWcub3JnL0ZvbnRDYXRhbG9ndWUv">The
LaTeX font catalogue, a font catalogue of LaTeX font packages<i class="fa fa-external-link-alt"></i></span>.</p>
<p>[20] Indian TeX users group. <span class="exturl" data-url="aHR0cHM6Ly93d3cudHVnLm9yZy90d2cvbWFjdGV4L3R1dG9yaWFscy9sdHhwcmltZXItMS4wLnBkZg==">LaTeX
Tutorials: A primer<i class="fa fa-external-link-alt"></i></span>.</p>
<p>[21] Overleaf. <span class="exturl" data-url="aHR0cHM6Ly93d3cub3ZlcmxlYWYuY29tL2xlYXJu">Overleaf
Documentation<i class="fa fa-external-link-alt"></i></span>.</p>
<p>[22] 黄新刚. <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1YW5neGcvbG5vdGVzL3Jhdy9tYXN0ZXIvbG5vdGVzMi5wZGY=">雷太赫排版系统简介(LaTeX
Notes)<i class="fa fa-external-link-alt"></i></span>, 第二版. （旧版：<strong>texdoc
latex-notes-zh-cn</strong>）</p>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$ 之符号表</title>
    <url>/lang-latex/notes-lshort/symbol-table/</url>
    <content><![CDATA[<p>本文主体内容来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NUZVgtb3JnL2xzaG9ydC16aC1jbg==">一份 (不太) 简短的
LATEX2ε 介绍<i class="fa fa-external-link-alt"></i></span>。</p>
<p>本文介绍了在 <span class="math inline">\(\LaTeX{}\)</span>
中常用的符号。</p>
<span id="more"></span>
<hr />
<p>有几个注意事项：</p>
<ol type="1">
<li>蓝色的命令依赖 <code>amsmath 宏包</code>（非 <code>amssymb</code>
宏包）；</li>
<li>带有角标 <span class="math inline">\(\ell\)</span> 的符号命令依赖
<code>latexsym</code> 宏包。</li>
</ol>
<h2 id="latex-普通符号"><span class="math inline">\(\LaTeX{}\)</span>
普通符号</h2>
<h3 id="文本数学模式通用符号">文本/数学模式通用符号</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120181959362.png" alt="image-20250120181959362" style="zoom:67%;" /></p>
<h3 id="希腊字母">希腊字母</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182031782.png" alt="image-20250120182031782" style="zoom:67%;" /></p>
<h3 id="二元关系符">二元关系符</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182111315.png" alt="image-20250120182111315" style="zoom:67%;" /></p>
<h3 id="二元运算符">二元运算符</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182201060.png" alt="image-20250120182201060" style="zoom:67%;" /></p>
<h3 id="巨算符">巨算符</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182228062.png" alt="image-20250120182228062" style="zoom:67%;" /></p>
<h3 id="数学重音符号">数学重音符号</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182250603.png" alt="image-20250120182250603" style="zoom:67%;" /></p>
<h3 id="箭头">箭头</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182315227.png" alt="image-20250120182315227" style="zoom:67%;" /></p>
<h3 id="作为重音的箭头符号">作为重音的箭头符号</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182339796.png" alt="image-20250120182339796" style="zoom:67%;" /></p>
<h3 id="定界符">定界符</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182407131.png" alt="image-20250120182407131" style="zoom:67%;" /></p>
<h3 id="用于行间公式的大定界符">用于行间公式的大定界符</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182438387.png" alt="image-20250120182438387" style="zoom:67%;" /></p>
<h3 id="其他符号">其他符号</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182501021.png" alt="image-20250120182501021" style="zoom:67%;" /></p>
<hr />
<h2 id="ams-符号">AMS 符号</h2>
<p>本小节所有符号依赖 <code>amssymb</code> 宏包。</p>
<h3 id="ams希腊字符和希伯来字母">AMS希腊字符和希伯来字母</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182624893.png" alt="image-20250120182624893" style="zoom:67%;" /></p>
<h3 id="ams-二元关系符">AMS 二元关系符</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182650748.png" alt="image-20250120182650748" style="zoom:67%;" /></p>
<h3 id="ams-二元运算符">AMS 二元运算符</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182713010.png" alt="image-20250120182713010" style="zoom:67%;" /></p>
<h3 id="ams-箭头">AMS 箭头</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182742368.png" alt="image-20250120182742368" style="zoom:67%;" /></p>
<h3 id="ams-反义二元关系符和箭头">AMS 反义二元关系符和箭头</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120182804491.png" alt="image-20250120182804491" style="zoom:67%;" /></p>
<h3 id="ams-定界符">AMS 定界符</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120204824904.png" alt="image-20250120204824904" style="zoom:67%;" /></p>
<h3 id="ams-其他符号">AMS 其他符号</h3>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250120204936578.png" alt="image-20250120204936578" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>LaTeX学习笔记</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX{}$各种发行版安装配置教程</title>
    <url>/lang-latex/usage-skills/latex-distribution-install-configure-tutorial/</url>
    <content><![CDATA[<p><span class="math inline">\(\TeX\)</span>/<span
class="math inline">\(\LaTeX\)</span>
并不是单独的程序，现在的TeX系统都是复杂的软件包，里面包含各种排版的引擎、编译脚本、格式转换工具、管理界面、配置文件、支持工具、字体及数以千计的宏包和文档。一个TeX发行版就是把所有这样的部件整合起来，打包发布的软件。</p>
<p>两个比较流行的发行版是CTeX套装和TeX
Live。前者是Windows系统下的软件，后者可以用在各种常见的桌面操作系统上。</p>
<span id="more"></span>
<hr />
<h2 id="windows安装latex">Windows安装LaTeX</h2>
<h3 id="ctex安装">1. CTEX安装</h3>
<p>官网网站：<span class="exturl" data-url="aHR0cHM6Ly9jdGV4Lm9yZy8=">https://ctex.org/<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><p>稳定版本</p>
<p>CTeX 3.0.216.3</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2N0ZXgvMy4wLw==">https://mirrors.tuna.tsinghua.edu.cn/ctex/3.0/<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20240805160610675.png" alt="image-20240805160610675" style="zoom: 33%;" /></p>
<p>下载图中三个文件，其中<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2N0ZXgvMy4wL0NUZVhfMy4wLjIxNS4yX0Z1bGwuZXhl">CTeX_3.0.215.2_Full.exe<i class="fa fa-external-link-alt"></i></span>为32位/64位通用版本，<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2N0ZXgvMy4wL0NUZVhfMy4wLjIxNS4yX0Z1bGwubnNpc2Jpbg==">CTeX_3.0.215.2_Full.nsisbin<i class="fa fa-external-link-alt"></i></span>是数据文件，<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2N0ZXgvMy4wL0NUZVhfMy4wLjIxNi4zX1VwZGF0ZS5leGU=">CTeX_3.0.216.3_Update.exe<i class="fa fa-external-link-alt"></i></span>是更新文件。</p>
<p>下载后将这三个文件放在<strong>同一文件夹</strong>下，以管理员方式启动exe文件开始安装，安装路径选择<strong>不带中文路径与空格</strong>，安装时间取决于具体机型。安装完成后提示是否在线更新miktex，选择否，安装时间较长，后面可根据需要更新宏包。</p></li>
<li><p>旧版本</p></li>
</ul>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2N0ZXgvbGVnYWN5LzIuOS9DVGVYXzIuOS4yLjE2N19GdWxsLmV4ZQ==">CTeX_2.9.2.167_Full.exe<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h4 id="winedt11激活码">WinEdt11激活码</h4>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">name: *60[20220501] Warez_Down [RU-BOARD] (100 users)</span><br><span class="line">code:4049089118892183088</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="texlive安装">2. TexLive安装</h3>
<p>历史版本：<span class="exturl" data-url="aHR0cHM6Ly9waS5rd2FyYy5pbmZvL2hpc3RvcmljL3N5c3RlbXMvdGV4bGl2ZS8=">https://pi.kwarc.info/historic/systems/texlive/<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="图形界面安装步骤"><strong>图形界面安装步骤：</strong></h4>
<ol type="1">
<li>下载<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL0NUQU4vc3lzdGVtcy90ZXhsaXZlL0ltYWdlcy8=">镜像文件<i class="fa fa-external-link-alt"></i></span>;
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20241108203305777.png" alt="image-20241108203305777" style="zoom: 33%;" /></li>
<li>在英文路径下解压texlive.iso文件，右键install-tl-windows.bat，以管理员身份打开；
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20241108204658453.png" alt="image-20241108204658453" style="zoom: 33%;" /></li>
<li>选择安装路径（使用英文不带括号的路径），点击安装；
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20241108204923261.png" alt="image-20241108204923261" style="zoom:50%;" /></li>
<li>漫长等待，安装完成
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20241112162248529.png" alt="image-20241112162248529" style="zoom:50%;" /></li>
</ol>
<p>texlive2025安装完成界面如下：</p>
<p>（可能是去掉了欢迎界面，查看安装目录下<code>texlive\2025\install-tl.log</code>最后出现
<strong>欢迎进入 TeX Live
的世界！</strong>的日志，基本上可以放心点击关闭）
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20250417144717830.png" alt="image-20250417144717830" style="zoom:50%;" />
5. Win+R输入cmd，分别输入tex -v，latex -v，xelatex -v，pdflatex
-v进行验证。</p>
<h4 id="命令行安装texlive步骤">命令行安装texlive步骤</h4>
<blockquote>
<ol type="1">
<li>下载镜像文件.iso，并装载；</li>
<li>以管理员方式打开cmd，切换到装载磁盘；</li>
<li>输入 <code>install-tl-windows.bat --no-gui</code>；</li>
<li>输入D 设置路径，再输入1来改变安装路径， 之后输入
<code>d:/install/texlive/2025</code>；</li>
<li>输入R返回主菜单，之后输入I开始安装。</li>
</ol>
</blockquote>
<h3 id="texstudio安装">3. TexStudio安装</h3>
<p><strong>安装包下载：</strong></p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly90ZXhzdHVkaW8uc291cmNlZm9yZ2UubmV0Lw==">官网主页<i class="fa fa-external-link-alt"></i></span></p></li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2dpdGh1Yi1yZWxlYXNlL3RleHN0dWRpby1vcmcvdGV4c3R1ZGlvL0xhdGVzdFJlbGVhc2Uv">国内镜像<i class="fa fa-external-link-alt"></i></span></p></li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RleHN0dWRpby1vcmcvdGV4c3R1ZGlvL3JlbGVhc2VzP3BhZ2U9MQ==">历史版本<i class="fa fa-external-link-alt"></i></span></p></li>
</ul>
<p><strong>安装步骤</strong>：傻瓜式安装，中间可以切换安装路径，不带中文路径，C盘容量较小可以切换其他盘符。</p>
<h3 id="vscode环境配置">4. VSCode环境配置</h3>
<ol type="1">
<li><p>打开VS
Code，点击左侧扩展图标，搜索<code>LaTeX Workshop</code>,点击第一个进行下载安装。</p></li>
<li><p>配置环境，在VS
Code界面快捷键<code>Ctrl Shift + P</code>，输入<code>Open Settings</code>，回车打开<code>Settings.json</code>文件。在文件中的<code>&#123;&#125;</code>中添加以下代码：</p></li>
</ol>
<details>
<summary>
<font size="4" color="orange">Show Code</font>
</summary>
<pre><code class="language-json">// 编译工具和命令
    "latex-workshop.latex.tools": [
        &#123;
            "name": "pdflatex",
            "command": "pdflatex",
            "args": [
                "-synctex=1",
                "-interaction=nonstopmode",
                "-file-line-error",
                "%DOCFILE%"
            ]
        &#125;,
        &#123;
            "name": "xelatex",
            "command": "xelatex",
            "args": [
                "-synctex=1",
                "-interaction=nonstopmode",
                "-file-line-error",
                "%DOCFILE%"
            ]
        &#125;,
        &#123;
            "name": "bibtex",
            "command": "bibtex",
            "args": [
                "%DOCFILE%"
            ]
        &#125;
    ],
    // 用于配置编译链
    "latex-workshop.latex.recipes": [
        &#123;
            "name": "xelatex",
            "tools": [
                "xelatex"
            ],
        &#125;,
        &#123;
            "name": "pdflatex",
            "tools": [
                "pdflatex"
            ]
        &#125;,
        &#123;
            "name": "xe->bib->xe->xe",
            "tools": [
                "xelatex",
                "bibtex",
                "xelatex",
                "xelatex"
            ]
        &#125;,
        &#123;
            "name": "pdf->bib->pdf->pdf",
            "tools": [
                "pdflatex",
                "bibtex",
                "pdflatex",
                "pdflatex"
            ]
        &#125;
    ],
     //文件清理。此属性必须是字符串数组
    "latex-workshop.latex.clean.fileTypes": [
        "*.aux",
        "*.bbl",
        "*.blg",
        "*.idx",
        "*.ind",
        "*.lof",
        "*.lot",
        "*.out",
        "*.toc",
        "*.acn",
        "*.acr",
        "*.alg",
        "*.glg",
        "*.glo",
        "*.gls",
        "*.ist",
        "*.fls",
        "*.log",
        "*.fdb_latexmk"
    ],
    //tex文件浏览器，可选项为"none" "browser" "tab" "external"
    "latex-workshop.view.pdf.viewer": "tab",
    //设置是否自动编译tex文件
    "latex-workshop.latex.autoBuild.run": "never",
    //右键菜单，显示内容菜单：（1）编译文件；（2）定位游标
    "latex-workshop.showContextMenu": true,
    //显示错误
    "latex-workshop.message.error.show": false,
    //显示警告
    "latex-workshop.message.warning.show": false,
    //从使用的包中自动补全命令和环境
    "latex-workshop.intellisense.package.enabled": true,
    //设置为never，为不清除辅助文件
    "latex-workshop.latex.autoClean.run": "never",
    //设置vscode编译tex文档时的默认编译链
    "latex-workshop.latex.recipe.default": "lastUsed",
    // 用于反向同步的内部查看器的键绑定。ctrl/cmd +点击(默认)或双击
    "latex-workshop.view.pdf.internal.synctex.keybinding": "double-click",</code>
</pre>
</details>
<ol start="3" type="1">
<li>编译<code>.tex</code>文件
打开Latex模板，打开<code>*.tex</code>文件夹，这时发现左侧多了一个<code>TEX</code>的图标，这就是<code>LaTeX Workshop</code>扩展。
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20241116141827720.png" alt="image-20241116141827720" style="zoom:33%;" /></li>
</ol>
<p>点击它打开，再点击左上角<code>构建LaTeX</code>中的配方条目，根据<code>*.tex</code>文件要求选择不同的条目进行编译。</p>
<p>编译失败则会显示<code>×</code>，其左侧的<code>!</code>显示的是警告，点击可以查看原因。点击上方的预览按钮，即可查看生成的<code>*.pdf</code>文件。
<img data-src="https://zzz-drawing-bed.oss-cn-nanjing.aliyuncs.com/img/image-20241116142705560.png" alt="image-20241116142705560" style="zoom: 33%;" /></p>
<hr />
<h2 id="linux-安装latex">Linux 安装LaTeX</h2>
<h3 id="基于-debianubuntu-的系统">1. 基于 Debian/Ubuntu 的系统</h3>
<p>Debian 和 Ubuntu 使用 <code>apt</code>
包管理器。以下是常用安装命令：</p>
<ol type="1">
<li><p><strong>安装基础版本</strong>（适合轻量需求）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install texlive-base</span><br></pre></td></tr></table></figure>
<p>包含基本的 LaTeX 运行环境。</p></li>
<li><p><strong>安装完整版本</strong>（推荐，包含所有功能和扩展包）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install texlive-full</span><br></pre></td></tr></table></figure>
<p>这是一个较大的安装包（约 3-4 GB），包含几乎所有的 LaTeX 包。</p></li>
<li><p><strong>安装常用版本</strong>（适合大多数用户）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install texlive-latex-extra</span><br></pre></td></tr></table></figure>
<p>包含大部分常用的 LaTeX 功能（如图形、表格支持）。</p></li>
<li><p><strong>安装 PDF 引擎和编辑工具（可选）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install texlive-fonts-recommended texlive-publishers texlive-science texmaker</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="基于-red-hatcentosfedora-的系统">2. 基于 Red Hat/CentOS/Fedora
的系统</h3>
<p>Red Hat 系列使用 <code>dnf</code> 或 <code>yum</code> 包管理器：</p>
<ol type="1">
<li><p><strong>更新包管理器</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf update</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装 TeX Live</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install texlive</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装完整版本（包含所有包）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install texlive-scheme-full</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="基于-arch-linux-的系统">3. 基于 Arch Linux 的系统</h3>
<p>Arch 系列使用 <code>pacman</code> 包管理器：</p>
<ol type="1">
<li><p><strong>安装 TeX Live</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S texlive-most</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装完整版本（如果需要额外的功能）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S texlive-full</span><br></pre></td></tr></table></figure></li>
</ol>
<hr />
<h3 id="通过官方-tex-live-安装器">4. 通过官方 TeX Live 安装器</h3>
<p>如果系统提供的包版本较旧，或者你需要特定版本，可以通过 TeX Live
官方安装程序进行安装：</p>
<ol type="1">
<li><p><strong>下载 TeX Live 安装器</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p><strong>解压安装器</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvzf install-tl-unx.tar.gz</span><br><span class="line"><span class="built_in">cd</span> install-tl-*</span><br></pre></td></tr></table></figure></li>
<li><p><strong>运行安装程序</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./install-tl</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装完成后配置环境变量</strong>： 编辑
<code>~/.bashrc</code> 文件，添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/local/texlive/2024/bin/x86_64-linux:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>然后运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="验证安装">5. 验证安装</h3>
<p>无论使用哪种方法，安装完成后可以通过以下命令验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">latex --version</span><br><span class="line">pdflatex --version</span><br></pre></td></tr></table></figure>
<p>如果输出版本号，说明安装成功。</p>
<h3 id="推荐的-latex-编辑器">6. 推荐的 LaTeX 编辑器</h3>
<p>除了安装 LaTeX，你可能还需要一个编辑器来编写文档：</p>
<ul>
<li><p>TeXworks：轻量级，适合初学者。</p></li>
<li><p>Texmaker：跨平台，功能全面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install texmaker  <span class="comment"># Debian/Ubuntu</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install texmaker  <span class="comment"># Red Hat/CentOS/Fedora</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>VS Code</strong>：使用 LaTeX Workshop 插件。</p></li>
<li><p><strong>Overleaf</strong>：在线编辑器，不需要本地安装。</p></li>
</ul>
]]></content>
      <categories>
        <category>LaTeX</category>
        <category>使用技巧</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
</search>
